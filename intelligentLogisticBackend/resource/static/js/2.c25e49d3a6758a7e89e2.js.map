{"version":3,"sources":["webpack:///./node_modules/echarts/lib/component/toolbox/ToolboxView.js","webpack:///./node_modules/echarts/lib/layout/points.js","webpack:///./node_modules/echarts/lib/chart/helper/Symbol.js","webpack:///./node_modules/echarts/lib/chart/bar/BaseBarSeries.js","webpack:///./node_modules/echarts/lib/component/markPoint.js","webpack:///./node_modules/echarts/lib/component/axis/AxisView.js","webpack:///./node_modules/echarts/lib/chart/line.js","webpack:///./node_modules/echarts/lib/component/axisPointer/AxisPointerView.js","webpack:///./node_modules/echarts/lib/coord/cartesian/Cartesian2D.js","webpack:///./node_modules/echarts/lib/coord/cartesian/Grid.js","webpack:///./node_modules/core-js/library/fn/array/from.js","webpack:///./src/assets/AI.png","webpack:///./node_modules/echarts/lib/component/tooltip/TooltipModel.js","webpack:///./node_modules/echarts/lib/component/dataZoom/history.js","webpack:///./node_modules/echarts/lib/component/axisPointer.js","webpack:///./node_modules/echarts/lib/component/toolbox/feature/SaveAsImage.js","webpack:///./node_modules/echarts/lib/visual/symbol.js","webpack:///./node_modules/echarts/lib/coord/cartesian/GridModel.js","webpack:///./node_modules/echarts/lib/component/axisPointer/CartesianAxisPointer.js","webpack:///./node_modules/echarts/lib/chart/bar/BarSeries.js","webpack:///./node_modules/echarts/lib/component/toolbox/feature/DataZoom.js","webpack:///./node_modules/echarts/lib/component/axisPointer/globalListener.js","webpack:///./node_modules/echarts/lib/lang.js","webpack:///./node_modules/echarts/lib/component/dataZoom/AxisProxy.js","webpack:///./node_modules/echarts/lib/chart/bar.js","webpack:///./node_modules/babel-runtime/helpers/toConsumableArray.js","webpack:///./node_modules/echarts/lib/component/toolbox/feature/Restore.js","webpack:///./node_modules/echarts/lib/component/dataZoom/dataZoomAction.js","webpack:///./node_modules/echarts/lib/chart/line/poly.js","webpack:///./node_modules/echarts/lib/component/marker/MarkerModel.js","webpack:///./node_modules/echarts/lib/component/helper/cursorHelper.js","webpack:///./node_modules/echarts/lib/component/tooltip.js","webpack:///./node_modules/echarts/lib/component/axisPointer/BaseAxisPointer.js","webpack:///./node_modules/echarts/lib/component/axisPointer/findPointFromSeries.js","webpack:///./node_modules/echarts/lib/processor/dataSample.js","webpack:///./node_modules/time-formater/lib/timeformater.js","webpack:///./node_modules/echarts/lib/chart/bar/barItemStyle.js","webpack:///./node_modules/echarts/lib/component/axisPointer/modelHelper.js","webpack:///./node_modules/echarts/lib/coord/cartesian/Axis2D.js","webpack:///./node_modules/echarts/lib/component/toolbox/feature/MagicType.js","webpack:///./node_modules/echarts/lib/chart/helper/labelHelper.js","webpack:///./node_modules/echarts/lib/component/marker/MarkerView.js","webpack:///./node_modules/echarts/lib/chart/line/lineAnimationDiff.js","webpack:///./node_modules/echarts/lib/component/axisPointer/AxisPointerModel.js","webpack:///./node_modules/echarts/lib/component/gridSimple.js","webpack:///./node_modules/echarts/lib/component/dataZoom/SelectZoomView.js","webpack:///./node_modules/echarts/lib/component/tooltip/TooltipView.js","webpack:///./node_modules/echarts/lib/component/helper/BrushTargetManager.js","webpack:///./node_modules/echarts/lib/component/toolbox.js","webpack:///./node_modules/echarts/lib/component/helper/brushHelper.js","webpack:///./node_modules/echarts/lib/component/tooltip/TooltipContent.js","webpack:///./node_modules/echarts/lib/component/toolbox/ToolboxModel.js","webpack:///./node_modules/echarts/lib/component/dataZoom/dataZoomProcessor.js","webpack:///./node_modules/babel-runtime/core-js/array/from.js","webpack:///./node_modules/echarts/lib/chart/line/LineView.js","webpack:///./node_modules/echarts/lib/coord/cartesian/Cartesian.js","webpack:///./node_modules/echarts/lib/component/dataZoom/typeDefaulter.js","webpack:///./node_modules/echarts/lib/component/toolbox/featureManager.js","webpack:///./node_modules/echarts/lib/chart/helper/SymbolDraw.js","webpack:///./node_modules/echarts/lib/component/axisPointer/axisTrigger.js","webpack:///./node_modules/echarts/lib/chart/bar/helper.js","webpack:///./node_modules/echarts/lib/coord/axisModelCreator.js","webpack:///./node_modules/echarts/lib/chart/bar/BarView.js","webpack:///./node_modules/echarts/lib/coord/cartesian/AxisModel.js","webpack:///./node_modules/core-js/library/modules/_create-property.js","webpack:///./node_modules/echarts/lib/component/dataZoom/DataZoomView.js","webpack:///./node_modules/echarts/lib/chart/line/LineSeries.js","webpack:///./node_modules/echarts/lib/component/axis/cartesianAxisHelper.js","webpack:///./node_modules/echarts/lib/component/dataZoomSelect.js","webpack:///src/components/tendency.vue","webpack:///./src/components/tendency.vue?294b","webpack:///./src/components/tendency.vue","webpack:///src/page/home.vue","webpack:///./src/page/home.vue?c40b","webpack:///./src/page/home.vue","webpack:///./node_modules/echarts/lib/layout/barGrid.js","webpack:///./node_modules/echarts/lib/component/helper/interactionMutex.js","webpack:///./node_modules/echarts/lib/component/helper/BrushController.js","webpack:///./node_modules/echarts/lib/component/helper/sliderMove.js","webpack:///./node_modules/echarts/lib/component/marker/MarkPointModel.js","webpack:///./node_modules/core-js/library/modules/es6.array.from.js","webpack:///./node_modules/echarts/lib/component/dataZoom/SelectZoomModel.js","webpack:///./node_modules/echarts/lib/coord/axisDefault.js","webpack:///./node_modules/echarts/lib/component/dataZoom/helper.js","webpack:///./node_modules/echarts/lib/component/axis/CartesianAxisView.js","webpack:///./node_modules/echarts/lib/component/dataZoom/DataZoomModel.js","webpack:///./node_modules/echarts/lib/component/toolbox/feature/DataView.js","webpack:///./node_modules/echarts/lib/component/marker/MarkPointView.js","webpack:///./node_modules/echarts/lib/component/axis/AxisBuilder.js","webpack:///./node_modules/echarts/lib/component/marker/markerHelper.js","webpack:///./node_modules/echarts/lib/component/axisPointer/viewHelper.js","webpack:///./node_modules/echarts/lib/component/axis.js"],"names":["echarts","__webpack_require__","zrUtil","textContain","featureManager","graphic","Model","DataDiffer","listComponentHelper","_default","extendComponentView","type","render","toolboxModel","ecModel","api","payload","group","this","removeAll","get","itemSize","featureOpts","features","_features","featureNames","each","opt","name","push","_featureNames","add","processFeature","update","remove","curry","execute","layout","makeBackground","getBoundingRect","eachChild","icon","titleText","__title","hoverStyle","rect","makeFont","offsetX","position","needPutOnTop","height","getHeight","textPosition","topOffset","width","getWidth","textAlign","newIndex","oldIndex","feature","featureName","oldName","featureOpt","featureModel","indexOf","isUserFeatureName","model","onclick","option","Feature","unusable","iconStyleModel","getModel","icons","getIcons","titles","title","iconPaths","iconStr","iconName","path","createIcon","x","y","setStyle","getItemStyle","setHoverStyle","on","text","textFill","fill","stroke","trigger","bind","createIconPaths","setIconStatus","status","iconStatus","dispose","updateView","updateLayout","module","exports","seriesType","eachSeriesByType","seriesModel","data","getData","coordSys","coordinateSystem","dims","coordDims","dimensions","i","length","coordDimToDataDim","idx","setItemLayout","isNaN","NaN","dataToPoint","createSymbol","parsePercent","findLabelValueDim","getScale","symbolSize","SymbolClz","seriesScope","Group","call","updateData","symbolProto","prototype","driftSymbol","dx","dy","parent","drift","_createSymbol","symbolType","color","getItemVisual","symbolPath","attr","z2","culling","scale","_symbolType","stopSymbolAnimation","toLastFrame","childAt","stopAnimation","getSymbolPath","highlight","downplay","setZ","zlevel","z","setDraggable","draggable","cursor","silent","hostModel","Array","slice","getSymbolSize","isInit","updateProps","_updateCommon","fadeIn","target","style","opacity","initProps","_seriesModel","normalStyleAccessPath","emphasisStyleAccessPath","normalLabelAccessPath","emphasisLabelAccessPath","useStyle","strokeNoScale","itemStyle","hoverItemStyle","symbolRotate","symbolOffset","labelModel","hoverLabelModel","hoverAnimation","cursorStyle","hasItemOption","itemModel","getItemModel","getShallow","extend","elStyle","Math","PI","setColor","symbolInnerColor","useNameLabel","valueDim","setLabelStyle","labelFetcher","labelDataIndex","defaultText","getName","isRectText","autoColor","off","isAnimationEnabled","onEmphasis","ratio","animateTo","max","onNormal","fadeOut","cb","keepLabel","dataIndex","inherits","SeriesModel","createListFromArray","getInitialData","getMarkerPosition","value","pt","offset","getLayout","size","getBaseAxis","isHorizontal","defaultOption","legendHoverLink","barMinHeight","barMinAngle","registerPreprocessor","markPoint","__DEV__","axisPointerModelHelper","AxisView","_axisPointer","axisPointerClass","axisModel","fixValue","superApply","arguments","updateAxisPointer","force","axisPointer","disposeAxisPointer","axisView","forceRender","Clazz","getAxisPointerClass","axisPointerModel","getAxisPointerModel","axisPointerClazz","registerAxisPointerClass","clazz","visualSymbol","layoutPoints","dataSample","registerVisual","registerLayout","registerProcessor","PRIORITY","PROCESSOR","STATISTIC","globalListener","AxisPointerView","globalAxisPointerModel","globalTooltipModel","getComponent","triggerOn","register","currTrigger","e","dispatchAction","offsetY","unregister","getZr","_model","Cartesian","Cartesian2D","constructor","getAxesByScale","getAxis","containPoint","point","axisX","axisY","contain","toLocalCoord","containData","clamp","xAxis","yAxis","toGlobalCoord","dataToCoord","pointToData","coordToData","getOtherAxis","axis","dim","BoundingRect","getLayoutRect","axisHelper","Axis2D","CoordinateSystem","ifAxisCrossZero","niceScaleExtent","isAxisUsedInTheGrid","gridModel","getCoordSysModel","Grid","_coordsMap","_coordsList","_axesMap","_axesList","_initCartesian","gridProto","fixAxisOnZero","axesMap","otherAxisDim","axes","onZero","onZeroAxisIndex","hasOwnProperty","otherAxis","canNotOnZeroToAxis","axisPointerEnabled","getRect","_rect","_updateScale","resize","ignoreContainLabel","gridRect","getBoxLayoutParams","axesList","adjustAxes","extent","inverse","setExtent","coordBase","axisExtent","getExtent","axisExtentSum","coord","updateAxisTransfrom","labelUnionRect","textRect","rotate","rotateRadians","boundingBox","beforeWidth","beforeHeight","afterWidth","afterHeight","labels","getFormattedLabels","axisLabelModel","step","labelCount","ceil","isLabelIgnored","unrotatedSingleRect","getTextRect","singleRect","plain","cos","sin","union","getLabelUnionRect","margin","axisType","axisIndex","axesMapOnDim","getAxes","getCartesian","xAxisIndex","yAxisIndex","key","isObject","coordList","index","getCartesians","convertToPixel","finder","_findConvertTarget","cartesian","convertFromPixel","xAxisModel","getReferringComponents","yAxisModel","coordsList","componentIndex","axisPositionUsed","left","right","top","bottom","axesCount","eachComponent","createAxisCreator","axisPosition","createScaleByModel","isCategory","onBand","grid","addAxis","unionExtent","unionExtentFromData","Infinity","eachSeries","isCartesian2D","axesModels","findAxesModels","getTooltipAxes","baseAxes","otherAxes","baseAxis","axesTypes","map","create","grids","from","p","extendComponentModel","dependencies","show","showContent","alwaysShowContent","displayMode","confine","showDelay","hideDelay","transitionDuration","enterable","backgroundColor","borderColor","borderRadius","borderWidth","padding","extraCssText","animation","animationDurationUpdate","animationEasingUpdate","crossStyle","textStyle","fontSize","ATTR","giveStore","store","newSnapshot","batchItem","dataZoomId","dataZoomModel","queryComponents","mainType","subType","id","percentRange","getPercentRange","start","end","pop","head","snapshot","clear","count","axisTrigger","link","isArray","coordSysAxesInfo","collect","registerAction","event","env","lang","saveAsImageLang","toolbox","saveAsImage","SaveAsImage","excludeComponents","pixelRatio","canvasSupported","$a","document","createElement","download","url","getConnectedDataURL","href","MouseEvent","browser","ie","edge","window","navigator","msSaveOrOpenBlob","bstr","atob","split","n","u8arr","Uint8Array","charCodeAt","blob","Blob","html","open","write","evt","view","bubbles","cancelable","dispatchEvent","defaultSymbolType","legendSymbol","eachRawSeriesByType","setVisual","symbol","isSeriesFiltered","rawValue","getRawValue","params","getDataParams","setItemVisual","itemSymbolType","itemSymbolSize","layoutMode","containLabel","BaseAxisPointer","viewHelper","cartesianAxisHelper","CartesianAxisPointer","makeElOption","elOption","axisPointerType","otherExtent","getGlobalExtent","pixelValue","buildElStyle","pointerOption","pointerShapeBuilder","graphicKey","pointer","layoutInfo","buildCartesianSingleLabelElOption","getHandleTransform","labelInside","labelMargin","getTransformedPosition","rotation","labelDirection","updateHandleTransform","transform","delta","dimIndex","currPosition","min","cursorOtherValue","cursorPoint","tooltipOption","verticalAlign","align","line","targetShape","makeLineShape","getAxisDimIndex","subPixelOptimizeLine","shape","shadow","bandWidth","getBandWidth","span","makeRectShape","brushSelector","BrushController","BrushTargetManager","history","sliderMove","dataZoomLang","dataZoom","DATA_ZOOM_ID_BASE","DataZoom","_brushController","_onBrush","mount","_isZoomActive","zoom","back","clone","proto","zoomActive","dataZoomSelectActive","brushTargetManager","retrieveAxisSetting","include","setPanels","makePanelOpts","targetInfo","xAxisDeclared","yAxisDeclared","enableBrush","brushType","brushStyle","lineWidth","updateZoomBtnStatus","updateBackBtnStatus","handlers","unmount","nextActive","_dispatchZoomAction","setting","areas","isEnd","updateCovers","matchOutputRanges","area","coordRange","setBatch","lineX","lineY","dimName","minMax","found","dzModel","getAxisModel","findDataZoom","minMaxSpan","findRepresentativeAxisProxy","getMinMaxSpan","minValueSpan","maxValueSpan","startValue","endValue","batch","uid","dataZoomOpts","toolboxOpt","dataZoomOpt","addForAxis","axisName","axisIndicesName","givenAxisIndices","opts","forEachComponent","axisOpt","newOpt","$fromToolbox","makeGetter","onLeave","record","handler","doEnter","node","zr","records","useHandler","eventType","dis","pendings","showTip","hideTip","pendingList","makeDispatchAction","actuallyPayload","showLen","hideLen","dispatchTooltipFinally","initialized","initGlobalListeners","brush","polygon","keep","dataView","magicType","bar","stack","tiled","restore","numberUtil","helper","asc","AxisProxy","_dimName","_axisIndex","_valueWindow","_percentWindow","_dataExtent","_minMaxSpan","_dataZoomModel","setAxisModel","axisProxy","isRestore","percentWindow","valueWindow","precision","getPixelPrecision","useOrigin","setRange","toFixed","hostedBy","getDataValueWindow","getDataPercentWindow","getTargetSeriesModels","seriesModels","isCoordSupported","getOtherAxisModel","coordSysIndexName","foundOtherAxisModel","axisDim","otherAxisModel","calculateDataWindow","dataExtent","rangePropMode","getRangePropMode","percentExtent","prop","parse","boundValue","boundPercent","linearMap","reset","seriesData","seriesExtent","getDataExtent","getMin","isCategoryAxis","axisDataLen","getMax","fixExtentByAxis","calculateDataExtent","dataWindow","valueSpan","setMinMaxSpan","filterData","filterMode","dataDims","filterSelf","leftOut","rightOut","hasValue","thisHasValue","thisLeftOut","thisRightOut","setData","isInWindow","barLayoutGrid","__esModule","obj","_from","_from2","default","arr","arr2","restoreLang","Restore","resetOption","linkedNodesFinder","createLinkedNodesFinder","eachAxisDim","dimNames","effectedModels","query","apply","nodes","setRawRange","Path","vec2","fixClipWithShadow","vec2Min","vec2Max","scaleAndAdd","v2Copy","copy","v","cp0","cp1","isPointNull","drawSegment","ctx","points","segLen","allLen","dir","smoothMin","smoothMax","smooth","smoothMonotone","connectNulls","prevIdx","k","nextIdx","nextP","ratioNextSeg","prevP","lenPrevSeg","lenNextSeg","sub","abs","dist","bezierCurveTo","lineTo","getBoundingBox","smoothConstraint","ptMin","ptMax","Polyline","buildPath","len","result","Polygon","stackedOnPoints","stackedOnSmooth","bbox","stackedOnBBox","closePath","modelUtil","formatUtil","addCommas","encodeHTML","fillLabel","defaultEmphasis","label","MarkerModel","init","parentModel","extraOpt","mergeDefaultAndTheme","mergeOption","createdBySelf","hostSeries","__hostSeries","modelPropName","markerOpt","markerModel","item","seriesIndex","formatTooltip","formattedValue","join","_data","mixin","dataFormatMixin","IRRELEVANT_EXCLUDES","tooltip","onIrrelevantElement","targetCoordSysModel","getComponentByElement","topTarget","clazzUtil","eventTool","throttleUtil","animationModel","moveAnimation","el","props","propsEqual","lastProps","newProps","equals","lastProp","updateLabelShowHide","labelEl","getHandleTransProps","trans","updateMandatoryProps","traverse","_group","_lastGraphicKey","_handle","_dragging","_lastValue","_lastStatus","_payloadInfo","animationThreshold","_axisModel","_axisPointerModel","_api","handle","hide","_moveAnimation","determineAnimation","doUpdateProps","updatePointerEl","updateLabelEl","createPointerEl","createLabelEl","_renderHandle","useSnap","seriesDataCount","getAxisInfo","pointerEl","Rect","handleModel","onmousemove","stop","onmousedown","_onHandleDragMove","ondragend","_onHandleDragEnd","handleSize","createOrUpdate","_moveHandleToValue","_doDispatchAxisPointer","payloadInfo","axesInfo","doClear","buildLabel","xy","wh","xDimIndex","enableClassExtend","getSeriesByIndex","queryDataIndex","getItemGraphicEl","getTooltipPosition","getValues","applyTransform","samplers","average","frame","sum","nearest","indexSampler","round","sampling","sampler","valueAxis","rate","downSample","MONTH_DISPLAY","WEEK_DISPLAY","UNIT_SIZE","d","H","m","s","S","TimeFormater","input","Date","[object Object]","token","toLocaleString","replace","match","oldTime","getTime","newTime","now","diff","floor","parseInt","fillZero","num","getFullYear","M","getMonth","getDate","D","getDay","dd","getHours","h","getMinutes","getSeconds","getMilliseconds","SSS","SS","hm","findIndex","A","countdown","time","endPoint","format","remain","all","r","str","toString","getBarItemStyle","makeStyleMapper","excludes","getBorderLineDash","lineDash","checkPropInLink","linkPropValue","axisPropValue","makeKey","isHandleTrigger","seriesInvolved","coordSysMap","linksOption","linkGroups","getCoordinateSystems","coordSysKey","axesInfoInCoordSys","coordSysModel","baseTooltipModel","saveTooltipAxisInfo","triggerAxis","cross","tooltipAxes","fromTooltip","triggerTooltip","axisPointerShow","snap","tooltipAxisPointerModel","volatileOption","field","labelOption","lineStyle","defaults","makeAxisPointerModel","involveSeries","axisInfo","useHandle","groupIndex","linkOption","getLinkGroupIndex","linkGroup","mapper","collectAxesInfo","seriesTooltipTrigger","seriesTooltipShow","collectSeriesInfo","reverse","isBlank","Axis","coordExtent","ret","labelInterval","getLabelInterval","getLabel","magicTypeLang","MagicType","availableIcons","seriesOptGenreator","seriesId","merge","markLine","radioTypes","newOption","series","radio","newSeriesOpt","categoryAxis","boundaryGap","currentType","otherDimToDataDim","labelDims","dataType","getDimensionInfo","markerGroupMap","createHashMap","__keep","markerModelKey","renderSeries","sign","val","getStackedOnPoint","stackedOnSameSign","valueStart","baseDataOffset","stackedOn","stackedData","oldData","newData","oldStackedOnPoints","newStackedOnPoints","oldCoordSys","newCoordSys","diffResult","cmd","newIdx","oldIdx","idx1","diffData","currPoints","nextPoints","currStackedPoints","nextStackedPoints","sortedIndices","rawIndices","diffItem","pointAdded","currentPt","getItemLayout","nextPt","getRawIndex","rawIndex","sort","a","b","sortedCurrPoints","sortedNextPoints","sortedCurrStackedPoints","sortedNextStackedPoints","sortedStatus","current","next","stackedOnCurrent","stackedOnNext","shadowStyle","formatter","shadowBlur","shadowColor","shadowOffsetX","shadowOffsetY","throttle","TooltipContent","findPointFromSeries","layoutUtil","axisPointerViewHelper","proxyRect","tooltipContent","getDom","_tooltipContent","tooltipModel","_tooltipModel","_ecModel","_lastDataByCoordSys","_alwaysShowContent","setEnterable","_initGlobalListener","_keepShow","_tryShow","_hide","_lastX","_lastY","self","clearTimeout","_refreshUpdateTimeout","setTimeout","manuallyShowTip","_ticket","dataByCoordSys","_manuallyAxisShowTip","pointInfo","cx","cy","findHover","manuallyHideTip","hideLater","buildTooltipModel","_showAxisTooltip","_showSeriesItemTooltip","_showComponentItemTooltip","_showOrMove","delay","_showTimout","singleDefaultHTML","singleParamsList","singleTooltipModel","itemCoordSys","dataByAxis","axisValue","seriesDefaultHTML","valueLabel","getValueLabel","seriesDataIndices","valueLabelOpt","idxItem","dataIndexInside","dataParams","axisId","getAxisRawValue","axisValueLabel","firstLine","positionExpr","_updateContentNotChangedOnAxis","_updatePosition","_showTooltipContent","random","dataModel","tooltipTrigger","defaultHtml","asyncTicket","tooltipOpt","content","subTooltipModel","formatTpl","callback","cbTicket","setContent","viewWidth","viewHeight","contentSize","getSize","vAlign","viewSize","layoutRect","pos","domWidth","domHeight","rectWidth","rectHeight","calcTooltipPosition","gapH","gapV","getOuterSize","refixTooltipPosition","isCenterAlign","confineTooltipPosition","moveTo","lastCoordSys","contentNotChanged","lastItemCoordSys","indexCoordSys","lastDataByAxis","thisDataByAxis","lastItem","indexAxis","thisItem","lastIndices","newIndices","lastIdxItem","j","newIdxItem","modelCascade","resultModel","clientWidth","clientHeight","defaultView","getComputedStyle","stl","paddingLeft","paddingRight","borderLeftWidth","borderRightWidth","paddingTop","paddingBottom","borderTopWidth","borderBottomWidth","brushHelper","COORD_CONVERTS","INCLUDE_FINDER_MAIN_TYPES","targetInfoList","_targetInfoList","info","foundCpts","parseFinder","targetInfoBuilders","builder","formatMinMax","includeMainTypes","setOutputRanges","coordRanges","coordConvert","__rangeOffset","diffProcessor","values","range","xyMinMax","findTargetInfo","coordSyses","setInputRanges","xyMinMaxCurr","xyMinMaxOrigin","sizeCurr","sizeOrigin","scales","panelId","rangeOffset","getDefaultBrushType","getPanelRect","defaultBrushType","clipPath","makeRectPanelClipPath","isTargetByCursor","makeRectIsTargetByCursor","getLinearBrushOtherExtent","makeLinearBrushOtherExtent","controlSeries","areaPanelId","targetInfoMatchers","xAxisModels","yAxisModels","gridModels","gridModelMap","xAxesHas","yAxesHas","set","cartesians","panelRectBuilder","geo","geoModels","geoModel","getTransform","axisConvert","to","rangeOrCoordRange","xminymin","xmaxymax","axisNameIndex","axisDiffProcessor","refer","graphicUtil","normalizeRect","localPoints","clipPointsByRect","specifiedXYIndex","xyIndex","brushWidth","base","targetModel","localCursorPoint","zrColor","eventUtil","toCamelCase","vendors","assembleCssText","duration","transitionText","cssText","textStyleModel","vendorPrefix","toHex","borderName","camelCase","getTextColor","getFont","assembleFont","normalizeCssArray","container","_zr","_x","_y","appendChild","_container","_show","_hideTimeout","onmouseenter","_enterable","_inContent","normalizeEvent","dispatch","onmouseleave","_hideDelay","currentStyle","domStyle","display","innerHTML","viewportRootOffset","painter","getViewportRootOffset","offsetLeft","offsetTop","isShow","ToolboxModel","ignoreSize","orient","itemGap","showTitle","iconStyle","normal","emphasis","resetSingleAxis","getAxisProxy","filterSingleAxis","eachTargetAxis","valueRange","SymbolDraw","lineAnimationDiff","_poly","ChartView","isPointsSame","points1","points2","p1","p2","getSmooth","getAxisExtentWithGap","halfBandWidth","createClipShape","hasAnimation","polar","angleAxis","getAngleAxis","radiusExtent","getRadiusAxis","angleExtent","RADIAN","Sector","r0","startAngle","endAngle","clockwise","createPolarClipShape","xExtent","yExtent","expandSize","createGridClipShape","turnPointsIntoStep","stepTurnAt","baseIndex","stepPoints","stepPt","middle","stepPt2","lineGroup","symbolDraw","_symbolDraw","_lineGroup","lineStyleModel","areaStyleModel","mapArray","isCoordSysPolar","prevCoordSys","_coordSys","polyline","_polyline","_polygon","isAreaChart","isEmpty","getStackedOnPoints","showSymbol","isSymbolIgnore","_getSymbolIgnoreFunc","eachItemGraphicEl","__temp","setItemGraphicEl","_step","_newPolygon","setClipPath","_stackedOnPoints","_points","_updateAnimation","setShape","_newPolyline","visualColor","visualMetaList","getVisual","visualMeta","dimension","colorStops","stops","stopLen","outerColors","minCoord","maxCoord","coordSpan","unshift","gradient","LinearGradient","getVisualGradient","getLineStyle","lineJoin","getAreaStyle","ignore","__points","updatedDataInfo","diffStatus","ptIdx","animators","during","dimAxisMapper","_axes","_dimList","scaleType","toLowerCase","filter","_dataCoordConvert","method","dimList","output","registerSubTypeDefaulter","ctor","symbolCtor","_symbolCtor","symbolDrawProto","symbolNeedsDraw","isIgnore","SymbolCtor","symbolEl","enableAnimation","modelHelper","processOnAxis","newValue","updaters","dontSnap","outputFinder","snapToValue","payloadBatch","minDist","Number","MAX_VALUE","minDiff","seriesNestestValue","dataIndices","dataDim","getAxisTooltipData","nestestValue","indicesOfNearest","isFinite","buildPayloadsBySeries","showPointer","showTooltip","showValueMap","coordSysItem","coordSysId","coordSysIndex","coordSysType","coordSysMainType","list","makeMapperParam","illegalPoint","isIllegalPoint","inputAxesInfo","shouldHide","coordSysContainsPoint","inputAxisInfo","findInputAxisInfo","linkTriggers","tarAxisInfo","tarKey","srcAxisInfo","srcKey","srcValItem","outputAxesInfo","valItem","updateModelActually","sampleItem","escapeConnect","dispatchTooltipActually","lastHighlights","newHighlights","toHighlight","toDownplay","dispatchHighDownActually","fixPosition","labelPositionOutside","setLabel","normalStyle","axisDefault","ComponentModel","_layout","getLayoutParams","mergeLayoutParam","AXIS_TYPES","BaseAxisModelClass","axisTypeDefaulter","extraDefaultOption","inputPositionParams","themeModel","getTheme","getDefaultOption","mergeAll","barItemStyle","BAR_BORDER_WIDTH_QUERY","extendChartView","coordinateSystemType","_render","noop","isHorizontalOrRadial","elementCreator","updateStyle","removeRect","removeSector","cartesian2d","isUpdate","rectShape","animateProperty","animateTarget","isRadial","sector","sectorShape","fixedLineWidth","rawLayout","getLineWidth","signX","signY","isPolar","itemStyleModel","axisModelCreator","axisModelCommonMixin","AxisModel","resetRange","restoreData","gridIndex","gridId","getAxisType","extraOption","$defineProperty","createDesc","object","f","getTargetCoordInfo","coordSysLists","coordModel","coordIndex","axisModels","save","clipOverflow","showAllSymbol","animationEasing","progressive","hoverLayerThreshold","rawAxisPosition","rectBound","axisOffset","posBound","onZeroCoord","tickDirection","nameDirection","labelOffset","retrieve","labelRotate","tendency","mounted","myChart","echarts_default","getElementById","initData","methods","subtext","legend","readOnly","sevenDay","axisLine","axisLabel","sevenDate","setOption","watch","components_tendency","$createElement","_self","_c","_m","staticRenderFns","_h","staticClass","staticStyle","attrs","src_components_tendency","normalizeComponent","ssrContext","home","userCount","orderCount","adminCount","allUserCount","allOrderCount","allAdminCount","components","headTop","date","timeformater_default","getSevenData","computed","_this","asyncToGenerator_default","regenerator_default","mark","_callee","today","wrap","_context","prev","promise_default","Object","then","res","catch","err","console","log","_this2","_callee2","apiArr","promiseArr","_context2","forEach","concat","toConsumableArray_default","resArr","page_home","_v","src","home_Component","home_normalizeComponent","__webpack_exports__","STACK_PREFIX","getSeriesStackId","getAxisKey","doCalBarWidthAndOffset","seriesInfoList","columnsMap","seriesInfo","axisKey","columnsOnAxis","remainedWidth","autoWidthCount","categoryGap","gap","stacks","stackId","maxWidth","barWidth","barMaxWidth","barGap","barCategoryGap","coordSysName","barGapPercent","autoWidth","column","lastColumn","widthSum","barSeries","barWidthAndOffset","getSeriesByType","lastStackCoords","lastStackCoordsOrigin","columnLayoutInfo","columnOffset","columnWidth","valueAxisStart","coords","setLayout","lastCoord","lastCoordOrigin","getLayoutOnAxis","widthAndOffsets","offsetCenter","getStore","take","resourceKey","userKey","release","isTaken","Eventful","interactionMutex","mathMin","mathMax","mathPow","pow","COVER_Z","UNSELECT_THRESHOLD","MIN_RESIZE_LINE_WIDTH","MUTEX_RESOURCE_KEY","DIRECTION_MAP","w","CURSOR_MAP","ne","sw","nw","se","DEFAULT_BRUSH_OPT","transformable","brushMode","removeOnClick","baseUID","_brushType","_brushOption","_panels","_track","_covers","_creatingCover","_creatingPanel","_enableGlobalPan","_uid","_handlers","mouseHandlers","eventName","createCover","controller","brushOption","cover","coverRenderers","__brushOption","updateZ","endCreating","creatingCover","coverRenderer","getCoverRenderer","updateCoverShape","updateCoverAfterCreation","updateCommon","getPanelByPoint","panel","panels","_transform","pn","getPanelByCover","clearCovers","covers","originalLength","getTrackEnds","track","tail","createBaseRectCover","doDrift","edgeNames","makeStyle","invisible","updateBaseRect","localRange","xa","ya","x2","y2","x2a","y2a","widtha","heighta","updateRectShape","mainEl","childOfName","globalDir","getGlobalDirection","localDirection","transformDirection","xmin","ymin","xmax","ymax","clipByPanel","formatRectRange","driftRect","toRectRange","fromRectRange","rectRange","localDelta","toLocalDelta","namePart","ind","driftPolygon","thisGroup","localD","transformCoordToLocal","localZero","preventDefault","rawE","mainShapeContain","updateCoverByMouse","eventParams","thisBrushOption","shouldShowCover","determineBrushType","getCreatingRange","doEnableBrush","panelOpts","enableGlobalPan","getLocalTransform","eachCover","context","brushOptionList","tmpIdPrefix","oldCovers","newCovers","getKey","addOrUpdate","newBrushOption","mousedown","handleDragEnd","mousemove","currPanel","setCursorStyle","resetCursor","mouseup","getLineRenderer","localTrack","ends","getSpanSign","handleEnds","handleIndex","restrict","minSpan","maxSpan","extentSpan","originalDistSign","extentMinSpan","realExtent","currDistSign","$export","toObject","isArrayIter","toLength","createProperty","getIterFn","F","iter","arrayLike","iterator","O","C","aLen","mapfn","undefined","mapping","iterFn","done","nameLocation","nameRotate","nameTruncate","ellipsis","placeholder","nameTextStyle","nameGap","triggerEvent","axisTick","inside","showMinLabel","showMaxLabel","splitLine","splitArea","areaStyle","alignWithLabel","interval","splitNumber","timeAxis","logAxis","logBase","COORDS","createNameEach","names","capitalNames","capitalFirst","capitalAttrs","nameObj","capital","coordType","forEachNode","forEachEdgeType","edgeIdGetter","sourceNode","existsLink","edgeType","absorb","processSingleNode","isNodeAbsorded","hasLink","edgeId","isLinked","AxisBuilder","ifIgnoreOnTick","getInterval","axisBuilderAttrs","selfBuilderAttrs","CartesianAxisView","oldAxisGroup","_axisGroup","axisBuilder","getGroup","groupTransition","superCall","_splitLine","splitLineModel","lineColors","lineInterval","lineCount","ticksCoords","getTicksCoords","ticks","getTicks","tickCoord","colorIndex","Line","anid","x1","y1","_splitArea","splitAreaModel","areaColors","prevX","prevY","areaInterval","retrieveRaw","updateRangeUse","rawOption","_rangePropMode","rangeModeInOption","percentSpecified","valueSpecified","rangeMode","_dataIntervalByAxis","_dataInfo","_axisProxies","_autoThrottle","doInit","thisOption","realtime","_setDefaultThrottle","_resetTarget","_giveAxisProxies","axisProxies","dependentModels","__dzAxisProxy","autoMode","_judgeAutoMode","axisIndexName","normalizeToArray","_autoSetAxisIndex","_autoSetOrient","hasIndexSpecified","autoAxisIndex","singleAxis","singleAxisModel","singleAxisIndex","axisIndices","_isSeriesHasAllAxesTypeOf","is","seriesAxisIndex","globalOption","getFirstTargetAxisModel","firstAxisModel","indices","ignoreUpdateRangeUsg","getValueRange","axisDimName","dataViewLang","BLOCK_SPLITER","ITEM_SPLITER","getContentFromModel","tables","seriesGroupByCategoryAxis","otherSeries","meta","eachRawSeries","other","groupSeries","valueAxisDim","headers","columns","getCategories","getRawData","lines","items","vals","argLen","assembleOtherSeries","trim","itemSplitRegex","RegExp","parseContents","blockMetaList","blocks","block","isTSVFormat","tsv","tsvLines","shift","categories","header","parseTSVContents","blockMeta","seriesName","hasName","parseListContents","DataView","_dom","optionToContent","contentToOption","textColor","textareaColor","textareaBorderColor","buttonColor","buttonTextColor","removeChild","root","viewMain","textarea","htmlOrDom","getOption","isDom","buttonContainer","buttonStyle","closeButton","refreshButton","close","addEventListener","Error","keyCode","which","selectionStart","selectionEnd","substring","newSeriesOptList","seriesOpt","getSeriesByName","originalData","newVal","original","tryMergeDataOption","List","markerHelper","updateMarkerLayout","mpData","xPx","yPx","markPointModel","mpModel","symbolDrawMap","coordDimsInfos","coordDim","dataOpt","dataTransform","dataFilter","dimValueGetter","createList","child","_util","_number","isRadianAroundZero","remRadian","matrixUtil","v2ApplyTransform","makeAxisEventDataBase","eventData","componentType","dumbGroup","updateTransform","_dumbGroup","hasBuilder","builders","matrix","pt1","pt2","lineCap","strokeContainThreshold","arrows","arrowSize","symbolWidth","symbolHeight","axisTickLabel","tickEls","tickModel","tickLen","tickInterval","ticksCnt","tickEl","buildAxisTick","labelEls","firstLabel","nextLabel","lastLabel","prevLabel","firstTick","nextTick","lastTick","prevTick","ignoreEl","isTwoLabelOverlapped","fixMinMaxLabelShow","axisLabelShow","labelRotation","labelLayout","innerTextLayout","categoryData","isSilent","tickVal","itemLabelModel","labelStr","textEl","Text","setTextStyle","textVerticalAlign","targetType","decomposeTransform","buildAxisLabel","axisNameAvailableWidth","gapSignal","isNameLocationCenter","nameRotation","textRotate","rotationDiff","onLeft","endTextLayout","textFont","truncateOpt","nameTruncateMaxWidth","truncatedText","truncateText","minChar","formatterParams","$vars","__fullText","__truncatedText","axisRotation","textRotation","direction","firstRect","nextRect","mRotationBack","identity","mul","intersect","rawTick","markerTypeCalculatorWithExtent","mlType","otherDataDim","targetDataDim","otherCoordIndex","targetCoordIndex","coordArr","numCalculate","getPrecision","markerTypeCalculator","valueIndex","valueDataDim","getDimension","dataDimToCoordDim","baseDataDim","parseFloat","hasXAndY","radiusAxis","hasXOrY","buildLabelElOption","labelPos","paddings","font","confineInContainer","bgColor","isString","isFunction","translate","styleModel","textLayout","makeSectorShape"],"mappings":"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","file":"static/js/2.c25e49d3a6758a7e89e2.js","sourcesContent":["var echarts = require(\"../../echarts\");\n\nvar zrUtil = require(\"zrender/lib/core/util\");\n\nvar textContain = require(\"zrender/lib/contain/text\");\n\nvar featureManager = require(\"./featureManager\");\n\nvar graphic = require(\"../../util/graphic\");\n\nvar Model = require(\"../../model/Model\");\n\nvar DataDiffer = require(\"../../data/DataDiffer\");\n\nvar listComponentHelper = require(\"../helper/listComponent\");\n\nvar _default = echarts.extendComponentView({\n  type: 'toolbox',\n  render: function (toolboxModel, ecModel, api, payload) {\n    var group = this.group;\n    group.removeAll();\n\n    if (!toolboxModel.get('show')) {\n      return;\n    }\n\n    var itemSize = +toolboxModel.get('itemSize');\n    var featureOpts = toolboxModel.get('feature') || {};\n    var features = this._features || (this._features = {});\n    var featureNames = [];\n    zrUtil.each(featureOpts, function (opt, name) {\n      featureNames.push(name);\n    });\n    new DataDiffer(this._featureNames || [], featureNames).add(processFeature).update(processFeature).remove(zrUtil.curry(processFeature, null)).execute(); // Keep for diff.\n\n    this._featureNames = featureNames;\n\n    function processFeature(newIndex, oldIndex) {\n      var featureName = featureNames[newIndex];\n      var oldName = featureNames[oldIndex];\n      var featureOpt = featureOpts[featureName];\n      var featureModel = new Model(featureOpt, toolboxModel, toolboxModel.ecModel);\n      var feature;\n\n      if (featureName && !oldName) {\n        // Create\n        if (isUserFeatureName(featureName)) {\n          feature = {\n            model: featureModel,\n            onclick: featureModel.option.onclick,\n            featureName: featureName\n          };\n        } else {\n          var Feature = featureManager.get(featureName);\n\n          if (!Feature) {\n            return;\n          }\n\n          feature = new Feature(featureModel, ecModel, api);\n        }\n\n        features[featureName] = feature;\n      } else {\n        feature = features[oldName]; // If feature does not exsit.\n\n        if (!feature) {\n          return;\n        }\n\n        feature.model = featureModel;\n        feature.ecModel = ecModel;\n        feature.api = api;\n      }\n\n      if (!featureName && oldName) {\n        feature.dispose && feature.dispose(ecModel, api);\n        return;\n      }\n\n      if (!featureModel.get('show') || feature.unusable) {\n        feature.remove && feature.remove(ecModel, api);\n        return;\n      }\n\n      createIconPaths(featureModel, feature, featureName);\n\n      featureModel.setIconStatus = function (iconName, status) {\n        var option = this.option;\n        var iconPaths = this.iconPaths;\n        option.iconStatus = option.iconStatus || {};\n        option.iconStatus[iconName] = status; // FIXME\n\n        iconPaths[iconName] && iconPaths[iconName].trigger(status);\n      };\n\n      if (feature.render) {\n        feature.render(featureModel, ecModel, api, payload);\n      }\n    }\n\n    function createIconPaths(featureModel, feature, featureName) {\n      var iconStyleModel = featureModel.getModel('iconStyle'); // If one feature has mutiple icon. they are orginaized as\n      // {\n      //     icon: {\n      //         foo: '',\n      //         bar: ''\n      //     },\n      //     title: {\n      //         foo: '',\n      //         bar: ''\n      //     }\n      // }\n\n      var icons = feature.getIcons ? feature.getIcons() : featureModel.get('icon');\n      var titles = featureModel.get('title') || {};\n\n      if (typeof icons === 'string') {\n        var icon = icons;\n        var title = titles;\n        icons = {};\n        titles = {};\n        icons[featureName] = icon;\n        titles[featureName] = title;\n      }\n\n      var iconPaths = featureModel.iconPaths = {};\n      zrUtil.each(icons, function (iconStr, iconName) {\n        var path = graphic.createIcon(iconStr, {}, {\n          x: -itemSize / 2,\n          y: -itemSize / 2,\n          width: itemSize,\n          height: itemSize\n        });\n        path.setStyle(iconStyleModel.getModel('normal').getItemStyle());\n        path.hoverStyle = iconStyleModel.getModel('emphasis').getItemStyle();\n        graphic.setHoverStyle(path);\n\n        if (toolboxModel.get('showTitle')) {\n          path.__title = titles[iconName];\n          path.on('mouseover', function () {\n            // Should not reuse above hoverStyle, which might be modified.\n            var hoverStyle = iconStyleModel.getModel('emphasis').getItemStyle();\n            path.setStyle({\n              text: titles[iconName],\n              textPosition: hoverStyle.textPosition || 'bottom',\n              textFill: hoverStyle.fill || hoverStyle.stroke || '#000',\n              textAlign: hoverStyle.textAlign || 'center'\n            });\n          }).on('mouseout', function () {\n            path.setStyle({\n              textFill: null\n            });\n          });\n        }\n\n        path.trigger(featureModel.get('iconStatus.' + iconName) || 'normal');\n        group.add(path);\n        path.on('click', zrUtil.bind(feature.onclick, feature, ecModel, api, iconName));\n        iconPaths[iconName] = path;\n      });\n    }\n\n    listComponentHelper.layout(group, toolboxModel, api); // Render background after group is layout\n    // FIXME\n\n    group.add(listComponentHelper.makeBackground(group.getBoundingRect(), toolboxModel)); // Adjust icon title positions to avoid them out of screen\n\n    group.eachChild(function (icon) {\n      var titleText = icon.__title;\n      var hoverStyle = icon.hoverStyle; // May be background element\n\n      if (hoverStyle && titleText) {\n        var rect = textContain.getBoundingRect(titleText, textContain.makeFont(hoverStyle));\n        var offsetX = icon.position[0] + group.position[0];\n        var offsetY = icon.position[1] + group.position[1] + itemSize;\n        var needPutOnTop = false;\n\n        if (offsetY + rect.height > api.getHeight()) {\n          hoverStyle.textPosition = 'top';\n          needPutOnTop = true;\n        }\n\n        var topOffset = needPutOnTop ? -5 - rect.height : itemSize + 8;\n\n        if (offsetX + rect.width / 2 > api.getWidth()) {\n          hoverStyle.textPosition = ['100%', topOffset];\n          hoverStyle.textAlign = 'right';\n        } else if (offsetX - rect.width / 2 < 0) {\n          hoverStyle.textPosition = [0, topOffset];\n          hoverStyle.textAlign = 'left';\n        }\n      }\n    });\n  },\n  updateView: function (toolboxModel, ecModel, api, payload) {\n    zrUtil.each(this._features, function (feature) {\n      feature.updateView && feature.updateView(feature.model, ecModel, api, payload);\n    });\n  },\n  updateLayout: function (toolboxModel, ecModel, api, payload) {\n    zrUtil.each(this._features, function (feature) {\n      feature.updateLayout && feature.updateLayout(feature.model, ecModel, api, payload);\n    });\n  },\n  remove: function (ecModel, api) {\n    zrUtil.each(this._features, function (feature) {\n      feature.remove && feature.remove(ecModel, api);\n    });\n    this.group.removeAll();\n  },\n  dispose: function (ecModel, api) {\n    zrUtil.each(this._features, function (feature) {\n      feature.dispose && feature.dispose(ecModel, api);\n    });\n  }\n});\n\nfunction isUserFeatureName(featureName) {\n  return featureName.indexOf('my') === 0;\n}\n\nmodule.exports = _default;\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/echarts/lib/component/toolbox/ToolboxView.js\n// module id = +PQg\n// module chunks = 1 2","function _default(seriesType, ecModel) {\n  ecModel.eachSeriesByType(seriesType, function (seriesModel) {\n    var data = seriesModel.getData();\n    var coordSys = seriesModel.coordinateSystem;\n\n    if (!coordSys) {\n      return;\n    }\n\n    var dims = [];\n    var coordDims = coordSys.dimensions;\n\n    for (var i = 0; i < coordDims.length; i++) {\n      dims.push(seriesModel.coordDimToDataDim(coordSys.dimensions[i])[0]);\n    }\n\n    if (dims.length === 1) {\n      data.each(dims[0], function (x, idx) {\n        // Also {Array.<number>}, not undefined to avoid if...else... statement\n        data.setItemLayout(idx, isNaN(x) ? [NaN, NaN] : coordSys.dataToPoint(x));\n      });\n    } else if (dims.length === 2) {\n      data.each(dims, function (x, y, idx) {\n        // Also {Array.<number>}, not undefined to avoid if...else... statement\n        data.setItemLayout(idx, isNaN(x) || isNaN(y) ? [NaN, NaN] : coordSys.dataToPoint([x, y]));\n      }, true);\n    }\n  });\n}\n\nmodule.exports = _default;\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/echarts/lib/layout/points.js\n// module id = 1Nix\n// module chunks = 1 2","var zrUtil = require(\"zrender/lib/core/util\");\n\nvar _symbol = require(\"../../util/symbol\");\n\nvar createSymbol = _symbol.createSymbol;\n\nvar graphic = require(\"../../util/graphic\");\n\nvar _number = require(\"../../util/number\");\n\nvar parsePercent = _number.parsePercent;\n\nvar _labelHelper = require(\"./labelHelper\");\n\nvar findLabelValueDim = _labelHelper.findLabelValueDim;\n\n/**\n * @module echarts/chart/helper/Symbol\n */\nfunction getSymbolSize(data, idx) {\n  var symbolSize = data.getItemVisual(idx, 'symbolSize');\n  return symbolSize instanceof Array ? symbolSize.slice() : [+symbolSize, +symbolSize];\n}\n\nfunction getScale(symbolSize) {\n  return [symbolSize[0] / 2, symbolSize[1] / 2];\n}\n/**\n * @constructor\n * @alias {module:echarts/chart/helper/Symbol}\n * @param {module:echarts/data/List} data\n * @param {number} idx\n * @extends {module:zrender/graphic/Group}\n */\n\n\nfunction SymbolClz(data, idx, seriesScope) {\n  graphic.Group.call(this);\n  this.updateData(data, idx, seriesScope);\n}\n\nvar symbolProto = SymbolClz.prototype;\n\nfunction driftSymbol(dx, dy) {\n  this.parent.drift(dx, dy);\n}\n\nsymbolProto._createSymbol = function (symbolType, data, idx, symbolSize) {\n  // Remove paths created before\n  this.removeAll();\n  var color = data.getItemVisual(idx, 'color'); // var symbolPath = createSymbol(\n  //     symbolType, -0.5, -0.5, 1, 1, color\n  // );\n  // If width/height are set too small (e.g., set to 1) on ios10\n  // and macOS Sierra, a circle stroke become a rect, no matter what\n  // the scale is set. So we set width/height as 2. See #4150.\n\n  var symbolPath = createSymbol(symbolType, -1, -1, 2, 2, color);\n  symbolPath.attr({\n    z2: 100,\n    culling: true,\n    scale: getScale(symbolSize)\n  }); // Rewrite drift method\n\n  symbolPath.drift = driftSymbol;\n  this._symbolType = symbolType;\n  this.add(symbolPath);\n};\n/**\n * Stop animation\n * @param {boolean} toLastFrame\n */\n\n\nsymbolProto.stopSymbolAnimation = function (toLastFrame) {\n  this.childAt(0).stopAnimation(toLastFrame);\n};\n/**\n * FIXME:\n * Caution: This method breaks the encapsulation of this module,\n * but it indeed brings convenience. So do not use the method\n * unless you detailedly know all the implements of `Symbol`,\n * especially animation.\n *\n * Get symbol path element.\n */\n\n\nsymbolProto.getSymbolPath = function () {\n  return this.childAt(0);\n};\n/**\n * Get scale(aka, current symbol size).\n * Including the change caused by animation\n */\n\n\nsymbolProto.getScale = function () {\n  return this.childAt(0).scale;\n};\n/**\n * Highlight symbol\n */\n\n\nsymbolProto.highlight = function () {\n  this.childAt(0).trigger('emphasis');\n};\n/**\n * Downplay symbol\n */\n\n\nsymbolProto.downplay = function () {\n  this.childAt(0).trigger('normal');\n};\n/**\n * @param {number} zlevel\n * @param {number} z\n */\n\n\nsymbolProto.setZ = function (zlevel, z) {\n  var symbolPath = this.childAt(0);\n  symbolPath.zlevel = zlevel;\n  symbolPath.z = z;\n};\n\nsymbolProto.setDraggable = function (draggable) {\n  var symbolPath = this.childAt(0);\n  symbolPath.draggable = draggable;\n  symbolPath.cursor = draggable ? 'move' : 'pointer';\n};\n/**\n * Update symbol properties\n * @param {module:echarts/data/List} data\n * @param {number} idx\n * @param {Object} [seriesScope]\n * @param {Object} [seriesScope.itemStyle]\n * @param {Object} [seriesScope.hoverItemStyle]\n * @param {Object} [seriesScope.symbolRotate]\n * @param {Object} [seriesScope.symbolOffset]\n * @param {module:echarts/model/Model} [seriesScope.labelModel]\n * @param {module:echarts/model/Model} [seriesScope.hoverLabelModel]\n * @param {boolean} [seriesScope.hoverAnimation]\n * @param {Object} [seriesScope.cursorStyle]\n * @param {module:echarts/model/Model} [seriesScope.itemModel]\n * @param {string} [seriesScope.symbolInnerColor]\n * @param {Object} [seriesScope.fadeIn=false]\n */\n\n\nsymbolProto.updateData = function (data, idx, seriesScope) {\n  this.silent = false;\n  var symbolType = data.getItemVisual(idx, 'symbol') || 'circle';\n  var seriesModel = data.hostModel;\n  var symbolSize = getSymbolSize(data, idx);\n  var isInit = symbolType !== this._symbolType;\n\n  if (isInit) {\n    this._createSymbol(symbolType, data, idx, symbolSize);\n  } else {\n    var symbolPath = this.childAt(0);\n    symbolPath.silent = false;\n    graphic.updateProps(symbolPath, {\n      scale: getScale(symbolSize)\n    }, seriesModel, idx);\n  }\n\n  this._updateCommon(data, idx, symbolSize, seriesScope);\n\n  if (isInit) {\n    var symbolPath = this.childAt(0);\n    var fadeIn = seriesScope && seriesScope.fadeIn;\n    var target = {\n      scale: symbolPath.scale.slice()\n    };\n    fadeIn && (target.style = {\n      opacity: symbolPath.style.opacity\n    });\n    symbolPath.scale = [0, 0];\n    fadeIn && (symbolPath.style.opacity = 0);\n    graphic.initProps(symbolPath, target, seriesModel, idx);\n  }\n\n  this._seriesModel = seriesModel;\n}; // Update common properties\n\n\nvar normalStyleAccessPath = ['itemStyle', 'normal'];\nvar emphasisStyleAccessPath = ['itemStyle', 'emphasis'];\nvar normalLabelAccessPath = ['label', 'normal'];\nvar emphasisLabelAccessPath = ['label', 'emphasis'];\n/**\n * @param {module:echarts/data/List} data\n * @param {number} idx\n * @param {Array.<number>} symbolSize\n * @param {Object} [seriesScope]\n */\n\nsymbolProto._updateCommon = function (data, idx, symbolSize, seriesScope) {\n  var symbolPath = this.childAt(0);\n  var seriesModel = data.hostModel;\n  var color = data.getItemVisual(idx, 'color'); // Reset style\n\n  if (symbolPath.type !== 'image') {\n    symbolPath.useStyle({\n      strokeNoScale: true\n    });\n  }\n\n  var itemStyle = seriesScope && seriesScope.itemStyle;\n  var hoverItemStyle = seriesScope && seriesScope.hoverItemStyle;\n  var symbolRotate = seriesScope && seriesScope.symbolRotate;\n  var symbolOffset = seriesScope && seriesScope.symbolOffset;\n  var labelModel = seriesScope && seriesScope.labelModel;\n  var hoverLabelModel = seriesScope && seriesScope.hoverLabelModel;\n  var hoverAnimation = seriesScope && seriesScope.hoverAnimation;\n  var cursorStyle = seriesScope && seriesScope.cursorStyle;\n\n  if (!seriesScope || data.hasItemOption) {\n    var itemModel = seriesScope && seriesScope.itemModel ? seriesScope.itemModel : data.getItemModel(idx); // Color must be excluded.\n    // Because symbol provide setColor individually to set fill and stroke\n\n    itemStyle = itemModel.getModel(normalStyleAccessPath).getItemStyle(['color']);\n    hoverItemStyle = itemModel.getModel(emphasisStyleAccessPath).getItemStyle();\n    symbolRotate = itemModel.getShallow('symbolRotate');\n    symbolOffset = itemModel.getShallow('symbolOffset');\n    labelModel = itemModel.getModel(normalLabelAccessPath);\n    hoverLabelModel = itemModel.getModel(emphasisLabelAccessPath);\n    hoverAnimation = itemModel.getShallow('hoverAnimation');\n    cursorStyle = itemModel.getShallow('cursor');\n  } else {\n    hoverItemStyle = zrUtil.extend({}, hoverItemStyle);\n  }\n\n  var elStyle = symbolPath.style;\n  symbolPath.attr('rotation', (symbolRotate || 0) * Math.PI / 180 || 0);\n\n  if (symbolOffset) {\n    symbolPath.attr('position', [parsePercent(symbolOffset[0], symbolSize[0]), parsePercent(symbolOffset[1], symbolSize[1])]);\n  }\n\n  cursorStyle && symbolPath.attr('cursor', cursorStyle); // PENDING setColor before setStyle!!!\n\n  symbolPath.setColor(color, seriesScope && seriesScope.symbolInnerColor);\n  symbolPath.setStyle(itemStyle);\n  var opacity = data.getItemVisual(idx, 'opacity');\n\n  if (opacity != null) {\n    elStyle.opacity = opacity;\n  }\n\n  var useNameLabel = seriesScope && seriesScope.useNameLabel;\n  var valueDim = !useNameLabel && findLabelValueDim(data);\n\n  if (useNameLabel || valueDim != null) {\n    graphic.setLabelStyle(elStyle, hoverItemStyle, labelModel, hoverLabelModel, {\n      labelFetcher: seriesModel,\n      labelDataIndex: idx,\n      defaultText: useNameLabel ? data.getName(idx) : data.get(valueDim, idx),\n      isRectText: true,\n      autoColor: color\n    });\n  }\n\n  symbolPath.off('mouseover').off('mouseout').off('emphasis').off('normal');\n  symbolPath.hoverStyle = hoverItemStyle; // FIXME\n  // Do not use symbol.trigger('emphasis'), but use symbol.highlight() instead.\n\n  graphic.setHoverStyle(symbolPath);\n  var scale = getScale(symbolSize);\n\n  if (hoverAnimation && seriesModel.isAnimationEnabled()) {\n    var onEmphasis = function () {\n      var ratio = scale[1] / scale[0];\n      this.animateTo({\n        scale: [Math.max(scale[0] * 1.1, scale[0] + 3), Math.max(scale[1] * 1.1, scale[1] + 3 * ratio)]\n      }, 400, 'elasticOut');\n    };\n\n    var onNormal = function () {\n      this.animateTo({\n        scale: scale\n      }, 400, 'elasticOut');\n    };\n\n    symbolPath.on('mouseover', onEmphasis).on('mouseout', onNormal).on('emphasis', onEmphasis).on('normal', onNormal);\n  }\n};\n/**\n * @param {Function} cb\n * @param {Object} [opt]\n * @param {Object} [opt.keepLabel=true]\n */\n\n\nsymbolProto.fadeOut = function (cb, opt) {\n  var symbolPath = this.childAt(0); // Avoid mistaken hover when fading out\n\n  this.silent = symbolPath.silent = true; // Not show text when animating\n\n  !(opt && opt.keepLabel) && (symbolPath.style.text = null);\n  graphic.updateProps(symbolPath, {\n    style: {\n      opacity: 0\n    },\n    scale: [0, 0]\n  }, this._seriesModel, this.dataIndex, cb);\n};\n\nzrUtil.inherits(SymbolClz, graphic.Group);\nvar _default = SymbolClz;\nmodule.exports = _default;\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/echarts/lib/chart/helper/Symbol.js\n// module id = 1bHA\n// module chunks = 1 2","var SeriesModel = require(\"../../model/Series\");\n\nvar createListFromArray = require(\"../helper/createListFromArray\");\n\nvar _default = SeriesModel.extend({\n  type: 'series.__base_bar__',\n  getInitialData: function (option, ecModel) {\n    return createListFromArray(option.data, this, ecModel);\n  },\n  getMarkerPosition: function (value) {\n    var coordSys = this.coordinateSystem;\n\n    if (coordSys) {\n      // PENDING if clamp ?\n      var pt = coordSys.dataToPoint(value, true);\n      var data = this.getData();\n      var offset = data.getLayout('offset');\n      var size = data.getLayout('size');\n      var offsetIndex = coordSys.getBaseAxis().isHorizontal() ? 0 : 1;\n      pt[offsetIndex] += offset + size / 2;\n      return pt;\n    }\n\n    return [NaN, NaN];\n  },\n  defaultOption: {\n    zlevel: 0,\n    // 一级层叠\n    z: 2,\n    // 二级层叠\n    coordinateSystem: 'cartesian2d',\n    legendHoverLink: true,\n    // stack: null\n    // Cartesian coordinate system\n    // xAxisIndex: 0,\n    // yAxisIndex: 0,\n    // 最小高度改为0\n    barMinHeight: 0,\n    // 最小角度为0，仅对极坐标系下的柱状图有效\n    barMinAngle: 0,\n    // cursor: null,\n    // barMaxWidth: null,\n    // 默认自适应\n    // barWidth: null,\n    // 柱间距离，默认为柱形宽度的30%，可设固定值\n    // barGap: '30%',\n    // 类目间柱形距离，默认为类目间距的20%，可设固定值\n    // barCategoryGap: '20%',\n    // label: {\n    //     normal: {\n    //         show: false\n    //     }\n    // },\n    itemStyle: {// normal: {\n      // color: '各异'\n      // },\n      // emphasis: {}\n    }\n  }\n});\n\nmodule.exports = _default;\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/echarts/lib/chart/bar/BaseBarSeries.js\n// module id = 2m1D\n// module chunks = 1 2","var echarts = require(\"../echarts\");\n\nrequire(\"./marker/MarkPointModel\");\n\nrequire(\"./marker/MarkPointView\");\n\n// HINT Markpoint can't be used too much\necharts.registerPreprocessor(function (opt) {\n  // Make sure markPoint component is enabled\n  opt.markPoint = opt.markPoint || {};\n});\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/echarts/lib/component/markPoint.js\n// module id = 2tOJ\n// module chunks = 1 2","var _config = require(\"../../config\");\n\nvar __DEV__ = _config.__DEV__;\n\nvar echarts = require(\"../../echarts\");\n\nvar axisPointerModelHelper = require(\"../axisPointer/modelHelper\");\n\n/**\n * Base class of AxisView.\n */\nvar AxisView = echarts.extendComponentView({\n  type: 'axis',\n\n  /**\n   * @private\n   */\n  _axisPointer: null,\n\n  /**\n   * @protected\n   * @type {string}\n   */\n  axisPointerClass: null,\n\n  /**\n   * @override\n   */\n  render: function (axisModel, ecModel, api, payload) {\n    // FIXME\n    // This process should proformed after coordinate systems updated\n    // (axis scale updated), and should be performed each time update.\n    // So put it here temporarily, although it is not appropriate to\n    // put a model-writing procedure in `view`.\n    this.axisPointerClass && axisPointerModelHelper.fixValue(axisModel);\n    AxisView.superApply(this, 'render', arguments);\n    updateAxisPointer(this, axisModel, ecModel, api, payload, true);\n  },\n\n  /**\n   * Action handler.\n   * @public\n   * @param {module:echarts/coord/cartesian/AxisModel} axisModel\n   * @param {module:echarts/model/Global} ecModel\n   * @param {module:echarts/ExtensionAPI} api\n   * @param {Object} payload\n   */\n  updateAxisPointer: function (axisModel, ecModel, api, payload, force) {\n    updateAxisPointer(this, axisModel, ecModel, api, payload, false);\n  },\n\n  /**\n   * @override\n   */\n  remove: function (ecModel, api) {\n    var axisPointer = this._axisPointer;\n    axisPointer && axisPointer.remove(api);\n    AxisView.superApply(this, 'remove', arguments);\n  },\n\n  /**\n   * @override\n   */\n  dispose: function (ecModel, api) {\n    disposeAxisPointer(this, api);\n    AxisView.superApply(this, 'dispose', arguments);\n  }\n});\n\nfunction updateAxisPointer(axisView, axisModel, ecModel, api, payload, forceRender) {\n  var Clazz = AxisView.getAxisPointerClass(axisView.axisPointerClass);\n\n  if (!Clazz) {\n    return;\n  }\n\n  var axisPointerModel = axisPointerModelHelper.getAxisPointerModel(axisModel);\n  axisPointerModel ? (axisView._axisPointer || (axisView._axisPointer = new Clazz())).render(axisModel, axisPointerModel, api, forceRender) : disposeAxisPointer(axisView, api);\n}\n\nfunction disposeAxisPointer(axisView, ecModel, api) {\n  var axisPointer = axisView._axisPointer;\n  axisPointer && axisPointer.dispose(ecModel, api);\n  axisView._axisPointer = null;\n}\n\nvar axisPointerClazz = [];\n\nAxisView.registerAxisPointerClass = function (type, clazz) {\n  axisPointerClazz[type] = clazz;\n};\n\nAxisView.getAxisPointerClass = function (type) {\n  return type && axisPointerClazz[type];\n};\n\nvar _default = AxisView;\nmodule.exports = _default;\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/echarts/lib/component/axis/AxisView.js\n// module id = 43ae\n// module chunks = 1 2","var echarts = require(\"../echarts\");\n\nvar zrUtil = require(\"zrender/lib/core/util\");\n\nrequire(\"./line/LineSeries\");\n\nrequire(\"./line/LineView\");\n\nvar visualSymbol = require(\"../visual/symbol\");\n\nvar layoutPoints = require(\"../layout/points\");\n\nvar dataSample = require(\"../processor/dataSample\");\n\nrequire(\"../component/gridSimple\");\n\n// In case developer forget to include grid component\necharts.registerVisual(zrUtil.curry(visualSymbol, 'line', 'circle', 'line'));\necharts.registerLayout(zrUtil.curry(layoutPoints, 'line')); // Down sample after filter\n\necharts.registerProcessor(echarts.PRIORITY.PROCESSOR.STATISTIC, zrUtil.curry(dataSample, 'line'));\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/echarts/lib/chart/line.js\n// module id = 4UDB\n// module chunks = 1 2","var echarts = require(\"../../echarts\");\n\nvar globalListener = require(\"./globalListener\");\n\nvar AxisPointerView = echarts.extendComponentView({\n  type: 'axisPointer',\n  render: function (globalAxisPointerModel, ecModel, api) {\n    var globalTooltipModel = ecModel.getComponent('tooltip');\n    var triggerOn = globalAxisPointerModel.get('triggerOn') || globalTooltipModel && globalTooltipModel.get('triggerOn') || 'mousemove|click'; // Register global listener in AxisPointerView to enable\n    // AxisPointerView to be independent to Tooltip.\n\n    globalListener.register('axisPointer', api, function (currTrigger, e, dispatchAction) {\n      // If 'none', it is not controlled by mouse totally.\n      if (triggerOn !== 'none' && (currTrigger === 'leave' || triggerOn.indexOf(currTrigger) >= 0)) {\n        dispatchAction({\n          type: 'updateAxisPointer',\n          currTrigger: currTrigger,\n          x: e && e.offsetX,\n          y: e && e.offsetY\n        });\n      }\n    });\n  },\n\n  /**\n   * @override\n   */\n  remove: function (ecModel, api) {\n    globalListener.unregister(api.getZr(), 'axisPointer');\n    AxisPointerView.superApply(this._model, 'remove', arguments);\n  },\n\n  /**\n   * @override\n   */\n  dispose: function (ecModel, api) {\n    globalListener.unregister('axisPointer', api);\n    AxisPointerView.superApply(this._model, 'dispose', arguments);\n  }\n});\nvar _default = AxisPointerView;\nmodule.exports = _default;\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/echarts/lib/component/axisPointer/AxisPointerView.js\n// module id = 56C7\n// module chunks = 1 2","var zrUtil = require(\"zrender/lib/core/util\");\n\nvar Cartesian = require(\"./Cartesian\");\n\nfunction Cartesian2D(name) {\n  Cartesian.call(this, name);\n}\n\nCartesian2D.prototype = {\n  constructor: Cartesian2D,\n  type: 'cartesian2d',\n\n  /**\n   * @type {Array.<string>}\n   * @readOnly\n   */\n  dimensions: ['x', 'y'],\n\n  /**\n   * Base axis will be used on stacking.\n   *\n   * @return {module:echarts/coord/cartesian/Axis2D}\n   */\n  getBaseAxis: function () {\n    return this.getAxesByScale('ordinal')[0] || this.getAxesByScale('time')[0] || this.getAxis('x');\n  },\n\n  /**\n   * If contain point\n   * @param {Array.<number>} point\n   * @return {boolean}\n   */\n  containPoint: function (point) {\n    var axisX = this.getAxis('x');\n    var axisY = this.getAxis('y');\n    return axisX.contain(axisX.toLocalCoord(point[0])) && axisY.contain(axisY.toLocalCoord(point[1]));\n  },\n\n  /**\n   * If contain data\n   * @param {Array.<number>} data\n   * @return {boolean}\n   */\n  containData: function (data) {\n    return this.getAxis('x').containData(data[0]) && this.getAxis('y').containData(data[1]);\n  },\n\n  /**\n   * @param {Array.<number>} data\n   * @param {boolean} [clamp=false]\n   * @return {Array.<number>}\n   */\n  dataToPoint: function (data, clamp) {\n    var xAxis = this.getAxis('x');\n    var yAxis = this.getAxis('y');\n    return [xAxis.toGlobalCoord(xAxis.dataToCoord(data[0], clamp)), yAxis.toGlobalCoord(yAxis.dataToCoord(data[1], clamp))];\n  },\n\n  /**\n   * @param {Array.<number>} point\n   * @param {boolean} [clamp=false]\n   * @return {Array.<number>}\n   */\n  pointToData: function (point, clamp) {\n    var xAxis = this.getAxis('x');\n    var yAxis = this.getAxis('y');\n    return [xAxis.coordToData(xAxis.toLocalCoord(point[0]), clamp), yAxis.coordToData(yAxis.toLocalCoord(point[1]), clamp)];\n  },\n\n  /**\n   * Get other axis\n   * @param {module:echarts/coord/cartesian/Axis2D} axis\n   */\n  getOtherAxis: function (axis) {\n    return this.getAxis(axis.dim === 'x' ? 'y' : 'x');\n  }\n};\nzrUtil.inherits(Cartesian2D, Cartesian);\nvar _default = Cartesian2D;\nmodule.exports = _default;\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/echarts/lib/coord/cartesian/Cartesian2D.js\n// module id = 5dr1\n// module chunks = 1 2","var _config = require(\"../../config\");\n\nvar __DEV__ = _config.__DEV__;\n\nvar zrUtil = require(\"zrender/lib/core/util\");\n\nvar BoundingRect = require(\"zrender/lib/core/BoundingRect\");\n\nvar _layout = require(\"../../util/layout\");\n\nvar getLayoutRect = _layout.getLayoutRect;\n\nvar axisHelper = require(\"../../coord/axisHelper\");\n\nvar Cartesian2D = require(\"./Cartesian2D\");\n\nvar Axis2D = require(\"./Axis2D\");\n\nvar CoordinateSystem = require(\"../../CoordinateSystem\");\n\nrequire(\"./GridModel\");\n\n/**\n * Grid is a region which contains at most 4 cartesian systems\n *\n * TODO Default cartesian\n */\n// Depends on GridModel, AxisModel, which performs preprocess.\nvar each = zrUtil.each;\nvar ifAxisCrossZero = axisHelper.ifAxisCrossZero;\nvar niceScaleExtent = axisHelper.niceScaleExtent;\n/**\n * Check if the axis is used in the specified grid\n * @inner\n */\n\nfunction isAxisUsedInTheGrid(axisModel, gridModel, ecModel) {\n  return axisModel.getCoordSysModel() === gridModel;\n}\n\nfunction rotateTextRect(textRect, rotate) {\n  var rotateRadians = rotate * Math.PI / 180;\n  var boundingBox = textRect.plain();\n  var beforeWidth = boundingBox.width;\n  var beforeHeight = boundingBox.height;\n  var afterWidth = beforeWidth * Math.cos(rotateRadians) + beforeHeight * Math.sin(rotateRadians);\n  var afterHeight = beforeWidth * Math.sin(rotateRadians) + beforeHeight * Math.cos(rotateRadians);\n  var rotatedRect = new BoundingRect(boundingBox.x, boundingBox.y, afterWidth, afterHeight);\n  return rotatedRect;\n}\n\nfunction getLabelUnionRect(axis) {\n  var axisModel = axis.model;\n  var labels = axisModel.getFormattedLabels();\n  var axisLabelModel = axisModel.getModel('axisLabel');\n  var rect;\n  var step = 1;\n  var labelCount = labels.length;\n\n  if (labelCount > 40) {\n    // Simple optimization for large amount of labels\n    step = Math.ceil(labelCount / 40);\n  }\n\n  for (var i = 0; i < labelCount; i += step) {\n    if (!axis.isLabelIgnored(i)) {\n      var unrotatedSingleRect = axisLabelModel.getTextRect(labels[i]);\n      var singleRect = rotateTextRect(unrotatedSingleRect, axisLabelModel.get('rotate') || 0);\n      rect ? rect.union(singleRect) : rect = singleRect;\n    }\n  }\n\n  return rect;\n}\n\nfunction Grid(gridModel, ecModel, api) {\n  /**\n   * @type {Object.<string, module:echarts/coord/cartesian/Cartesian2D>}\n   * @private\n   */\n  this._coordsMap = {};\n  /**\n   * @type {Array.<module:echarts/coord/cartesian/Cartesian>}\n   * @private\n   */\n\n  this._coordsList = [];\n  /**\n   * @type {Object.<string, module:echarts/coord/cartesian/Axis2D>}\n   * @private\n   */\n\n  this._axesMap = {};\n  /**\n   * @type {Array.<module:echarts/coord/cartesian/Axis2D>}\n   * @private\n   */\n\n  this._axesList = [];\n\n  this._initCartesian(gridModel, ecModel, api);\n\n  this.model = gridModel;\n}\n\nvar gridProto = Grid.prototype;\ngridProto.type = 'grid';\ngridProto.axisPointerEnabled = true;\n\ngridProto.getRect = function () {\n  return this._rect;\n};\n\ngridProto.update = function (ecModel, api) {\n  var axesMap = this._axesMap;\n\n  this._updateScale(ecModel, this.model);\n\n  each(axesMap.x, function (xAxis) {\n    niceScaleExtent(xAxis.scale, xAxis.model);\n  });\n  each(axesMap.y, function (yAxis) {\n    niceScaleExtent(yAxis.scale, yAxis.model);\n  });\n  each(axesMap.x, function (xAxis) {\n    fixAxisOnZero(axesMap, 'y', xAxis);\n  });\n  each(axesMap.y, function (yAxis) {\n    fixAxisOnZero(axesMap, 'x', yAxis);\n  }); // Resize again if containLabel is enabled\n  // FIXME It may cause getting wrong grid size in data processing stage\n\n  this.resize(this.model, api);\n};\n\nfunction fixAxisOnZero(axesMap, otherAxisDim, axis) {\n  // onZero can not be enabled in these two situations:\n  // 1. When any other axis is a category axis.\n  // 2. When no axis is cross 0 point.\n  var axes = axesMap[otherAxisDim];\n\n  if (!axis.onZero) {\n    return;\n  }\n\n  var onZeroAxisIndex = axis.onZeroAxisIndex; // If target axis is specified.\n\n  if (onZeroAxisIndex != null) {\n    var otherAxis = axes[onZeroAxisIndex];\n\n    if (otherAxis && canNotOnZeroToAxis(otherAxis)) {\n      axis.onZero = false;\n    }\n\n    return;\n  }\n\n  for (var idx in axes) {\n    if (axes.hasOwnProperty(idx)) {\n      var otherAxis = axes[idx];\n\n      if (otherAxis && !canNotOnZeroToAxis(otherAxis)) {\n        onZeroAxisIndex = +idx;\n        break;\n      }\n    }\n  }\n\n  if (onZeroAxisIndex == null) {\n    axis.onZero = false;\n  }\n\n  axis.onZeroAxisIndex = onZeroAxisIndex;\n}\n\nfunction canNotOnZeroToAxis(axis) {\n  return axis.type === 'category' || axis.type === 'time' || !ifAxisCrossZero(axis);\n}\n/**\n * Resize the grid\n * @param {module:echarts/coord/cartesian/GridModel} gridModel\n * @param {module:echarts/ExtensionAPI} api\n */\n\n\ngridProto.resize = function (gridModel, api, ignoreContainLabel) {\n  var gridRect = getLayoutRect(gridModel.getBoxLayoutParams(), {\n    width: api.getWidth(),\n    height: api.getHeight()\n  });\n  this._rect = gridRect;\n  var axesList = this._axesList;\n  adjustAxes(); // Minus label size\n\n  if (!ignoreContainLabel && gridModel.get('containLabel')) {\n    each(axesList, function (axis) {\n      if (!axis.model.get('axisLabel.inside')) {\n        var labelUnionRect = getLabelUnionRect(axis);\n\n        if (labelUnionRect) {\n          var dim = axis.isHorizontal() ? 'height' : 'width';\n          var margin = axis.model.get('axisLabel.margin');\n          gridRect[dim] -= labelUnionRect[dim] + margin;\n\n          if (axis.position === 'top') {\n            gridRect.y += labelUnionRect.height + margin;\n          } else if (axis.position === 'left') {\n            gridRect.x += labelUnionRect.width + margin;\n          }\n        }\n      }\n    });\n    adjustAxes();\n  }\n\n  function adjustAxes() {\n    each(axesList, function (axis) {\n      var isHorizontal = axis.isHorizontal();\n      var extent = isHorizontal ? [0, gridRect.width] : [0, gridRect.height];\n      var idx = axis.inverse ? 1 : 0;\n      axis.setExtent(extent[idx], extent[1 - idx]);\n      updateAxisTransfrom(axis, isHorizontal ? gridRect.x : gridRect.y);\n    });\n  }\n};\n/**\n * @param {string} axisType\n * @param {number} [axisIndex]\n */\n\n\ngridProto.getAxis = function (axisType, axisIndex) {\n  var axesMapOnDim = this._axesMap[axisType];\n\n  if (axesMapOnDim != null) {\n    if (axisIndex == null) {\n      // Find first axis\n      for (var name in axesMapOnDim) {\n        if (axesMapOnDim.hasOwnProperty(name)) {\n          return axesMapOnDim[name];\n        }\n      }\n    }\n\n    return axesMapOnDim[axisIndex];\n  }\n};\n/**\n * @return {Array.<module:echarts/coord/Axis>}\n */\n\n\ngridProto.getAxes = function () {\n  return this._axesList.slice();\n};\n/**\n * Usage:\n *      grid.getCartesian(xAxisIndex, yAxisIndex);\n *      grid.getCartesian(xAxisIndex);\n *      grid.getCartesian(null, yAxisIndex);\n *      grid.getCartesian({xAxisIndex: ..., yAxisIndex: ...});\n *\n * @param {number|Object} [xAxisIndex]\n * @param {number} [yAxisIndex]\n */\n\n\ngridProto.getCartesian = function (xAxisIndex, yAxisIndex) {\n  if (xAxisIndex != null && yAxisIndex != null) {\n    var key = 'x' + xAxisIndex + 'y' + yAxisIndex;\n    return this._coordsMap[key];\n  }\n\n  if (zrUtil.isObject(xAxisIndex)) {\n    yAxisIndex = xAxisIndex.yAxisIndex;\n    xAxisIndex = xAxisIndex.xAxisIndex;\n  } // When only xAxisIndex or yAxisIndex given, find its first cartesian.\n\n\n  for (var i = 0, coordList = this._coordsList; i < coordList.length; i++) {\n    if (coordList[i].getAxis('x').index === xAxisIndex || coordList[i].getAxis('y').index === yAxisIndex) {\n      return coordList[i];\n    }\n  }\n};\n\ngridProto.getCartesians = function () {\n  return this._coordsList.slice();\n};\n/**\n * @implements\n * see {module:echarts/CoodinateSystem}\n */\n\n\ngridProto.convertToPixel = function (ecModel, finder, value) {\n  var target = this._findConvertTarget(ecModel, finder);\n\n  return target.cartesian ? target.cartesian.dataToPoint(value) : target.axis ? target.axis.toGlobalCoord(target.axis.dataToCoord(value)) : null;\n};\n/**\n * @implements\n * see {module:echarts/CoodinateSystem}\n */\n\n\ngridProto.convertFromPixel = function (ecModel, finder, value) {\n  var target = this._findConvertTarget(ecModel, finder);\n\n  return target.cartesian ? target.cartesian.pointToData(value) : target.axis ? target.axis.coordToData(target.axis.toLocalCoord(value)) : null;\n};\n/**\n * @inner\n */\n\n\ngridProto._findConvertTarget = function (ecModel, finder) {\n  var seriesModel = finder.seriesModel;\n  var xAxisModel = finder.xAxisModel || seriesModel && seriesModel.getReferringComponents('xAxis')[0];\n  var yAxisModel = finder.yAxisModel || seriesModel && seriesModel.getReferringComponents('yAxis')[0];\n  var gridModel = finder.gridModel;\n  var coordsList = this._coordsList;\n  var cartesian;\n  var axis;\n\n  if (seriesModel) {\n    cartesian = seriesModel.coordinateSystem;\n    zrUtil.indexOf(coordsList, cartesian) < 0 && (cartesian = null);\n  } else if (xAxisModel && yAxisModel) {\n    cartesian = this.getCartesian(xAxisModel.componentIndex, yAxisModel.componentIndex);\n  } else if (xAxisModel) {\n    axis = this.getAxis('x', xAxisModel.componentIndex);\n  } else if (yAxisModel) {\n    axis = this.getAxis('y', yAxisModel.componentIndex);\n  } // Lowest priority.\n  else if (gridModel) {\n      var grid = gridModel.coordinateSystem;\n\n      if (grid === this) {\n        cartesian = this._coordsList[0];\n      }\n    }\n\n  return {\n    cartesian: cartesian,\n    axis: axis\n  };\n};\n/**\n * @implements\n * see {module:echarts/CoodinateSystem}\n */\n\n\ngridProto.containPoint = function (point) {\n  var coord = this._coordsList[0];\n\n  if (coord) {\n    return coord.containPoint(point);\n  }\n};\n/**\n * Initialize cartesian coordinate systems\n * @private\n */\n\n\ngridProto._initCartesian = function (gridModel, ecModel, api) {\n  var axisPositionUsed = {\n    left: false,\n    right: false,\n    top: false,\n    bottom: false\n  };\n  var axesMap = {\n    x: {},\n    y: {}\n  };\n  var axesCount = {\n    x: 0,\n    y: 0\n  }; /// Create axis\n\n  ecModel.eachComponent('xAxis', createAxisCreator('x'), this);\n  ecModel.eachComponent('yAxis', createAxisCreator('y'), this);\n\n  if (!axesCount.x || !axesCount.y) {\n    // Roll back when there no either x or y axis\n    this._axesMap = {};\n    this._axesList = [];\n    return;\n  }\n\n  this._axesMap = axesMap; /// Create cartesian2d\n\n  each(axesMap.x, function (xAxis, xAxisIndex) {\n    each(axesMap.y, function (yAxis, yAxisIndex) {\n      var key = 'x' + xAxisIndex + 'y' + yAxisIndex;\n      var cartesian = new Cartesian2D(key);\n      cartesian.grid = this;\n      cartesian.model = gridModel;\n      this._coordsMap[key] = cartesian;\n\n      this._coordsList.push(cartesian);\n\n      cartesian.addAxis(xAxis);\n      cartesian.addAxis(yAxis);\n    }, this);\n  }, this);\n\n  function createAxisCreator(axisType) {\n    return function (axisModel, idx) {\n      if (!isAxisUsedInTheGrid(axisModel, gridModel, ecModel)) {\n        return;\n      }\n\n      var axisPosition = axisModel.get('position');\n\n      if (axisType === 'x') {\n        // Fix position\n        if (axisPosition !== 'top' && axisPosition !== 'bottom') {\n          // Default bottom of X\n          axisPosition = 'bottom';\n\n          if (axisPositionUsed[axisPosition]) {\n            axisPosition = axisPosition === 'top' ? 'bottom' : 'top';\n          }\n        }\n      } else {\n        // Fix position\n        if (axisPosition !== 'left' && axisPosition !== 'right') {\n          // Default left of Y\n          axisPosition = 'left';\n\n          if (axisPositionUsed[axisPosition]) {\n            axisPosition = axisPosition === 'left' ? 'right' : 'left';\n          }\n        }\n      }\n\n      axisPositionUsed[axisPosition] = true;\n      var axis = new Axis2D(axisType, axisHelper.createScaleByModel(axisModel), [0, 0], axisModel.get('type'), axisPosition);\n      var isCategory = axis.type === 'category';\n      axis.onBand = isCategory && axisModel.get('boundaryGap');\n      axis.inverse = axisModel.get('inverse');\n      axis.onZero = axisModel.get('axisLine.onZero');\n      axis.onZeroAxisIndex = axisModel.get('axisLine.onZeroAxisIndex'); // Inject axis into axisModel\n\n      axisModel.axis = axis; // Inject axisModel into axis\n\n      axis.model = axisModel; // Inject grid info axis\n\n      axis.grid = this; // Index of axis, can be used as key\n\n      axis.index = idx;\n\n      this._axesList.push(axis);\n\n      axesMap[axisType][idx] = axis;\n      axesCount[axisType]++;\n    };\n  }\n};\n/**\n * Update cartesian properties from series\n * @param  {module:echarts/model/Option} option\n * @private\n */\n\n\ngridProto._updateScale = function (ecModel, gridModel) {\n  // Reset scale\n  zrUtil.each(this._axesList, function (axis) {\n    axis.scale.setExtent(Infinity, -Infinity);\n  });\n  ecModel.eachSeries(function (seriesModel) {\n    if (isCartesian2D(seriesModel)) {\n      var axesModels = findAxesModels(seriesModel, ecModel);\n      var xAxisModel = axesModels[0];\n      var yAxisModel = axesModels[1];\n\n      if (!isAxisUsedInTheGrid(xAxisModel, gridModel, ecModel) || !isAxisUsedInTheGrid(yAxisModel, gridModel, ecModel)) {\n        return;\n      }\n\n      var cartesian = this.getCartesian(xAxisModel.componentIndex, yAxisModel.componentIndex);\n      var data = seriesModel.getData();\n      var xAxis = cartesian.getAxis('x');\n      var yAxis = cartesian.getAxis('y');\n\n      if (data.type === 'list') {\n        unionExtent(data, xAxis, seriesModel);\n        unionExtent(data, yAxis, seriesModel);\n      }\n    }\n  }, this);\n\n  function unionExtent(data, axis, seriesModel) {\n    each(seriesModel.coordDimToDataDim(axis.dim), function (dim) {\n      axis.scale.unionExtentFromData(data, dim);\n    });\n  }\n};\n/**\n * @param {string} [dim] 'x' or 'y' or 'auto' or null/undefined\n * @return {Object} {baseAxes: [], otherAxes: []}\n */\n\n\ngridProto.getTooltipAxes = function (dim) {\n  var baseAxes = [];\n  var otherAxes = [];\n  each(this.getCartesians(), function (cartesian) {\n    var baseAxis = dim != null && dim !== 'auto' ? cartesian.getAxis(dim) : cartesian.getBaseAxis();\n    var otherAxis = cartesian.getOtherAxis(baseAxis);\n    zrUtil.indexOf(baseAxes, baseAxis) < 0 && baseAxes.push(baseAxis);\n    zrUtil.indexOf(otherAxes, otherAxis) < 0 && otherAxes.push(otherAxis);\n  });\n  return {\n    baseAxes: baseAxes,\n    otherAxes: otherAxes\n  };\n};\n/**\n * @inner\n */\n\n\nfunction updateAxisTransfrom(axis, coordBase) {\n  var axisExtent = axis.getExtent();\n  var axisExtentSum = axisExtent[0] + axisExtent[1]; // Fast transform\n\n  axis.toGlobalCoord = axis.dim === 'x' ? function (coord) {\n    return coord + coordBase;\n  } : function (coord) {\n    return axisExtentSum - coord + coordBase;\n  };\n  axis.toLocalCoord = axis.dim === 'x' ? function (coord) {\n    return coord - coordBase;\n  } : function (coord) {\n    return axisExtentSum - coord + coordBase;\n  };\n}\n\nvar axesTypes = ['xAxis', 'yAxis'];\n/**\n * @inner\n */\n\nfunction findAxesModels(seriesModel, ecModel) {\n  return zrUtil.map(axesTypes, function (axisType) {\n    var axisModel = seriesModel.getReferringComponents(axisType)[0];\n    return axisModel;\n  });\n}\n/**\n * @inner\n */\n\n\nfunction isCartesian2D(seriesModel) {\n  return seriesModel.get('coordinateSystem') === 'cartesian2d';\n}\n\nGrid.create = function (ecModel, api) {\n  var grids = [];\n  ecModel.eachComponent('grid', function (gridModel, idx) {\n    var grid = new Grid(gridModel, ecModel, api);\n    grid.name = 'grid_' + idx; // dataSampling requires axis extent, so resize\n    // should be performed in create stage.\n\n    grid.resize(gridModel, api, true);\n    gridModel.coordinateSystem = grid;\n    grids.push(grid);\n  }); // Inject the coordinateSystems into seriesModel\n\n  ecModel.eachSeries(function (seriesModel) {\n    if (!isCartesian2D(seriesModel)) {\n      return;\n    }\n\n    var axesModels = findAxesModels(seriesModel, ecModel);\n    var xAxisModel = axesModels[0];\n    var yAxisModel = axesModels[1];\n    var gridModel = xAxisModel.getCoordSysModel();\n    var grid = gridModel.coordinateSystem;\n    seriesModel.coordinateSystem = grid.getCartesian(xAxisModel.componentIndex, yAxisModel.componentIndex);\n  });\n  return grids;\n}; // For deciding which dimensions to use when creating list data\n\n\nGrid.dimensions = Grid.prototype.dimensions = Cartesian2D.prototype.dimensions;\nCoordinateSystem.register('cartesian2d', Grid);\nvar _default = Grid;\nmodule.exports = _default;\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/echarts/lib/coord/cartesian/Grid.js\n// module id = 5vFd\n// module chunks = 1 2","require('../../modules/es6.string.iterator');\nrequire('../../modules/es6.array.from');\nmodule.exports = require('../../modules/_core').Array.from;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/core-js/library/fn/array/from.js\n// module id = 5zde\n// module chunks = 2","module.exports = __webpack_public_path__ + \"static/img/AI.91e14ac.png\";\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/assets/AI.png\n// module id = 6/bW\n// module chunks = 2","var echarts = require(\"../../echarts\");\n\nvar _default = echarts.extendComponentModel({\n  type: 'tooltip',\n  dependencies: ['axisPointer'],\n  defaultOption: {\n    zlevel: 0,\n    z: 8,\n    show: true,\n    // tooltip主体内容\n    showContent: true,\n    // 'trigger' only works on coordinate system.\n    // 'item' | 'axis' | 'none'\n    trigger: 'item',\n    // 'click' | 'mousemove' | 'none'\n    triggerOn: 'mousemove|click',\n    alwaysShowContent: false,\n    displayMode: 'single',\n    // 'single' | 'multipleByCoordSys'\n    // 位置 {Array} | {Function}\n    // position: null\n    // Consider triggered from axisPointer handle, verticalAlign should be 'middle'\n    // align: null,\n    // verticalAlign: null,\n    // 是否约束 content 在 viewRect 中。默认 false 是为了兼容以前版本。\n    confine: false,\n    // 内容格式器：{string}（Template） ¦ {Function}\n    // formatter: null\n    showDelay: 0,\n    // 隐藏延迟，单位ms\n    hideDelay: 100,\n    // 动画变换时间，单位s\n    transitionDuration: 0.4,\n    enterable: false,\n    // 提示背景颜色，默认为透明度为0.7的黑色\n    backgroundColor: 'rgba(50,50,50,0.7)',\n    // 提示边框颜色\n    borderColor: '#333',\n    // 提示边框圆角，单位px，默认为4\n    borderRadius: 4,\n    // 提示边框线宽，单位px，默认为0（无边框）\n    borderWidth: 0,\n    // 提示内边距，单位px，默认各方向内边距为5，\n    // 接受数组分别设定上右下左边距，同css\n    padding: 5,\n    // Extra css text\n    extraCssText: '',\n    // 坐标轴指示器，坐标轴触发有效\n    axisPointer: {\n      // 默认为直线\n      // 可选为：'line' | 'shadow' | 'cross'\n      type: 'line',\n      // type 为 line 的时候有效，指定 tooltip line 所在的轴，可选\n      // 可选 'x' | 'y' | 'angle' | 'radius' | 'auto'\n      // 默认 'auto'，会选择类型为 cateogry 的轴，对于双数值轴，笛卡尔坐标系会默认选择 x 轴\n      // 极坐标系会默认选择 angle 轴\n      axis: 'auto',\n      animation: 'auto',\n      animationDurationUpdate: 200,\n      animationEasingUpdate: 'exponentialOut',\n      crossStyle: {\n        color: '#999',\n        width: 1,\n        type: 'dashed',\n        // TODO formatter\n        textStyle: {} // lineStyle and shadowStyle should not be specified here,\n        // otherwise it will always override those styles on option.axisPointer.\n\n      }\n    },\n    textStyle: {\n      color: '#fff',\n      fontSize: 14\n    }\n  }\n});\n\nmodule.exports = _default;\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/echarts/lib/component/tooltip/TooltipModel.js\n// module id = 7XrG\n// module chunks = 1 2","var zrUtil = require(\"zrender/lib/core/util\");\n\nvar each = zrUtil.each;\nvar ATTR = '\\0_ec_hist_store';\n/**\n * @param {module:echarts/model/Global} ecModel\n * @param {Object} newSnapshot {dataZoomId, batch: [payloadInfo, ...]}\n */\n\nfunction push(ecModel, newSnapshot) {\n  var store = giveStore(ecModel); // If previous dataZoom can not be found,\n  // complete an range with current range.\n\n  each(newSnapshot, function (batchItem, dataZoomId) {\n    var i = store.length - 1;\n\n    for (; i >= 0; i--) {\n      var snapshot = store[i];\n\n      if (snapshot[dataZoomId]) {\n        break;\n      }\n    }\n\n    if (i < 0) {\n      // No origin range set, create one by current range.\n      var dataZoomModel = ecModel.queryComponents({\n        mainType: 'dataZoom',\n        subType: 'select',\n        id: dataZoomId\n      })[0];\n\n      if (dataZoomModel) {\n        var percentRange = dataZoomModel.getPercentRange();\n        store[0][dataZoomId] = {\n          dataZoomId: dataZoomId,\n          start: percentRange[0],\n          end: percentRange[1]\n        };\n      }\n    }\n  });\n  store.push(newSnapshot);\n}\n/**\n * @param {module:echarts/model/Global} ecModel\n * @return {Object} snapshot\n */\n\n\nfunction pop(ecModel) {\n  var store = giveStore(ecModel);\n  var head = store[store.length - 1];\n  store.length > 1 && store.pop(); // Find top for all dataZoom.\n\n  var snapshot = {};\n  each(head, function (batchItem, dataZoomId) {\n    for (var i = store.length - 1; i >= 0; i--) {\n      var batchItem = store[i][dataZoomId];\n\n      if (batchItem) {\n        snapshot[dataZoomId] = batchItem;\n        break;\n      }\n    }\n  });\n  return snapshot;\n}\n/**\n * @param {module:echarts/model/Global} ecModel\n */\n\n\nfunction clear(ecModel) {\n  ecModel[ATTR] = null;\n}\n/**\n * @param {module:echarts/model/Global} ecModel\n * @return {number} records. always >= 1.\n */\n\n\nfunction count(ecModel) {\n  return giveStore(ecModel).length;\n}\n/**\n * [{key: dataZoomId, value: {dataZoomId, range}}, ...]\n * History length of each dataZoom may be different.\n * this._history[0] is used to store origin range.\n * @type {Array.<Object>}\n */\n\n\nfunction giveStore(ecModel) {\n  var store = ecModel[ATTR];\n\n  if (!store) {\n    store = ecModel[ATTR] = [{}];\n  }\n\n  return store;\n}\n\nexports.push = push;\nexports.pop = pop;\nexports.clear = clear;\nexports.count = count;\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/echarts/lib/component/dataZoom/history.js\n// module id = 9Owa\n// module chunks = 1 2","var echarts = require(\"../echarts\");\n\nvar zrUtil = require(\"zrender/lib/core/util\");\n\nvar axisPointerModelHelper = require(\"./axisPointer/modelHelper\");\n\nvar axisTrigger = require(\"./axisPointer/axisTrigger\");\n\nrequire(\"./axisPointer/AxisPointerModel\");\n\nrequire(\"./axisPointer/AxisPointerView\");\n\nrequire(\"./axisPointer/CartesianAxisPointer\");\n\n// CartesianAxisPointer is not supposed to be required here. But consider\n// echarts.simple.js and online build tooltip, which only require gridSimple,\n// CartesianAxisPointer should be able to required somewhere.\necharts.registerPreprocessor(function (option) {\n  // Always has a global axisPointerModel for default setting.\n  if (option) {\n    (!option.axisPointer || option.axisPointer.length === 0) && (option.axisPointer = {});\n    var link = option.axisPointer.link; // Normalize to array to avoid object mergin. But if link\n    // is not set, remain null/undefined, otherwise it will\n    // override existent link setting.\n\n    if (link && !zrUtil.isArray(link)) {\n      option.axisPointer.link = [link];\n    }\n  }\n}); // This process should proformed after coordinate systems created\n// and series data processed. So put it on statistic processing stage.\n\necharts.registerProcessor(echarts.PRIORITY.PROCESSOR.STATISTIC, function (ecModel, api) {\n  // Build axisPointerModel, mergin tooltip.axisPointer model for each axis.\n  // allAxesInfo should be updated when setOption performed.\n  ecModel.getComponent('axisPointer').coordSysAxesInfo = axisPointerModelHelper.collect(ecModel, api);\n}); // Broadcast to all views.\n\necharts.registerAction({\n  type: 'updateAxisPointer',\n  event: 'updateAxisPointer',\n  update: ':updateAxisPointer'\n}, axisTrigger);\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/echarts/lib/component/axisPointer.js\n// module id = AKXb\n// module chunks = 1 2","var env = require(\"zrender/lib/core/env\");\n\nvar lang = require(\"../../../lang\");\n\nvar featureManager = require(\"../featureManager\");\n\nvar saveAsImageLang = lang.toolbox.saveAsImage;\n\nfunction SaveAsImage(model) {\n  this.model = model;\n}\n\nSaveAsImage.defaultOption = {\n  show: true,\n  icon: 'M4.7,22.9L29.3,45.5L54.7,23.4M4.6,43.6L4.6,58L53.8,58L53.8,43.6M29.2,45.1L29.2,0',\n  title: saveAsImageLang.title,\n  type: 'png',\n  // Default use option.backgroundColor\n  // backgroundColor: '#fff',\n  name: '',\n  excludeComponents: ['toolbox'],\n  pixelRatio: 1,\n  lang: saveAsImageLang.lang.slice()\n};\nSaveAsImage.prototype.unusable = !env.canvasSupported;\nvar proto = SaveAsImage.prototype;\n\nproto.onclick = function (ecModel, api) {\n  var model = this.model;\n  var title = model.get('name') || ecModel.get('title.0.text') || 'echarts';\n  var $a = document.createElement('a');\n  var type = model.get('type', true) || 'png';\n  $a.download = title + '.' + type;\n  $a.target = '_blank';\n  var url = api.getConnectedDataURL({\n    type: type,\n    backgroundColor: model.get('backgroundColor', true) || ecModel.get('backgroundColor') || '#fff',\n    excludeComponents: model.get('excludeComponents'),\n    pixelRatio: model.get('pixelRatio')\n  });\n  $a.href = url; // Chrome and Firefox\n\n  if (typeof MouseEvent === 'function' && !env.browser.ie && !env.browser.edge) {\n    var evt = new MouseEvent('click', {\n      view: window,\n      bubbles: true,\n      cancelable: false\n    });\n    $a.dispatchEvent(evt);\n  } // IE\n  else {\n      if (window.navigator.msSaveOrOpenBlob) {\n        var bstr = atob(url.split(',')[1]);\n        var n = bstr.length;\n        var u8arr = new Uint8Array(n);\n\n        while (n--) {\n          u8arr[n] = bstr.charCodeAt(n);\n        }\n\n        var blob = new Blob([u8arr]);\n        window.navigator.msSaveOrOpenBlob(blob, title + '.' + type);\n      } else {\n        var lang = model.get('lang');\n        var html = '' + '<body style=\"margin:0;\">' + '<img src=\"' + url + '\" style=\"max-width:100%;\" title=\"' + (lang && lang[0] || '') + '\" />' + '</body>';\n        var tab = window.open();\n        tab.document.write(html);\n      }\n    }\n};\n\nfeatureManager.register('saveAsImage', SaveAsImage);\nvar _default = SaveAsImage;\nmodule.exports = _default;\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/echarts/lib/component/toolbox/feature/SaveAsImage.js\n// module id = AbHi\n// module chunks = 1 2","function _default(seriesType, defaultSymbolType, legendSymbol, ecModel, api) {\n  // Encoding visual for all series include which is filtered for legend drawing\n  ecModel.eachRawSeriesByType(seriesType, function (seriesModel) {\n    var data = seriesModel.getData();\n    var symbolType = seriesModel.get('symbol') || defaultSymbolType;\n    var symbolSize = seriesModel.get('symbolSize');\n    data.setVisual({\n      legendSymbol: legendSymbol || symbolType,\n      symbol: symbolType,\n      symbolSize: symbolSize\n    }); // Only visible series has each data be visual encoded\n\n    if (!ecModel.isSeriesFiltered(seriesModel)) {\n      if (typeof symbolSize === 'function') {\n        data.each(function (idx) {\n          var rawValue = seriesModel.getRawValue(idx); // FIXME\n\n          var params = seriesModel.getDataParams(idx);\n          data.setItemVisual(idx, 'symbolSize', symbolSize(rawValue, params));\n        });\n      }\n\n      data.each(function (idx) {\n        var itemModel = data.getItemModel(idx);\n        var itemSymbolType = itemModel.getShallow('symbol', true);\n        var itemSymbolSize = itemModel.getShallow('symbolSize', true); // If has item symbol\n\n        if (itemSymbolType != null) {\n          data.setItemVisual(idx, 'symbol', itemSymbolType);\n        }\n\n        if (itemSymbolSize != null) {\n          // PENDING Transform symbolSize ?\n          data.setItemVisual(idx, 'symbolSize', itemSymbolSize);\n        }\n      });\n    }\n  });\n}\n\nmodule.exports = _default;\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/echarts/lib/visual/symbol.js\n// module id = AjK0\n// module chunks = 1 2","require(\"./AxisModel\");\n\nvar ComponentModel = require(\"../../model/Component\");\n\n// Grid 是在有直角坐标系的时候必须要存在的\n// 所以这里也要被 Cartesian2D 依赖\nvar _default = ComponentModel.extend({\n  type: 'grid',\n  dependencies: ['xAxis', 'yAxis'],\n  layoutMode: 'box',\n\n  /**\n   * @type {module:echarts/coord/cartesian/Grid}\n   */\n  coordinateSystem: null,\n  defaultOption: {\n    show: false,\n    zlevel: 0,\n    z: 0,\n    left: '10%',\n    top: 60,\n    right: '10%',\n    bottom: 60,\n    // If grid size contain label\n    containLabel: false,\n    // width: {totalWidth} - left - right,\n    // height: {totalHeight} - top - bottom,\n    backgroundColor: 'rgba(0,0,0,0)',\n    borderWidth: 1,\n    borderColor: '#ccc'\n  }\n});\n\nmodule.exports = _default;\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/echarts/lib/coord/cartesian/GridModel.js\n// module id = BuI2\n// module chunks = 1 2","var graphic = require(\"../../util/graphic\");\n\nvar BaseAxisPointer = require(\"./BaseAxisPointer\");\n\nvar viewHelper = require(\"./viewHelper\");\n\nvar cartesianAxisHelper = require(\"../axis/cartesianAxisHelper\");\n\nvar AxisView = require(\"../axis/AxisView\");\n\nvar CartesianAxisPointer = BaseAxisPointer.extend({\n  /**\n   * @override\n   */\n  makeElOption: function (elOption, value, axisModel, axisPointerModel, api) {\n    var axis = axisModel.axis;\n    var grid = axis.grid;\n    var axisPointerType = axisPointerModel.get('type');\n    var otherExtent = getCartesian(grid, axis).getOtherAxis(axis).getGlobalExtent();\n    var pixelValue = axis.toGlobalCoord(axis.dataToCoord(value, true));\n\n    if (axisPointerType && axisPointerType !== 'none') {\n      var elStyle = viewHelper.buildElStyle(axisPointerModel);\n      var pointerOption = pointerShapeBuilder[axisPointerType](axis, pixelValue, otherExtent, elStyle);\n      pointerOption.style = elStyle;\n      elOption.graphicKey = pointerOption.type;\n      elOption.pointer = pointerOption;\n    }\n\n    var layoutInfo = cartesianAxisHelper.layout(grid.model, axisModel);\n    viewHelper.buildCartesianSingleLabelElOption(value, elOption, layoutInfo, axisModel, axisPointerModel, api);\n  },\n\n  /**\n   * @override\n   */\n  getHandleTransform: function (value, axisModel, axisPointerModel) {\n    var layoutInfo = cartesianAxisHelper.layout(axisModel.axis.grid.model, axisModel, {\n      labelInside: false\n    });\n    layoutInfo.labelMargin = axisPointerModel.get('handle.margin');\n    return {\n      position: viewHelper.getTransformedPosition(axisModel.axis, value, layoutInfo),\n      rotation: layoutInfo.rotation + (layoutInfo.labelDirection < 0 ? Math.PI : 0)\n    };\n  },\n\n  /**\n   * @override\n   */\n  updateHandleTransform: function (transform, delta, axisModel, axisPointerModel) {\n    var axis = axisModel.axis;\n    var grid = axis.grid;\n    var axisExtent = axis.getGlobalExtent(true);\n    var otherExtent = getCartesian(grid, axis).getOtherAxis(axis).getGlobalExtent();\n    var dimIndex = axis.dim === 'x' ? 0 : 1;\n    var currPosition = transform.position;\n    currPosition[dimIndex] += delta[dimIndex];\n    currPosition[dimIndex] = Math.min(axisExtent[1], currPosition[dimIndex]);\n    currPosition[dimIndex] = Math.max(axisExtent[0], currPosition[dimIndex]);\n    var cursorOtherValue = (otherExtent[1] + otherExtent[0]) / 2;\n    var cursorPoint = [cursorOtherValue, cursorOtherValue];\n    cursorPoint[dimIndex] = currPosition[dimIndex]; // Make tooltip do not overlap axisPointer and in the middle of the grid.\n\n    var tooltipOptions = [{\n      verticalAlign: 'middle'\n    }, {\n      align: 'center'\n    }];\n    return {\n      position: currPosition,\n      rotation: transform.rotation,\n      cursorPoint: cursorPoint,\n      tooltipOption: tooltipOptions[dimIndex]\n    };\n  }\n});\n\nfunction getCartesian(grid, axis) {\n  var opt = {};\n  opt[axis.dim + 'AxisIndex'] = axis.index;\n  return grid.getCartesian(opt);\n}\n\nvar pointerShapeBuilder = {\n  line: function (axis, pixelValue, otherExtent, elStyle) {\n    var targetShape = viewHelper.makeLineShape([pixelValue, otherExtent[0]], [pixelValue, otherExtent[1]], getAxisDimIndex(axis));\n    graphic.subPixelOptimizeLine({\n      shape: targetShape,\n      style: elStyle\n    });\n    return {\n      type: 'Line',\n      shape: targetShape\n    };\n  },\n  shadow: function (axis, pixelValue, otherExtent, elStyle) {\n    var bandWidth = axis.getBandWidth();\n    var span = otherExtent[1] - otherExtent[0];\n    return {\n      type: 'Rect',\n      shape: viewHelper.makeRectShape([pixelValue - bandWidth / 2, otherExtent[0]], [bandWidth, span], getAxisDimIndex(axis))\n    };\n  }\n};\n\nfunction getAxisDimIndex(axis) {\n  return axis.dim === 'x' ? 0 : 1;\n}\n\nAxisView.registerAxisPointerClass('CartesianAxisPointer', CartesianAxisPointer);\nvar _default = CartesianAxisPointer;\nmodule.exports = _default;\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/echarts/lib/component/axisPointer/CartesianAxisPointer.js\n// module id = D7EH\n// module chunks = 1 2","var BaseBarSeries = require(\"./BaseBarSeries\");\n\nvar _default = BaseBarSeries.extend({\n  type: 'series.bar',\n  dependencies: ['grid', 'polar'],\n  brushSelector: 'rect'\n});\n\nmodule.exports = _default;\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/echarts/lib/chart/bar/BarSeries.js\n// module id = DPh+\n// module chunks = 1 2","var echarts = require(\"../../../echarts\");\n\nvar zrUtil = require(\"zrender/lib/core/util\");\n\nvar BrushController = require(\"../../helper/BrushController\");\n\nvar BrushTargetManager = require(\"../../helper/BrushTargetManager\");\n\nvar history = require(\"../../dataZoom/history\");\n\nvar sliderMove = require(\"../../helper/sliderMove\");\n\nvar lang = require(\"../../../lang\");\n\nvar featureManager = require(\"../featureManager\");\n\nrequire(\"../../dataZoomSelect\");\n\n// Use dataZoomSelect\nvar dataZoomLang = lang.toolbox.dataZoom;\nvar each = zrUtil.each; // Spectial component id start with \\0ec\\0, see echarts/model/Global.js~hasInnerId\n\nvar DATA_ZOOM_ID_BASE = '\\0_ec_\\0toolbox-dataZoom_';\n\nfunction DataZoom(model, ecModel, api) {\n  /**\n   * @private\n   * @type {module:echarts/component/helper/BrushController}\n   */\n  (this._brushController = new BrushController(api.getZr())).on('brush', zrUtil.bind(this._onBrush, this)).mount();\n  /**\n   * @private\n   * @type {boolean}\n   */\n\n  this._isZoomActive;\n}\n\nDataZoom.defaultOption = {\n  show: true,\n  // Icon group\n  icon: {\n    zoom: 'M0,13.5h26.9 M13.5,26.9V0 M32.1,13.5H58V58H13.5 V32.1',\n    back: 'M22,1.4L9.9,13.5l12.3,12.3 M10.3,13.5H54.9v44.6 H10.3v-26'\n  },\n  // `zoom`, `back`\n  title: zrUtil.clone(dataZoomLang.title)\n};\nvar proto = DataZoom.prototype;\n\nproto.render = function (featureModel, ecModel, api, payload) {\n  this.model = featureModel;\n  this.ecModel = ecModel;\n  this.api = api;\n  updateZoomBtnStatus(featureModel, ecModel, this, payload, api);\n  updateBackBtnStatus(featureModel, ecModel);\n};\n\nproto.onclick = function (ecModel, api, type) {\n  handlers[type].call(this);\n};\n\nproto.remove = function (ecModel, api) {\n  this._brushController.unmount();\n};\n\nproto.dispose = function (ecModel, api) {\n  this._brushController.dispose();\n};\n/**\n * @private\n */\n\n\nvar handlers = {\n  zoom: function () {\n    var nextActive = !this._isZoomActive;\n    this.api.dispatchAction({\n      type: 'takeGlobalCursor',\n      key: 'dataZoomSelect',\n      dataZoomSelectActive: nextActive\n    });\n  },\n  back: function () {\n    this._dispatchZoomAction(history.pop(this.ecModel));\n  }\n};\n/**\n * @private\n */\n\nproto._onBrush = function (areas, opt) {\n  if (!opt.isEnd || !areas.length) {\n    return;\n  }\n\n  var snapshot = {};\n  var ecModel = this.ecModel;\n\n  this._brushController.updateCovers([]); // remove cover\n\n\n  var brushTargetManager = new BrushTargetManager(retrieveAxisSetting(this.model.option), ecModel, {\n    include: ['grid']\n  });\n  brushTargetManager.matchOutputRanges(areas, ecModel, function (area, coordRange, coordSys) {\n    if (coordSys.type !== 'cartesian2d') {\n      return;\n    }\n\n    var brushType = area.brushType;\n\n    if (brushType === 'rect') {\n      setBatch('x', coordSys, coordRange[0]);\n      setBatch('y', coordSys, coordRange[1]);\n    } else {\n      setBatch({\n        lineX: 'x',\n        lineY: 'y'\n      }[brushType], coordSys, coordRange);\n    }\n  });\n  history.push(ecModel, snapshot);\n\n  this._dispatchZoomAction(snapshot);\n\n  function setBatch(dimName, coordSys, minMax) {\n    var axis = coordSys.getAxis(dimName);\n    var axisModel = axis.model;\n    var dataZoomModel = findDataZoom(dimName, axisModel, ecModel); // Restrict range.\n\n    var minMaxSpan = dataZoomModel.findRepresentativeAxisProxy(axisModel).getMinMaxSpan();\n\n    if (minMaxSpan.minValueSpan != null || minMaxSpan.maxValueSpan != null) {\n      minMax = sliderMove(0, minMax.slice(), axis.scale.getExtent(), 0, minMaxSpan.minValueSpan, minMaxSpan.maxValueSpan);\n    }\n\n    dataZoomModel && (snapshot[dataZoomModel.id] = {\n      dataZoomId: dataZoomModel.id,\n      startValue: minMax[0],\n      endValue: minMax[1]\n    });\n  }\n\n  function findDataZoom(dimName, axisModel, ecModel) {\n    var found;\n    ecModel.eachComponent({\n      mainType: 'dataZoom',\n      subType: 'select'\n    }, function (dzModel) {\n      var has = dzModel.getAxisModel(dimName, axisModel.componentIndex);\n      has && (found = dzModel);\n    });\n    return found;\n  }\n};\n/**\n * @private\n */\n\n\nproto._dispatchZoomAction = function (snapshot) {\n  var batch = []; // Convert from hash map to array.\n\n  each(snapshot, function (batchItem, dataZoomId) {\n    batch.push(zrUtil.clone(batchItem));\n  });\n  batch.length && this.api.dispatchAction({\n    type: 'dataZoom',\n    from: this.uid,\n    batch: batch\n  });\n};\n\nfunction retrieveAxisSetting(option) {\n  var setting = {}; // Compatible with previous setting: null => all axis, false => no axis.\n\n  zrUtil.each(['xAxisIndex', 'yAxisIndex'], function (name) {\n    setting[name] = option[name];\n    setting[name] == null && (setting[name] = 'all');\n    (setting[name] === false || setting[name] === 'none') && (setting[name] = []);\n  });\n  return setting;\n}\n\nfunction updateBackBtnStatus(featureModel, ecModel) {\n  featureModel.setIconStatus('back', history.count(ecModel) > 1 ? 'emphasis' : 'normal');\n}\n\nfunction updateZoomBtnStatus(featureModel, ecModel, view, payload, api) {\n  var zoomActive = view._isZoomActive;\n\n  if (payload && payload.type === 'takeGlobalCursor') {\n    zoomActive = payload.key === 'dataZoomSelect' ? payload.dataZoomSelectActive : false;\n  }\n\n  view._isZoomActive = zoomActive;\n  featureModel.setIconStatus('zoom', zoomActive ? 'emphasis' : 'normal');\n  var brushTargetManager = new BrushTargetManager(retrieveAxisSetting(featureModel.option), ecModel, {\n    include: ['grid']\n  });\n\n  view._brushController.setPanels(brushTargetManager.makePanelOpts(api, function (targetInfo) {\n    return targetInfo.xAxisDeclared && !targetInfo.yAxisDeclared ? 'lineX' : !targetInfo.xAxisDeclared && targetInfo.yAxisDeclared ? 'lineY' : 'rect';\n  })).enableBrush(zoomActive ? {\n    brushType: 'auto',\n    brushStyle: {\n      // FIXME user customized?\n      lineWidth: 0,\n      fill: 'rgba(0,0,0,0.2)'\n    }\n  } : false);\n}\n\nfeatureManager.register('dataZoom', DataZoom); // Create special dataZoom option for select\n\necharts.registerPreprocessor(function (option) {\n  if (!option) {\n    return;\n  }\n\n  var dataZoomOpts = option.dataZoom || (option.dataZoom = []);\n\n  if (!zrUtil.isArray(dataZoomOpts)) {\n    option.dataZoom = dataZoomOpts = [dataZoomOpts];\n  }\n\n  var toolboxOpt = option.toolbox;\n\n  if (toolboxOpt) {\n    // Assume there is only one toolbox\n    if (zrUtil.isArray(toolboxOpt)) {\n      toolboxOpt = toolboxOpt[0];\n    }\n\n    if (toolboxOpt && toolboxOpt.feature) {\n      var dataZoomOpt = toolboxOpt.feature.dataZoom;\n      addForAxis('xAxis', dataZoomOpt);\n      addForAxis('yAxis', dataZoomOpt);\n    }\n  }\n\n  function addForAxis(axisName, dataZoomOpt) {\n    if (!dataZoomOpt) {\n      return;\n    } // Try not to modify model, because it is not merged yet.\n\n\n    var axisIndicesName = axisName + 'Index';\n    var givenAxisIndices = dataZoomOpt[axisIndicesName];\n\n    if (givenAxisIndices != null && givenAxisIndices != 'all' && !zrUtil.isArray(givenAxisIndices)) {\n      givenAxisIndices = givenAxisIndices === false || givenAxisIndices === 'none' ? [] : [givenAxisIndices];\n    }\n\n    forEachComponent(axisName, function (axisOpt, axisIndex) {\n      if (givenAxisIndices != null && givenAxisIndices != 'all' && zrUtil.indexOf(givenAxisIndices, axisIndex) === -1) {\n        return;\n      }\n\n      var newOpt = {\n        type: 'select',\n        $fromToolbox: true,\n        // Id for merge mapping.\n        id: DATA_ZOOM_ID_BASE + axisName + axisIndex\n      }; // FIXME\n      // Only support one axis now.\n\n      newOpt[axisIndicesName] = axisIndex;\n      dataZoomOpts.push(newOpt);\n    });\n  }\n\n  function forEachComponent(mainType, cb) {\n    var opts = option[mainType];\n\n    if (!zrUtil.isArray(opts)) {\n      opts = opts ? [opts] : [];\n    }\n\n    each(opts, cb);\n  }\n});\nvar _default = DataZoom;\nmodule.exports = _default;\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/echarts/lib/component/toolbox/feature/DataZoom.js\n// module id = DknX\n// module chunks = 1 2","var zrUtil = require(\"zrender/lib/core/util\");\n\nvar env = require(\"zrender/lib/core/env\");\n\nvar modelUtil = require(\"../../util/model\");\n\nvar get = modelUtil.makeGetter();\nvar each = zrUtil.each;\n/**\n * @param {string} key\n * @param {module:echarts/ExtensionAPI} api\n * @param {Function} handler\n *      param: {string} currTrigger\n *      param: {Array.<number>} point\n */\n\nfunction register(key, api, handler) {\n  if (env.node) {\n    return;\n  }\n\n  var zr = api.getZr();\n  get(zr).records || (get(zr).records = {});\n  initGlobalListeners(zr, api);\n  var record = get(zr).records[key] || (get(zr).records[key] = {});\n  record.handler = handler;\n}\n\nfunction initGlobalListeners(zr, api) {\n  if (get(zr).initialized) {\n    return;\n  }\n\n  get(zr).initialized = true;\n  useHandler('click', zrUtil.curry(doEnter, 'click'));\n  useHandler('mousemove', zrUtil.curry(doEnter, 'mousemove')); // useHandler('mouseout', onLeave);\n\n  useHandler('globalout', onLeave);\n\n  function useHandler(eventType, cb) {\n    zr.on(eventType, function (e) {\n      var dis = makeDispatchAction(api);\n      each(get(zr).records, function (record) {\n        record && cb(record, e, dis.dispatchAction);\n      });\n      dispatchTooltipFinally(dis.pendings, api);\n    });\n  }\n}\n\nfunction dispatchTooltipFinally(pendings, api) {\n  var showLen = pendings.showTip.length;\n  var hideLen = pendings.hideTip.length;\n  var actuallyPayload;\n\n  if (showLen) {\n    actuallyPayload = pendings.showTip[showLen - 1];\n  } else if (hideLen) {\n    actuallyPayload = pendings.hideTip[hideLen - 1];\n  }\n\n  if (actuallyPayload) {\n    actuallyPayload.dispatchAction = null;\n    api.dispatchAction(actuallyPayload);\n  }\n}\n\nfunction onLeave(record, e, dispatchAction) {\n  record.handler('leave', null, dispatchAction);\n}\n\nfunction doEnter(currTrigger, record, e, dispatchAction) {\n  record.handler(currTrigger, e, dispatchAction);\n}\n\nfunction makeDispatchAction(api) {\n  var pendings = {\n    showTip: [],\n    hideTip: []\n  }; // FIXME\n  // better approach?\n  // 'showTip' and 'hideTip' can be triggered by axisPointer and tooltip,\n  // which may be conflict, (axisPointer call showTip but tooltip call hideTip);\n  // So we have to add \"final stage\" to merge those dispatched actions.\n\n  var dispatchAction = function (payload) {\n    var pendingList = pendings[payload.type];\n\n    if (pendingList) {\n      pendingList.push(payload);\n    } else {\n      payload.dispatchAction = dispatchAction;\n      api.dispatchAction(payload);\n    }\n  };\n\n  return {\n    dispatchAction: dispatchAction,\n    pendings: pendings\n  };\n}\n/**\n * @param {string} key\n * @param {module:echarts/ExtensionAPI} api\n */\n\n\nfunction unregister(key, api) {\n  if (env.node) {\n    return;\n  }\n\n  var zr = api.getZr();\n  var record = (get(zr).records || {})[key];\n\n  if (record) {\n    get(zr).records[key] = null;\n  }\n}\n\nexports.register = register;\nexports.unregister = unregister;\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/echarts/lib/component/axisPointer/globalListener.js\n// module id = DpwM\n// module chunks = 1 2","var _default = {\n  toolbox: {\n    brush: {\n      title: {\n        rect: '矩形选择',\n        polygon: '圈选',\n        lineX: '横向选择',\n        lineY: '纵向选择',\n        keep: '保持选择',\n        clear: '清除选择'\n      }\n    },\n    dataView: {\n      title: '数据视图',\n      lang: ['数据视图', '关闭', '刷新']\n    },\n    dataZoom: {\n      title: {\n        zoom: '区域缩放',\n        back: '区域缩放还原'\n      }\n    },\n    magicType: {\n      title: {\n        line: '切换为折线图',\n        bar: '切换为柱状图',\n        stack: '切换为堆叠',\n        tiled: '切换为平铺'\n      }\n    },\n    restore: {\n      title: '还原'\n    },\n    saveAsImage: {\n      title: '保存为图片',\n      lang: ['右键另存为图片']\n    }\n  }\n};\nmodule.exports = _default;\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/echarts/lib/lang.js\n// module id = FIAY\n// module chunks = 1 2","var zrUtil = require(\"zrender/lib/core/util\");\n\nvar numberUtil = require(\"../../util/number\");\n\nvar helper = require(\"./helper\");\n\nvar each = zrUtil.each;\nvar asc = numberUtil.asc;\n/**\n * Operate single axis.\n * One axis can only operated by one axis operator.\n * Different dataZoomModels may be defined to operate the same axis.\n * (i.e. 'inside' data zoom and 'slider' data zoom components)\n * So dataZoomModels share one axisProxy in that case.\n *\n * @class\n */\n\nvar AxisProxy = function (dimName, axisIndex, dataZoomModel, ecModel) {\n  /**\n   * @private\n   * @type {string}\n   */\n  this._dimName = dimName;\n  /**\n   * @private\n   */\n\n  this._axisIndex = axisIndex;\n  /**\n   * @private\n   * @type {Array.<number>}\n   */\n\n  this._valueWindow;\n  /**\n   * @private\n   * @type {Array.<number>}\n   */\n\n  this._percentWindow;\n  /**\n   * @private\n   * @type {Array.<number>}\n   */\n\n  this._dataExtent;\n  /**\n   * {minSpan, maxSpan, minValueSpan, maxValueSpan}\n   * @private\n   * @type {Object}\n   */\n\n  this._minMaxSpan;\n  /**\n   * @readOnly\n   * @type {module: echarts/model/Global}\n   */\n\n  this.ecModel = ecModel;\n  /**\n   * @private\n   * @type {module: echarts/component/dataZoom/DataZoomModel}\n   */\n\n  this._dataZoomModel = dataZoomModel;\n};\n\nAxisProxy.prototype = {\n  constructor: AxisProxy,\n\n  /**\n   * Whether the axisProxy is hosted by dataZoomModel.\n   *\n   * @public\n   * @param {module: echarts/component/dataZoom/DataZoomModel} dataZoomModel\n   * @return {boolean}\n   */\n  hostedBy: function (dataZoomModel) {\n    return this._dataZoomModel === dataZoomModel;\n  },\n\n  /**\n   * @return {Array.<number>} Value can only be NaN or finite value.\n   */\n  getDataValueWindow: function () {\n    return this._valueWindow.slice();\n  },\n\n  /**\n   * @return {Array.<number>}\n   */\n  getDataPercentWindow: function () {\n    return this._percentWindow.slice();\n  },\n\n  /**\n   * @public\n   * @param {number} axisIndex\n   * @return {Array} seriesModels\n   */\n  getTargetSeriesModels: function () {\n    var seriesModels = [];\n    var ecModel = this.ecModel;\n    ecModel.eachSeries(function (seriesModel) {\n      if (helper.isCoordSupported(seriesModel.get('coordinateSystem'))) {\n        var dimName = this._dimName;\n        var axisModel = ecModel.queryComponents({\n          mainType: dimName + 'Axis',\n          index: seriesModel.get(dimName + 'AxisIndex'),\n          id: seriesModel.get(dimName + 'AxisId')\n        })[0];\n\n        if (this._axisIndex === (axisModel && axisModel.componentIndex)) {\n          seriesModels.push(seriesModel);\n        }\n      }\n    }, this);\n    return seriesModels;\n  },\n  getAxisModel: function () {\n    return this.ecModel.getComponent(this._dimName + 'Axis', this._axisIndex);\n  },\n  getOtherAxisModel: function () {\n    var axisDim = this._dimName;\n    var ecModel = this.ecModel;\n    var axisModel = this.getAxisModel();\n    var isCartesian = axisDim === 'x' || axisDim === 'y';\n    var otherAxisDim;\n    var coordSysIndexName;\n\n    if (isCartesian) {\n      coordSysIndexName = 'gridIndex';\n      otherAxisDim = axisDim === 'x' ? 'y' : 'x';\n    } else {\n      coordSysIndexName = 'polarIndex';\n      otherAxisDim = axisDim === 'angle' ? 'radius' : 'angle';\n    }\n\n    var foundOtherAxisModel;\n    ecModel.eachComponent(otherAxisDim + 'Axis', function (otherAxisModel) {\n      if ((otherAxisModel.get(coordSysIndexName) || 0) === (axisModel.get(coordSysIndexName) || 0)) {\n        foundOtherAxisModel = otherAxisModel;\n      }\n    });\n    return foundOtherAxisModel;\n  },\n  getMinMaxSpan: function () {\n    return zrUtil.clone(this._minMaxSpan);\n  },\n\n  /**\n   * Only calculate by given range and this._dataExtent, do not change anything.\n   *\n   * @param {Object} opt\n   * @param {number} [opt.start]\n   * @param {number} [opt.end]\n   * @param {number} [opt.startValue]\n   * @param {number} [opt.endValue]\n   */\n  calculateDataWindow: function (opt) {\n    var dataExtent = this._dataExtent;\n    var axisModel = this.getAxisModel();\n    var scale = axisModel.axis.scale;\n\n    var rangePropMode = this._dataZoomModel.getRangePropMode();\n\n    var percentExtent = [0, 100];\n    var percentWindow = [opt.start, opt.end];\n    var valueWindow = [];\n    each(['startValue', 'endValue'], function (prop) {\n      valueWindow.push(opt[prop] != null ? scale.parse(opt[prop]) : null);\n    }); // Normalize bound.\n\n    each([0, 1], function (idx) {\n      var boundValue = valueWindow[idx];\n      var boundPercent = percentWindow[idx]; // Notice: dataZoom is based either on `percentProp` ('start', 'end') or\n      // on `valueProp` ('startValue', 'endValue'). The former one is suitable\n      // for cases that a dataZoom component controls multiple axes with different\n      // unit or extent, and the latter one is suitable for accurate zoom by pixel\n      // (e.g., in dataZoomSelect). `valueProp` can be calculated from `percentProp`,\n      // but it is awkward that `percentProp` can not be obtained from `valueProp`\n      // accurately (because all of values that are overflow the `dataExtent` will\n      // be calculated to percent '100%'). So we have to use\n      // `dataZoom.getRangePropMode()` to mark which prop is used.\n      // `rangePropMode` is updated only when setOption or dispatchAction, otherwise\n      // it remains its original value.\n\n      if (rangePropMode[idx] === 'percent') {\n        if (boundPercent == null) {\n          boundPercent = percentExtent[idx];\n        } // Use scale.parse to math round for category or time axis.\n\n\n        boundValue = scale.parse(numberUtil.linearMap(boundPercent, percentExtent, dataExtent, true));\n      } else {\n        // Calculating `percent` from `value` may be not accurate, because\n        // This calculation can not be inversed, because all of values that\n        // are overflow the `dataExtent` will be calculated to percent '100%'\n        boundPercent = numberUtil.linearMap(boundValue, dataExtent, percentExtent, true);\n      } // valueWindow[idx] = round(boundValue);\n      // percentWindow[idx] = round(boundPercent);\n\n\n      valueWindow[idx] = boundValue;\n      percentWindow[idx] = boundPercent;\n    });\n    return {\n      valueWindow: asc(valueWindow),\n      percentWindow: asc(percentWindow)\n    };\n  },\n\n  /**\n   * Notice: reset should not be called before series.restoreData() called,\n   * so it is recommanded to be called in \"process stage\" but not \"model init\n   * stage\".\n   *\n   * @param {module: echarts/component/dataZoom/DataZoomModel} dataZoomModel\n   */\n  reset: function (dataZoomModel) {\n    if (dataZoomModel !== this._dataZoomModel) {\n      return;\n    } // Culculate data window and data extent, and record them.\n\n\n    this._dataExtent = calculateDataExtent(this, this._dimName, this.getTargetSeriesModels());\n    var dataWindow = this.calculateDataWindow(dataZoomModel.option);\n    this._valueWindow = dataWindow.valueWindow;\n    this._percentWindow = dataWindow.percentWindow;\n    setMinMaxSpan(this); // Update axis setting then.\n\n    setAxisModel(this);\n  },\n\n  /**\n   * @param {module: echarts/component/dataZoom/DataZoomModel} dataZoomModel\n   */\n  restore: function (dataZoomModel) {\n    if (dataZoomModel !== this._dataZoomModel) {\n      return;\n    }\n\n    this._valueWindow = this._percentWindow = null;\n    setAxisModel(this, true);\n  },\n\n  /**\n   * @param {module: echarts/component/dataZoom/DataZoomModel} dataZoomModel\n   */\n  filterData: function (dataZoomModel) {\n    if (dataZoomModel !== this._dataZoomModel) {\n      return;\n    }\n\n    var axisDim = this._dimName;\n    var seriesModels = this.getTargetSeriesModels();\n    var filterMode = dataZoomModel.get('filterMode');\n    var valueWindow = this._valueWindow;\n\n    if (filterMode === 'none') {\n      return;\n    } // FIXME\n    // Toolbox may has dataZoom injected. And if there are stacked bar chart\n    // with NaN data, NaN will be filtered and stack will be wrong.\n    // So we need to force the mode to be set empty.\n    // In fect, it is not a big deal that do not support filterMode-'filter'\n    // when using toolbox#dataZoom, utill tooltip#dataZoom support \"single axis\n    // selection\" some day, which might need \"adapt to data extent on the\n    // otherAxis\", which is disabled by filterMode-'empty'.\n\n\n    var otherAxisModel = this.getOtherAxisModel();\n\n    if (dataZoomModel.get('$fromToolbox') && otherAxisModel && otherAxisModel.get('type') === 'category') {\n      filterMode = 'empty';\n    } // Process series data\n\n\n    each(seriesModels, function (seriesModel) {\n      var seriesData = seriesModel.getData();\n      var dataDims = seriesModel.coordDimToDataDim(axisDim);\n\n      if (filterMode === 'weakFilter') {\n        seriesData && seriesData.filterSelf(function (dataIndex) {\n          var leftOut;\n          var rightOut;\n          var hasValue;\n\n          for (var i = 0; i < dataDims.length; i++) {\n            var value = seriesData.get(dataDims[i], dataIndex);\n            var thisHasValue = !isNaN(value);\n            var thisLeftOut = value < valueWindow[0];\n            var thisRightOut = value > valueWindow[1];\n\n            if (thisHasValue && !thisLeftOut && !thisRightOut) {\n              return true;\n            }\n\n            thisHasValue && (hasValue = true);\n            thisLeftOut && (leftOut = true);\n            thisRightOut && (rightOut = true);\n          } // If both left out and right out, do not filter.\n\n\n          return hasValue && leftOut && rightOut;\n        });\n      } else {\n        seriesData && each(dataDims, function (dim) {\n          if (filterMode === 'empty') {\n            seriesModel.setData(seriesData.map(dim, function (value) {\n              return !isInWindow(value) ? NaN : value;\n            }));\n          } else {\n            seriesData.filterSelf(dim, isInWindow);\n          }\n        });\n      }\n    });\n\n    function isInWindow(value) {\n      return value >= valueWindow[0] && value <= valueWindow[1];\n    }\n  }\n};\n\nfunction calculateDataExtent(axisProxy, axisDim, seriesModels) {\n  var dataExtent = [Infinity, -Infinity];\n  each(seriesModels, function (seriesModel) {\n    var seriesData = seriesModel.getData();\n\n    if (seriesData) {\n      each(seriesModel.coordDimToDataDim(axisDim), function (dim) {\n        var seriesExtent = seriesData.getDataExtent(dim);\n        seriesExtent[0] < dataExtent[0] && (dataExtent[0] = seriesExtent[0]);\n        seriesExtent[1] > dataExtent[1] && (dataExtent[1] = seriesExtent[1]);\n      });\n    }\n  });\n\n  if (dataExtent[1] < dataExtent[0]) {\n    dataExtent = [NaN, NaN];\n  } // It is important to get \"consistent\" extent when more then one axes is\n  // controlled by a `dataZoom`, otherwise those axes will not be synchronized\n  // when zooming. But it is difficult to know what is \"consistent\", considering\n  // axes have different type or even different meanings (For example, two\n  // time axes are used to compare data of the same date in different years).\n  // So basically dataZoom just obtains extent by series.data (in category axis\n  // extent can be obtained from axis.data).\n  // Nevertheless, user can set min/max/scale on axes to make extent of axes\n  // consistent.\n\n\n  fixExtentByAxis(axisProxy, dataExtent);\n  return dataExtent;\n}\n\nfunction fixExtentByAxis(axisProxy, dataExtent) {\n  var axisModel = axisProxy.getAxisModel();\n  var min = axisModel.getMin(true); // For category axis, if min/max/scale are not set, extent is determined\n  // by axis.data by default.\n\n  var isCategoryAxis = axisModel.get('type') === 'category';\n  var axisDataLen = isCategoryAxis && (axisModel.get('data') || []).length;\n\n  if (min != null && min !== 'dataMin' && typeof min !== 'function') {\n    dataExtent[0] = min;\n  } else if (isCategoryAxis) {\n    dataExtent[0] = axisDataLen > 0 ? 0 : NaN;\n  }\n\n  var max = axisModel.getMax(true);\n\n  if (max != null && max !== 'dataMax' && typeof max !== 'function') {\n    dataExtent[1] = max;\n  } else if (isCategoryAxis) {\n    dataExtent[1] = axisDataLen > 0 ? axisDataLen - 1 : NaN;\n  }\n\n  if (!axisModel.get('scale', true)) {\n    dataExtent[0] > 0 && (dataExtent[0] = 0);\n    dataExtent[1] < 0 && (dataExtent[1] = 0);\n  } // For value axis, if min/max/scale are not set, we just use the extent obtained\n  // by series data, which may be a little different from the extent calculated by\n  // `axisHelper.getScaleExtent`. But the different just affects the experience a\n  // little when zooming. So it will not be fixed until some users require it strongly.\n\n\n  return dataExtent;\n}\n\nfunction setAxisModel(axisProxy, isRestore) {\n  var axisModel = axisProxy.getAxisModel();\n  var percentWindow = axisProxy._percentWindow;\n  var valueWindow = axisProxy._valueWindow;\n\n  if (!percentWindow) {\n    return;\n  } // [0, 500]: arbitrary value, guess axis extent.\n\n\n  var precision = numberUtil.getPixelPrecision(valueWindow, [0, 500]);\n  precision = Math.min(precision, 20); // isRestore or isFull\n\n  var useOrigin = isRestore || percentWindow[0] === 0 && percentWindow[1] === 100;\n  axisModel.setRange(useOrigin ? null : +valueWindow[0].toFixed(precision), useOrigin ? null : +valueWindow[1].toFixed(precision));\n}\n\nfunction setMinMaxSpan(axisProxy) {\n  var minMaxSpan = axisProxy._minMaxSpan = {};\n  var dataZoomModel = axisProxy._dataZoomModel;\n  each(['min', 'max'], function (minMax) {\n    minMaxSpan[minMax + 'Span'] = dataZoomModel.get(minMax + 'Span'); // minValueSpan and maxValueSpan has higher priority than minSpan and maxSpan\n\n    var valueSpan = dataZoomModel.get(minMax + 'ValueSpan');\n\n    if (valueSpan != null) {\n      minMaxSpan[minMax + 'ValueSpan'] = valueSpan;\n      valueSpan = axisProxy.getAxisModel().axis.scale.parse(valueSpan);\n\n      if (valueSpan != null) {\n        var dataExtent = axisProxy._dataExtent;\n        minMaxSpan[minMax + 'Span'] = numberUtil.linearMap(dataExtent[0] + valueSpan, dataExtent, [0, 100], true);\n      }\n    }\n  });\n}\n\nvar _default = AxisProxy;\nmodule.exports = _default;\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/echarts/lib/component/dataZoom/AxisProxy.js\n// module id = GWV8\n// module chunks = 1 2","var echarts = require(\"../echarts\");\n\nvar zrUtil = require(\"zrender/lib/core/util\");\n\nvar barLayoutGrid = require(\"../layout/barGrid\");\n\nrequire(\"../coord/cartesian/Grid\");\n\nrequire(\"./bar/BarSeries\");\n\nrequire(\"./bar/BarView\");\n\nrequire(\"../component/gridSimple\");\n\n// In case developer forget to include grid component\necharts.registerLayout(zrUtil.curry(barLayoutGrid, 'bar')); // Visual coding for legend\n\necharts.registerVisual(function (ecModel) {\n  ecModel.eachSeriesByType('bar', function (seriesModel) {\n    var data = seriesModel.getData();\n    data.setVisual('legendSymbol', 'roundRect');\n  });\n});\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/echarts/lib/chart/bar.js\n// module id = GbHy\n// module chunks = 1 2","\"use strict\";\n\nexports.__esModule = true;\n\nvar _from = require(\"../core-js/array/from\");\n\nvar _from2 = _interopRequireDefault(_from);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nexports.default = function (arr) {\n  if (Array.isArray(arr)) {\n    for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) {\n      arr2[i] = arr[i];\n    }\n\n    return arr2;\n  } else {\n    return (0, _from2.default)(arr);\n  }\n};\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/babel-runtime/helpers/toConsumableArray.js\n// module id = Gu7T\n// module chunks = 2","var echarts = require(\"../../../echarts\");\n\nvar history = require(\"../../dataZoom/history\");\n\nvar lang = require(\"../../../lang\");\n\nvar featureManager = require(\"../featureManager\");\n\nvar restoreLang = lang.toolbox.restore;\n\nfunction Restore(model) {\n  this.model = model;\n}\n\nRestore.defaultOption = {\n  show: true,\n  icon: 'M3.8,33.4 M47,18.9h9.8V8.7 M56.3,20.1 C52.1,9,40.5,0.6,26.8,2.1C12.6,3.7,1.6,16.2,2.1,30.6 M13,41.1H3.1v10.2 M3.7,39.9c4.2,11.1,15.8,19.5,29.5,18 c14.2-1.6,25.2-14.1,24.7-28.5',\n  title: restoreLang.title\n};\nvar proto = Restore.prototype;\n\nproto.onclick = function (ecModel, api, type) {\n  history.clear(ecModel);\n  api.dispatchAction({\n    type: 'restore',\n    from: this.uid\n  });\n};\n\nfeatureManager.register('restore', Restore);\necharts.registerAction({\n  type: 'restore',\n  event: 'restore',\n  update: 'prepareAndUpdate'\n}, function (payload, ecModel) {\n  ecModel.resetOption('recreate');\n});\nvar _default = Restore;\nmodule.exports = _default;\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/echarts/lib/component/toolbox/feature/Restore.js\n// module id = JMu0\n// module chunks = 1 2","var echarts = require(\"../../echarts\");\n\nvar zrUtil = require(\"zrender/lib/core/util\");\n\nvar helper = require(\"./helper\");\n\necharts.registerAction('dataZoom', function (payload, ecModel) {\n  var linkedNodesFinder = helper.createLinkedNodesFinder(zrUtil.bind(ecModel.eachComponent, ecModel, 'dataZoom'), helper.eachAxisDim, function (model, dimNames) {\n    return model.get(dimNames.axisIndex);\n  });\n  var effectedModels = [];\n  ecModel.eachComponent({\n    mainType: 'dataZoom',\n    query: payload\n  }, function (model, index) {\n    effectedModels.push.apply(effectedModels, linkedNodesFinder(model).nodes);\n  });\n  zrUtil.each(effectedModels, function (dataZoomModel, index) {\n    dataZoomModel.setRawRange({\n      start: payload.start,\n      end: payload.end,\n      startValue: payload.startValue,\n      endValue: payload.endValue\n    });\n  });\n});\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/echarts/lib/component/dataZoom/dataZoomAction.js\n// module id = KAfT\n// module chunks = 1 2","var Path = require(\"zrender/lib/graphic/Path\");\n\nvar vec2 = require(\"zrender/lib/core/vector\");\n\nvar fixClipWithShadow = require(\"zrender/lib/graphic/helper/fixClipWithShadow\");\n\n// Poly path support NaN point\nvar vec2Min = vec2.min;\nvar vec2Max = vec2.max;\nvar scaleAndAdd = vec2.scaleAndAdd;\nvar v2Copy = vec2.copy; // Temporary variable\n\nvar v = [];\nvar cp0 = [];\nvar cp1 = [];\n\nfunction isPointNull(p) {\n  return isNaN(p[0]) || isNaN(p[1]);\n}\n\nfunction drawSegment(ctx, points, start, segLen, allLen, dir, smoothMin, smoothMax, smooth, smoothMonotone, connectNulls) {\n  var prevIdx = 0;\n  var idx = start;\n\n  for (var k = 0; k < segLen; k++) {\n    var p = points[idx];\n\n    if (idx >= allLen || idx < 0) {\n      break;\n    }\n\n    if (isPointNull(p)) {\n      if (connectNulls) {\n        idx += dir;\n        continue;\n      }\n\n      break;\n    }\n\n    if (idx === start) {\n      ctx[dir > 0 ? 'moveTo' : 'lineTo'](p[0], p[1]);\n      v2Copy(cp0, p);\n    } else {\n      if (smooth > 0) {\n        var nextIdx = idx + dir;\n        var nextP = points[nextIdx];\n\n        if (connectNulls) {\n          // Find next point not null\n          while (nextP && isPointNull(points[nextIdx])) {\n            nextIdx += dir;\n            nextP = points[nextIdx];\n          }\n        }\n\n        var ratioNextSeg = 0.5;\n        var prevP = points[prevIdx];\n        var nextP = points[nextIdx]; // Last point\n\n        if (!nextP || isPointNull(nextP)) {\n          v2Copy(cp1, p);\n        } else {\n          // If next data is null in not connect case\n          if (isPointNull(nextP) && !connectNulls) {\n            nextP = p;\n          }\n\n          vec2.sub(v, nextP, prevP);\n          var lenPrevSeg;\n          var lenNextSeg;\n\n          if (smoothMonotone === 'x' || smoothMonotone === 'y') {\n            var dim = smoothMonotone === 'x' ? 0 : 1;\n            lenPrevSeg = Math.abs(p[dim] - prevP[dim]);\n            lenNextSeg = Math.abs(p[dim] - nextP[dim]);\n          } else {\n            lenPrevSeg = vec2.dist(p, prevP);\n            lenNextSeg = vec2.dist(p, nextP);\n          } // Use ratio of seg length\n\n\n          ratioNextSeg = lenNextSeg / (lenNextSeg + lenPrevSeg);\n          scaleAndAdd(cp1, p, v, -smooth * (1 - ratioNextSeg));\n        } // Smooth constraint\n\n\n        vec2Min(cp0, cp0, smoothMax);\n        vec2Max(cp0, cp0, smoothMin);\n        vec2Min(cp1, cp1, smoothMax);\n        vec2Max(cp1, cp1, smoothMin);\n        ctx.bezierCurveTo(cp0[0], cp0[1], cp1[0], cp1[1], p[0], p[1]); // cp0 of next segment\n\n        scaleAndAdd(cp0, p, v, smooth * ratioNextSeg);\n      } else {\n        ctx.lineTo(p[0], p[1]);\n      }\n    }\n\n    prevIdx = idx;\n    idx += dir;\n  }\n\n  return k;\n}\n\nfunction getBoundingBox(points, smoothConstraint) {\n  var ptMin = [Infinity, Infinity];\n  var ptMax = [-Infinity, -Infinity];\n\n  if (smoothConstraint) {\n    for (var i = 0; i < points.length; i++) {\n      var pt = points[i];\n\n      if (pt[0] < ptMin[0]) {\n        ptMin[0] = pt[0];\n      }\n\n      if (pt[1] < ptMin[1]) {\n        ptMin[1] = pt[1];\n      }\n\n      if (pt[0] > ptMax[0]) {\n        ptMax[0] = pt[0];\n      }\n\n      if (pt[1] > ptMax[1]) {\n        ptMax[1] = pt[1];\n      }\n    }\n  }\n\n  return {\n    min: smoothConstraint ? ptMin : ptMax,\n    max: smoothConstraint ? ptMax : ptMin\n  };\n}\n\nvar Polyline = Path.extend({\n  type: 'ec-polyline',\n  shape: {\n    points: [],\n    smooth: 0,\n    smoothConstraint: true,\n    smoothMonotone: null,\n    connectNulls: false\n  },\n  style: {\n    fill: null,\n    stroke: '#000'\n  },\n  brush: fixClipWithShadow(Path.prototype.brush),\n  buildPath: function (ctx, shape) {\n    var points = shape.points;\n    var i = 0;\n    var len = points.length;\n    var result = getBoundingBox(points, shape.smoothConstraint);\n\n    if (shape.connectNulls) {\n      // Must remove first and last null values avoid draw error in polygon\n      for (; len > 0; len--) {\n        if (!isPointNull(points[len - 1])) {\n          break;\n        }\n      }\n\n      for (; i < len; i++) {\n        if (!isPointNull(points[i])) {\n          break;\n        }\n      }\n    }\n\n    while (i < len) {\n      i += drawSegment(ctx, points, i, len, len, 1, result.min, result.max, shape.smooth, shape.smoothMonotone, shape.connectNulls) + 1;\n    }\n  }\n});\nvar Polygon = Path.extend({\n  type: 'ec-polygon',\n  shape: {\n    points: [],\n    // Offset between stacked base points and points\n    stackedOnPoints: [],\n    smooth: 0,\n    stackedOnSmooth: 0,\n    smoothConstraint: true,\n    smoothMonotone: null,\n    connectNulls: false\n  },\n  brush: fixClipWithShadow(Path.prototype.brush),\n  buildPath: function (ctx, shape) {\n    var points = shape.points;\n    var stackedOnPoints = shape.stackedOnPoints;\n    var i = 0;\n    var len = points.length;\n    var smoothMonotone = shape.smoothMonotone;\n    var bbox = getBoundingBox(points, shape.smoothConstraint);\n    var stackedOnBBox = getBoundingBox(stackedOnPoints, shape.smoothConstraint);\n\n    if (shape.connectNulls) {\n      // Must remove first and last null values avoid draw error in polygon\n      for (; len > 0; len--) {\n        if (!isPointNull(points[len - 1])) {\n          break;\n        }\n      }\n\n      for (; i < len; i++) {\n        if (!isPointNull(points[i])) {\n          break;\n        }\n      }\n    }\n\n    while (i < len) {\n      var k = drawSegment(ctx, points, i, len, len, 1, bbox.min, bbox.max, shape.smooth, smoothMonotone, shape.connectNulls);\n      drawSegment(ctx, stackedOnPoints, i + k - 1, k, len, -1, stackedOnBBox.min, stackedOnBBox.max, shape.stackedOnSmooth, smoothMonotone, shape.connectNulls);\n      i += k + 1;\n      ctx.closePath();\n    }\n  }\n});\nexports.Polyline = Polyline;\nexports.Polygon = Polygon;\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/echarts/lib/chart/line/poly.js\n// module id = MXTC\n// module chunks = 1 2","var _config = require(\"../../config\");\n\nvar __DEV__ = _config.__DEV__;\n\nvar echarts = require(\"../../echarts\");\n\nvar zrUtil = require(\"zrender/lib/core/util\");\n\nvar env = require(\"zrender/lib/core/env\");\n\nvar modelUtil = require(\"../../util/model\");\n\nvar formatUtil = require(\"../../util/format\");\n\nvar addCommas = formatUtil.addCommas;\nvar encodeHTML = formatUtil.encodeHTML;\n\nfunction fillLabel(opt) {\n  modelUtil.defaultEmphasis(opt.label, ['show']);\n}\n\nvar MarkerModel = echarts.extendComponentModel({\n  type: 'marker',\n  dependencies: ['series', 'grid', 'polar', 'geo'],\n\n  /**\n   * @overrite\n   */\n  init: function (option, parentModel, ecModel, extraOpt) {\n    this.mergeDefaultAndTheme(option, ecModel);\n    this.mergeOption(option, ecModel, extraOpt.createdBySelf, true);\n  },\n\n  /**\n   * @return {boolean}\n   */\n  isAnimationEnabled: function () {\n    if (env.node) {\n      return false;\n    }\n\n    var hostSeries = this.__hostSeries;\n    return this.getShallow('animation') && hostSeries && hostSeries.isAnimationEnabled();\n  },\n  mergeOption: function (newOpt, ecModel, createdBySelf, isInit) {\n    var MarkerModel = this.constructor;\n    var modelPropName = this.mainType + 'Model';\n\n    if (!createdBySelf) {\n      ecModel.eachSeries(function (seriesModel) {\n        var markerOpt = seriesModel.get(this.mainType);\n        var markerModel = seriesModel[modelPropName];\n\n        if (!markerOpt || !markerOpt.data) {\n          seriesModel[modelPropName] = null;\n          return;\n        }\n\n        if (!markerModel) {\n          if (isInit) {\n            // Default label emphasis `position` and `show`\n            fillLabel(markerOpt);\n          }\n\n          zrUtil.each(markerOpt.data, function (item) {\n            // FIXME Overwrite fillLabel method ?\n            if (item instanceof Array) {\n              fillLabel(item[0]);\n              fillLabel(item[1]);\n            } else {\n              fillLabel(item);\n            }\n          });\n          markerModel = new MarkerModel(markerOpt, this, ecModel);\n          zrUtil.extend(markerModel, {\n            mainType: this.mainType,\n            // Use the same series index and name\n            seriesIndex: seriesModel.seriesIndex,\n            name: seriesModel.name,\n            createdBySelf: true\n          });\n          markerModel.__hostSeries = seriesModel;\n        } else {\n          markerModel.mergeOption(markerOpt, ecModel, true);\n        }\n\n        seriesModel[modelPropName] = markerModel;\n      }, this);\n    }\n  },\n  formatTooltip: function (dataIndex) {\n    var data = this.getData();\n    var value = this.getRawValue(dataIndex);\n    var formattedValue = zrUtil.isArray(value) ? zrUtil.map(value, addCommas).join(', ') : addCommas(value);\n    var name = data.getName(dataIndex);\n    var html = encodeHTML(this.name);\n\n    if (value != null || name) {\n      html += '<br />';\n    }\n\n    if (name) {\n      html += encodeHTML(name);\n\n      if (value != null) {\n        html += ' : ';\n      }\n    }\n\n    if (value != null) {\n      html += encodeHTML(formattedValue);\n    }\n\n    return html;\n  },\n  getData: function () {\n    return this._data;\n  },\n  setData: function (data) {\n    this._data = data;\n  }\n});\nzrUtil.mixin(MarkerModel, modelUtil.dataFormatMixin);\nvar _default = MarkerModel;\nmodule.exports = _default;\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/echarts/lib/component/marker/MarkerModel.js\n// module id = Mlni\n// module chunks = 1 2","var IRRELEVANT_EXCLUDES = {\n  'axisPointer': 1,\n  'tooltip': 1,\n  'brush': 1\n};\n/**\n * Avoid that: mouse click on a elements that is over geo or graph,\n * but roam is triggered.\n */\n\nfunction onIrrelevantElement(e, api, targetCoordSysModel) {\n  var model = api.getComponentByElement(e.topTarget); // If model is axisModel, it works only if it is injected with coordinateSystem.\n\n  var coordSys = model && model.coordinateSystem;\n  return model && model !== targetCoordSysModel && !IRRELEVANT_EXCLUDES[model.mainType] && coordSys && coordSys.model !== targetCoordSysModel;\n}\n\nexports.onIrrelevantElement = onIrrelevantElement;\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/echarts/lib/component/helper/cursorHelper.js\n// module id = NKek\n// module chunks = 1 2","var echarts = require(\"../echarts\");\n\nrequire(\"./axisPointer\");\n\nrequire(\"./tooltip/TooltipModel\");\n\nrequire(\"./tooltip/TooltipView\");\n\n// FIXME Better way to pack data in graphic element\n\n/**\n * @action\n * @property {string} type\n * @property {number} seriesIndex\n * @property {number} dataIndex\n * @property {number} [x]\n * @property {number} [y]\n */\necharts.registerAction({\n  type: 'showTip',\n  event: 'showTip',\n  update: 'tooltip:manuallyShowTip'\n}, // noop\nfunction () {});\necharts.registerAction({\n  type: 'hideTip',\n  event: 'hideTip',\n  update: 'tooltip:manuallyHideTip'\n}, // noop\nfunction () {});\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/echarts/lib/component/tooltip.js\n// module id = Oq2I\n// module chunks = 1 2","var zrUtil = require(\"zrender/lib/core/util\");\n\nvar clazzUtil = require(\"../../util/clazz\");\n\nvar graphic = require(\"../../util/graphic\");\n\nvar axisPointerModelHelper = require(\"./modelHelper\");\n\nvar eventTool = require(\"zrender/lib/core/event\");\n\nvar throttleUtil = require(\"../../util/throttle\");\n\nvar modelUtil = require(\"../../util/model\");\n\nvar get = modelUtil.makeGetter();\nvar clone = zrUtil.clone;\nvar bind = zrUtil.bind;\n/**\n * Base axis pointer class in 2D.\n * Implemenents {module:echarts/component/axis/IAxisPointer}.\n */\n\nfunction BaseAxisPointer() {}\n\nBaseAxisPointer.prototype = {\n  /**\n   * @private\n   */\n  _group: null,\n\n  /**\n   * @private\n   */\n  _lastGraphicKey: null,\n\n  /**\n   * @private\n   */\n  _handle: null,\n\n  /**\n   * @private\n   */\n  _dragging: false,\n\n  /**\n   * @private\n   */\n  _lastValue: null,\n\n  /**\n   * @private\n   */\n  _lastStatus: null,\n\n  /**\n   * @private\n   */\n  _payloadInfo: null,\n\n  /**\n   * In px, arbitrary value. Do not set too small,\n   * no animation is ok for most cases.\n   * @protected\n   */\n  animationThreshold: 15,\n\n  /**\n   * @implement\n   */\n  render: function (axisModel, axisPointerModel, api, forceRender) {\n    var value = axisPointerModel.get('value');\n    var status = axisPointerModel.get('status'); // Bind them to `this`, not in closure, otherwise they will not\n    // be replaced when user calling setOption in not merge mode.\n\n    this._axisModel = axisModel;\n    this._axisPointerModel = axisPointerModel;\n    this._api = api; // Optimize: `render` will be called repeatly during mouse move.\n    // So it is power consuming if performing `render` each time,\n    // especially on mobile device.\n\n    if (!forceRender && this._lastValue === value && this._lastStatus === status) {\n      return;\n    }\n\n    this._lastValue = value;\n    this._lastStatus = status;\n    var group = this._group;\n    var handle = this._handle;\n\n    if (!status || status === 'hide') {\n      // Do not clear here, for animation better.\n      group && group.hide();\n      handle && handle.hide();\n      return;\n    }\n\n    group && group.show();\n    handle && handle.show(); // Otherwise status is 'show'\n\n    var elOption = {};\n    this.makeElOption(elOption, value, axisModel, axisPointerModel, api); // Enable change axis pointer type.\n\n    var graphicKey = elOption.graphicKey;\n\n    if (graphicKey !== this._lastGraphicKey) {\n      this.clear(api);\n    }\n\n    this._lastGraphicKey = graphicKey;\n    var moveAnimation = this._moveAnimation = this.determineAnimation(axisModel, axisPointerModel);\n\n    if (!group) {\n      group = this._group = new graphic.Group();\n      this.createPointerEl(group, elOption, axisModel, axisPointerModel);\n      this.createLabelEl(group, elOption, axisModel, axisPointerModel);\n      api.getZr().add(group);\n    } else {\n      var doUpdateProps = zrUtil.curry(updateProps, axisPointerModel, moveAnimation);\n      this.updatePointerEl(group, elOption, doUpdateProps, axisPointerModel);\n      this.updateLabelEl(group, elOption, doUpdateProps, axisPointerModel);\n    }\n\n    updateMandatoryProps(group, axisPointerModel, true);\n\n    this._renderHandle(value);\n  },\n\n  /**\n   * @implement\n   */\n  remove: function (api) {\n    this.clear(api);\n  },\n\n  /**\n   * @implement\n   */\n  dispose: function (api) {\n    this.clear(api);\n  },\n\n  /**\n   * @protected\n   */\n  determineAnimation: function (axisModel, axisPointerModel) {\n    var animation = axisPointerModel.get('animation');\n    var axis = axisModel.axis;\n    var isCategoryAxis = axis.type === 'category';\n    var useSnap = axisPointerModel.get('snap'); // Value axis without snap always do not snap.\n\n    if (!useSnap && !isCategoryAxis) {\n      return false;\n    }\n\n    if (animation === 'auto' || animation == null) {\n      var animationThreshold = this.animationThreshold;\n\n      if (isCategoryAxis && axis.getBandWidth() > animationThreshold) {\n        return true;\n      } // It is important to auto animation when snap used. Consider if there is\n      // a dataZoom, animation will be disabled when too many points exist, while\n      // it will be enabled for better visual effect when little points exist.\n\n\n      if (useSnap) {\n        var seriesDataCount = axisPointerModelHelper.getAxisInfo(axisModel).seriesDataCount;\n        var axisExtent = axis.getExtent(); // Approximate band width\n\n        return Math.abs(axisExtent[0] - axisExtent[1]) / seriesDataCount > animationThreshold;\n      }\n\n      return false;\n    }\n\n    return animation === true;\n  },\n\n  /**\n   * add {pointer, label, graphicKey} to elOption\n   * @protected\n   */\n  makeElOption: function (elOption, value, axisModel, axisPointerModel, api) {// Shoule be implemenented by sub-class.\n  },\n\n  /**\n   * @protected\n   */\n  createPointerEl: function (group, elOption, axisModel, axisPointerModel) {\n    var pointerOption = elOption.pointer;\n\n    if (pointerOption) {\n      var pointerEl = get(group).pointerEl = new graphic[pointerOption.type](clone(elOption.pointer));\n      group.add(pointerEl);\n    }\n  },\n\n  /**\n   * @protected\n   */\n  createLabelEl: function (group, elOption, axisModel, axisPointerModel) {\n    if (elOption.label) {\n      var labelEl = get(group).labelEl = new graphic.Rect(clone(elOption.label));\n      group.add(labelEl);\n      updateLabelShowHide(labelEl, axisPointerModel);\n    }\n  },\n\n  /**\n   * @protected\n   */\n  updatePointerEl: function (group, elOption, updateProps) {\n    var pointerEl = get(group).pointerEl;\n\n    if (pointerEl) {\n      pointerEl.setStyle(elOption.pointer.style);\n      updateProps(pointerEl, {\n        shape: elOption.pointer.shape\n      });\n    }\n  },\n\n  /**\n   * @protected\n   */\n  updateLabelEl: function (group, elOption, updateProps, axisPointerModel) {\n    var labelEl = get(group).labelEl;\n\n    if (labelEl) {\n      labelEl.setStyle(elOption.label.style);\n      updateProps(labelEl, {\n        // Consider text length change in vertical axis, animation should\n        // be used on shape, otherwise the effect will be weird.\n        shape: elOption.label.shape,\n        position: elOption.label.position\n      });\n      updateLabelShowHide(labelEl, axisPointerModel);\n    }\n  },\n\n  /**\n   * @private\n   */\n  _renderHandle: function (value) {\n    if (this._dragging || !this.updateHandleTransform) {\n      return;\n    }\n\n    var axisPointerModel = this._axisPointerModel;\n\n    var zr = this._api.getZr();\n\n    var handle = this._handle;\n    var handleModel = axisPointerModel.getModel('handle');\n    var status = axisPointerModel.get('status');\n\n    if (!handleModel.get('show') || !status || status === 'hide') {\n      handle && zr.remove(handle);\n      this._handle = null;\n      return;\n    }\n\n    var isInit;\n\n    if (!this._handle) {\n      isInit = true;\n      handle = this._handle = graphic.createIcon(handleModel.get('icon'), {\n        cursor: 'move',\n        draggable: true,\n        onmousemove: function (e) {\n          // Fot mobile devicem, prevent screen slider on the button.\n          eventTool.stop(e.event);\n        },\n        onmousedown: bind(this._onHandleDragMove, this, 0, 0),\n        drift: bind(this._onHandleDragMove, this),\n        ondragend: bind(this._onHandleDragEnd, this)\n      });\n      zr.add(handle);\n    }\n\n    updateMandatoryProps(handle, axisPointerModel, false); // update style\n\n    var includeStyles = ['color', 'borderColor', 'borderWidth', 'opacity', 'shadowColor', 'shadowBlur', 'shadowOffsetX', 'shadowOffsetY'];\n    handle.setStyle(handleModel.getItemStyle(null, includeStyles)); // update position\n\n    var handleSize = handleModel.get('size');\n\n    if (!zrUtil.isArray(handleSize)) {\n      handleSize = [handleSize, handleSize];\n    }\n\n    handle.attr('scale', [handleSize[0] / 2, handleSize[1] / 2]);\n    throttleUtil.createOrUpdate(this, '_doDispatchAxisPointer', handleModel.get('throttle') || 0, 'fixRate');\n\n    this._moveHandleToValue(value, isInit);\n  },\n\n  /**\n   * @private\n   */\n  _moveHandleToValue: function (value, isInit) {\n    updateProps(this._axisPointerModel, !isInit && this._moveAnimation, this._handle, getHandleTransProps(this.getHandleTransform(value, this._axisModel, this._axisPointerModel)));\n  },\n\n  /**\n   * @private\n   */\n  _onHandleDragMove: function (dx, dy) {\n    var handle = this._handle;\n\n    if (!handle) {\n      return;\n    }\n\n    this._dragging = true; // Persistent for throttle.\n\n    var trans = this.updateHandleTransform(getHandleTransProps(handle), [dx, dy], this._axisModel, this._axisPointerModel);\n    this._payloadInfo = trans;\n    handle.stopAnimation();\n    handle.attr(getHandleTransProps(trans));\n    get(handle).lastProp = null;\n\n    this._doDispatchAxisPointer();\n  },\n\n  /**\n   * Throttled method.\n   * @private\n   */\n  _doDispatchAxisPointer: function () {\n    var handle = this._handle;\n\n    if (!handle) {\n      return;\n    }\n\n    var payloadInfo = this._payloadInfo;\n    var axisModel = this._axisModel;\n\n    this._api.dispatchAction({\n      type: 'updateAxisPointer',\n      x: payloadInfo.cursorPoint[0],\n      y: payloadInfo.cursorPoint[1],\n      tooltipOption: payloadInfo.tooltipOption,\n      axesInfo: [{\n        axisDim: axisModel.axis.dim,\n        axisIndex: axisModel.componentIndex\n      }]\n    });\n  },\n\n  /**\n   * @private\n   */\n  _onHandleDragEnd: function (moveAnimation) {\n    this._dragging = false;\n    var handle = this._handle;\n\n    if (!handle) {\n      return;\n    }\n\n    var value = this._axisPointerModel.get('value'); // Consider snap or categroy axis, handle may be not consistent with\n    // axisPointer. So move handle to align the exact value position when\n    // drag ended.\n\n\n    this._moveHandleToValue(value); // For the effect: tooltip will be shown when finger holding on handle\n    // button, and will be hidden after finger left handle button.\n\n\n    this._api.dispatchAction({\n      type: 'hideTip'\n    });\n  },\n\n  /**\n   * Should be implemenented by sub-class if support `handle`.\n   * @protected\n   * @param {number} value\n   * @param {module:echarts/model/Model} axisModel\n   * @param {module:echarts/model/Model} axisPointerModel\n   * @return {Object} {position: [x, y], rotation: 0}\n   */\n  getHandleTransform: null,\n\n  /**\n   * * Should be implemenented by sub-class if support `handle`.\n   * @protected\n   * @param {Object} transform {position, rotation}\n   * @param {Array.<number>} delta [dx, dy]\n   * @param {module:echarts/model/Model} axisModel\n   * @param {module:echarts/model/Model} axisPointerModel\n   * @return {Object} {position: [x, y], rotation: 0, cursorPoint: [x, y]}\n   */\n  updateHandleTransform: null,\n\n  /**\n   * @private\n   */\n  clear: function (api) {\n    this._lastValue = null;\n    this._lastStatus = null;\n    var zr = api.getZr();\n    var group = this._group;\n    var handle = this._handle;\n\n    if (zr && group) {\n      this._lastGraphicKey = null;\n      group && zr.remove(group);\n      handle && zr.remove(handle);\n      this._group = null;\n      this._handle = null;\n      this._payloadInfo = null;\n    }\n  },\n\n  /**\n   * @protected\n   */\n  doClear: function () {// Implemented by sub-class if necessary.\n  },\n\n  /**\n   * @protected\n   * @param {Array.<number>} xy\n   * @param {Array.<number>} wh\n   * @param {number} [xDimIndex=0] or 1\n   */\n  buildLabel: function (xy, wh, xDimIndex) {\n    xDimIndex = xDimIndex || 0;\n    return {\n      x: xy[xDimIndex],\n      y: xy[1 - xDimIndex],\n      width: wh[xDimIndex],\n      height: wh[1 - xDimIndex]\n    };\n  }\n};\nBaseAxisPointer.prototype.constructor = BaseAxisPointer;\n\nfunction updateProps(animationModel, moveAnimation, el, props) {\n  // Animation optimize.\n  if (!propsEqual(get(el).lastProp, props)) {\n    get(el).lastProp = props;\n    moveAnimation ? graphic.updateProps(el, props, animationModel) : (el.stopAnimation(), el.attr(props));\n  }\n}\n\nfunction propsEqual(lastProps, newProps) {\n  if (zrUtil.isObject(lastProps) && zrUtil.isObject(newProps)) {\n    var equals = true;\n    zrUtil.each(newProps, function (item, key) {\n      equals = equals && propsEqual(lastProps[key], item);\n    });\n    return !!equals;\n  } else {\n    return lastProps === newProps;\n  }\n}\n\nfunction updateLabelShowHide(labelEl, axisPointerModel) {\n  labelEl[axisPointerModel.get('label.show') ? 'show' : 'hide']();\n}\n\nfunction getHandleTransProps(trans) {\n  return {\n    position: trans.position.slice(),\n    rotation: trans.rotation || 0\n  };\n}\n\nfunction updateMandatoryProps(group, axisPointerModel, silent) {\n  var z = axisPointerModel.get('z');\n  var zlevel = axisPointerModel.get('zlevel');\n  group && group.traverse(function (el) {\n    if (el.type !== 'group') {\n      z != null && (el.z = z);\n      zlevel != null && (el.zlevel = zlevel);\n      el.silent = silent;\n    }\n  });\n}\n\nclazzUtil.enableClassExtend(BaseAxisPointer);\nvar _default = BaseAxisPointer;\nmodule.exports = _default;\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/echarts/lib/component/axisPointer/BaseAxisPointer.js\n// module id = Ou7x\n// module chunks = 1 2","var zrUtil = require(\"zrender/lib/core/util\");\n\nvar modelUtil = require(\"../../util/model\");\n\n/**\n * @param {Object} finder contains {seriesIndex, dataIndex, dataIndexInside}\n * @param {module:echarts/model/Global} ecModel\n * @return {Object} {point: [x, y], el: ...} point Will not be null.\n */\nfunction _default(finder, ecModel) {\n  var point = [];\n  var seriesIndex = finder.seriesIndex;\n  var seriesModel;\n\n  if (seriesIndex == null || !(seriesModel = ecModel.getSeriesByIndex(seriesIndex))) {\n    return {\n      point: []\n    };\n  }\n\n  var data = seriesModel.getData();\n  var dataIndex = modelUtil.queryDataIndex(data, finder);\n\n  if (dataIndex == null || zrUtil.isArray(dataIndex)) {\n    return {\n      point: []\n    };\n  }\n\n  var el = data.getItemGraphicEl(dataIndex);\n  var coordSys = seriesModel.coordinateSystem;\n\n  if (seriesModel.getTooltipPosition) {\n    point = seriesModel.getTooltipPosition(dataIndex) || [];\n  } else if (coordSys && coordSys.dataToPoint) {\n    point = coordSys.dataToPoint(data.getValues(zrUtil.map(coordSys.dimensions, function (dim) {\n      return seriesModel.coordDimToDataDim(dim)[0];\n    }), dataIndex, true)) || [];\n  } else if (el) {\n    // Use graphic bounding rect\n    var rect = el.getBoundingRect().clone();\n    rect.applyTransform(el.transform);\n    point = [rect.x + rect.width / 2, rect.y + rect.height / 2];\n  }\n\n  return {\n    point: point,\n    el: el\n  };\n}\n\nmodule.exports = _default;\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/echarts/lib/component/axisPointer/findPointFromSeries.js\n// module id = OxCu\n// module chunks = 1 2","var samplers = {\n  average: function (frame) {\n    var sum = 0;\n    var count = 0;\n\n    for (var i = 0; i < frame.length; i++) {\n      if (!isNaN(frame[i])) {\n        sum += frame[i];\n        count++;\n      }\n    } // Return NaN if count is 0\n\n\n    return count === 0 ? NaN : sum / count;\n  },\n  sum: function (frame) {\n    var sum = 0;\n\n    for (var i = 0; i < frame.length; i++) {\n      // Ignore NaN\n      sum += frame[i] || 0;\n    }\n\n    return sum;\n  },\n  max: function (frame) {\n    var max = -Infinity;\n\n    for (var i = 0; i < frame.length; i++) {\n      frame[i] > max && (max = frame[i]);\n    }\n\n    return max;\n  },\n  min: function (frame) {\n    var min = Infinity;\n\n    for (var i = 0; i < frame.length; i++) {\n      frame[i] < min && (min = frame[i]);\n    }\n\n    return min;\n  },\n  // TODO\n  // Median\n  nearest: function (frame) {\n    return frame[0];\n  }\n};\n\nvar indexSampler = function (frame, value) {\n  return Math.round(frame.length / 2);\n};\n\nfunction _default(seriesType, ecModel, api) {\n  ecModel.eachSeriesByType(seriesType, function (seriesModel) {\n    var data = seriesModel.getData();\n    var sampling = seriesModel.get('sampling');\n    var coordSys = seriesModel.coordinateSystem; // Only cartesian2d support down sampling\n\n    if (coordSys.type === 'cartesian2d' && sampling) {\n      var baseAxis = coordSys.getBaseAxis();\n      var valueAxis = coordSys.getOtherAxis(baseAxis);\n      var extent = baseAxis.getExtent(); // Coordinste system has been resized\n\n      var size = extent[1] - extent[0];\n      var rate = Math.round(data.count() / size);\n\n      if (rate > 1) {\n        var sampler;\n\n        if (typeof sampling === 'string') {\n          sampler = samplers[sampling];\n        } else if (typeof sampling === 'function') {\n          sampler = sampling;\n        }\n\n        if (sampler) {\n          data = data.downSample(valueAxis.dim, 1 / rate, sampler, indexSampler);\n          seriesModel.setData(data);\n        }\n      }\n    }\n  }, this);\n}\n\nmodule.exports = _default;\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/echarts/lib/processor/dataSample.js\n// module id = PWa9\n// module chunks = 1 2","const MONTH_DISPLAY = ['', '一月', '二月', '三月', '四月', '五月', '六月', '七月', '八月', '九月', '十月', '十一月', '十二月']\nconst WEEK_DISPLAY = ['日', '一', '二', '三', '四', '五', '六']\n// 单位大小\nconst UNIT_SIZE = {\n    d: 86400000, // 毫秒/天\n    H: 3600000, // 毫秒/小时\n    m: 60000, // 毫秒/分钟\n    s: 1000, // 毫秒/秒\n    S: 1 // 毫秒\n}\n\nconst TimeFormater = function (input) {\n    if (!(this instanceof TimeFormater)) {\n        return new TimeFormater(input)\n    }\n    this[0] = input ? new Date(input) : new Date()\n}\n\nTimeFormater.prototype = {\n\n    format(token) {\n        if (typeof token !== 'string') {\n            return this.toLocaleString()\n        }\n\n        const reg = /Y{4}|M{1,4}|Do|D{1,2}|d{1,4}|Q|H{1,2}|h{1,2}|m{1,2}|s{1,2}|S{1,3}|A|a|x|X/g\n        return token.replace(reg, (match) => this[match] ? this[match]() : match)\n    },\n\n    fromNow() {\n        let oldTime = this[0].getTime()\n        let newTime = Date.now()\n        let diff = Math.floor(newTime - oldTime)\n\n        if (diff < 10000) {\n            return '刚刚'\n        } else if (diff < 60000) {\n            return parseInt(diff / 1000) + '秒前'\n        } else if (diff < 3600000) {\n            return parseInt(diff / 60000) + '分钟前'\n        } else if (diff < 86400000) {\n            return parseInt(diff / 3600000) + '小时前'\n        } else if (diff < 2592000000) {\n            return parseInt(diff / 86400000) + '天前'\n        } else if (diff < 31104000000) {\n            return parseInt(diff / 2592000000) + '月前'\n        } else {\n            return parseInt(diff / 31104000000) + '年前'\n        }\n    },\n    \n    fillZero(num) {\n        return num < 10 ? '0' + num : num\n    },\n\n    YYYY() {\n        return this[0].getFullYear()\n    },\n\n    Q() {\n        return Math.ceil(this.M() / 3)\n    },\n\n    // 月份 [1..12]\n    M() {\n        return this[0].getMonth() + 1\n    },\n\n    // 月份 [01..12]\n    MM() {\n        return this.fillZero(this.M())\n    },\n\n    // 月份 [1月..12月]\n    MMM() {\n        return this.M() + '月'\n    },\n\n    // 月份 [一月..十二月]\n    MMMM() {\n        return MONTH_DISPLAY[this.M()]\n    },\n\n    // 日期 [1..31]\n    D() {\n        return this[0].getDate()\n    },\n\n    // 日期 [1日..31日]\n    Do() {\n        return this.D() + '日'\n    },\n\n    // 日期 [01..31]\n    DD() {\n        return this.fillZero(this.D())\n    },\n\n    // 星期 [0..6]\n    d() {\n        return this[0].getDay()\n    },\n\n    // 星期 [日..六]\n    dd() {\n        return WEEK_DISPLAY[this.d()]\n    },\n\n    // 星期 [周日..周六]\n    ddd() {\n        return '周' + this.dd()\n    },\n\n    // 星期 [星期日..星期六]\n    dddd() {\n        return '星期' + this.dd()\n    },\n\n    // 时 [0..23]\n    H() {\n        return this[0].getHours()\n    },\n\n    // 时 [00..23]\n    HH() {\n        return this.fillZero(this.H())\n    },\n\n    // 时 [1.12]\n    h() {\n        let hour = this.H() % 12\n        return hour || 12\n    },\n\n    // 时 [01..12]\n    hh() {\n        return this.fillZero(this.h())\n    },\n\n    // 分钟 [0..59]\n    m() {\n        return this[0].getMinutes()\n    },\n\n    // 分钟 [00..59]\n    mm() {\n        return this.fillZero(this.m())\n    },\n\n    // 秒 [0..59]\n    s() {\n        return this[0].getSeconds()\n    },\n\n    // 秒 [00..59]\n    ss() {\n        return this.fillZero(this.s())\n    },\n\n    // 毫秒 [0..999]\n    SSS() {\n        return this[0].getMilliseconds()\n    },\n\n    // 毫秒 [0..99]\n    SS() {\n        return Math.floor(this.SSS() / 10)\n    },\n\n    // 毫秒 [0..9]\n    S() {\n        return Math.floor(this.SS() / 10)\n    },\n\n    A() {\n        let hm = this.H() * 100 + this.m()\n        let part = ['凌晨', '早上', '上午', '中午', '下午', '晚上']\n        let interval = [600, 900, 1130, 1230, 1800, Infinity]\n        let i = interval.findIndex(function (item) {\n            return hm < item\n        })\n        return part[i]\n    },\n\n    // A 的别名\n    a() {\n        return this.A()\n    },\n\n    // 时间戳，单位：毫秒\n    x() {\n        return this[0].getTime()\n    },\n\n    // 时间戳，单位：秒\n    X() {\n        return Math.floor(this.x() / 1000)\n    }\n}\n\n/**\n * 倒计时\n * @param {number|string|Date} time 类型为数字表示剩余的秒数，为Date实例或字符串（符合ISO 8601格式），表示结束的时间点。\n */\nTimeFormater.countdown = function (time) {\n    let endPoint = 0\n    if (typeof time === 'number') {\n        // time 为数字类型，表示剩余的秒数\n        endPoint = time * 1000 + Date.now()\n    } else if (typeof time === 'string') {\n        // time 为字符串，则应符合ISO 8601格式，表示结束的时间点\n        endPoint = new Date(time).getTime()\n    } else if (time instanceof Date) {\n        // time 为Date对象实例，表示结束的时间点\n        endPoint = time.getTime()\n    }\n\n    /**\n     * 将剩余的时间量格式化为字符串\n     * @param {string} token 用于指定输出格式。例：'剩余：d天H小时m分钟s秒' => \"剩余：1天11小时4分钟38秒\"。\n     */\n    let format = function (token) {\n        let now = Date.now()\n        let remain = endPoint - now\n        let limit = 0 // 忽略负数\n        remain = Math.max(limit, remain)\n\n        return token.replace(/(?:#(\\d+))?([dHmsS])/g, function (all, width, key) {\n            // 如果存在换算单位，则进行单位转换\n            if (UNIT_SIZE[key]) {\n                let r = remain\n                remain %= UNIT_SIZE[key]\n                let str = parseInt(r / UNIT_SIZE[key]).toString()\n                // 如果指定宽度，则进行填充处理\n                if (width && str.length < width) {\n                    str = new Array(width - str.length).fill(0).join('') + str\n                }\n                return str\n            } else {\n                return key\n            }\n        })\n    }\n\n    return { format }\n}\n\nmodule.exports = TimeFormater\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/time-formater/lib/timeformater.js\n// module id = PeNd\n// module chunks = 2","var makeStyleMapper = require(\"../../model/mixin/makeStyleMapper\");\n\nvar getBarItemStyle = makeStyleMapper([['fill', 'color'], ['stroke', 'borderColor'], ['lineWidth', 'borderWidth'], // Compatitable with 2\n['stroke', 'barBorderColor'], ['lineWidth', 'barBorderWidth'], ['opacity'], ['shadowBlur'], ['shadowOffsetX'], ['shadowOffsetY'], ['shadowColor']]);\nvar _default = {\n  getBarItemStyle: function (excludes) {\n    var style = getBarItemStyle(this, excludes);\n\n    if (this.getBorderLineDash) {\n      var lineDash = this.getBorderLineDash();\n      lineDash && (style.lineDash = lineDash);\n    }\n\n    return style;\n  }\n};\nmodule.exports = _default;\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/echarts/lib/chart/bar/barItemStyle.js\n// module id = Pobh\n// module chunks = 1 2","var zrUtil = require(\"zrender/lib/core/util\");\n\nvar Model = require(\"../../model/Model\");\n\nvar each = zrUtil.each;\nvar curry = zrUtil.curry; // Build axisPointerModel, mergin tooltip.axisPointer model for each axis.\n// allAxesInfo should be updated when setOption performed.\n\nfunction collect(ecModel, api) {\n  var result = {\n    /**\n     * key: makeKey(axis.model)\n     * value: {\n     *      axis,\n     *      coordSys,\n     *      axisPointerModel,\n     *      triggerTooltip,\n     *      involveSeries,\n     *      snap,\n     *      seriesModels,\n     *      seriesDataCount\n     * }\n     */\n    axesInfo: {},\n    seriesInvolved: false,\n\n    /**\n     * key: makeKey(coordSys.model)\n     * value: Object: key makeKey(axis.model), value: axisInfo\n     */\n    coordSysAxesInfo: {},\n    coordSysMap: {}\n  };\n  collectAxesInfo(result, ecModel, api); // Check seriesInvolved for performance, in case too many series in some chart.\n\n  result.seriesInvolved && collectSeriesInfo(result, ecModel);\n  return result;\n}\n\nfunction collectAxesInfo(result, ecModel, api) {\n  var globalTooltipModel = ecModel.getComponent('tooltip');\n  var globalAxisPointerModel = ecModel.getComponent('axisPointer'); // links can only be set on global.\n\n  var linksOption = globalAxisPointerModel.get('link', true) || [];\n  var linkGroups = []; // Collect axes info.\n\n  each(api.getCoordinateSystems(), function (coordSys) {\n    // Some coordinate system do not support axes, like geo.\n    if (!coordSys.axisPointerEnabled) {\n      return;\n    }\n\n    var coordSysKey = makeKey(coordSys.model);\n    var axesInfoInCoordSys = result.coordSysAxesInfo[coordSysKey] = {};\n    result.coordSysMap[coordSysKey] = coordSys; // Set tooltip (like 'cross') is a convienent way to show axisPointer\n    // for user. So we enable seting tooltip on coordSys model.\n\n    var coordSysModel = coordSys.model;\n    var baseTooltipModel = coordSysModel.getModel('tooltip', globalTooltipModel);\n    each(coordSys.getAxes(), curry(saveTooltipAxisInfo, false, null)); // If axis tooltip used, choose tooltip axis for each coordSys.\n    // Notice this case: coordSys is `grid` but not `cartesian2D` here.\n\n    if (coordSys.getTooltipAxes && globalTooltipModel // If tooltip.showContent is set as false, tooltip will not\n    // show but axisPointer will show as normal.\n    && baseTooltipModel.get('show')) {\n      // Compatible with previous logic. But series.tooltip.trigger: 'axis'\n      // or series.data[n].tooltip.trigger: 'axis' are not support any more.\n      var triggerAxis = baseTooltipModel.get('trigger') === 'axis';\n      var cross = baseTooltipModel.get('axisPointer.type') === 'cross';\n      var tooltipAxes = coordSys.getTooltipAxes(baseTooltipModel.get('axisPointer.axis'));\n\n      if (triggerAxis || cross) {\n        each(tooltipAxes.baseAxes, curry(saveTooltipAxisInfo, cross ? 'cross' : true, triggerAxis));\n      }\n\n      if (cross) {\n        each(tooltipAxes.otherAxes, curry(saveTooltipAxisInfo, 'cross', false));\n      }\n    } // fromTooltip: true | false | 'cross'\n    // triggerTooltip: true | false | null\n\n\n    function saveTooltipAxisInfo(fromTooltip, triggerTooltip, axis) {\n      var axisPointerModel = axis.model.getModel('axisPointer', globalAxisPointerModel);\n      var axisPointerShow = axisPointerModel.get('show');\n\n      if (!axisPointerShow || axisPointerShow === 'auto' && !fromTooltip && !isHandleTrigger(axisPointerModel)) {\n        return;\n      }\n\n      if (triggerTooltip == null) {\n        triggerTooltip = axisPointerModel.get('triggerTooltip');\n      }\n\n      axisPointerModel = fromTooltip ? makeAxisPointerModel(axis, baseTooltipModel, globalAxisPointerModel, ecModel, fromTooltip, triggerTooltip) : axisPointerModel;\n      var snap = axisPointerModel.get('snap');\n      var key = makeKey(axis.model);\n      var involveSeries = triggerTooltip || snap || axis.type === 'category'; // If result.axesInfo[key] exist, override it (tooltip has higher priority).\n\n      var axisInfo = result.axesInfo[key] = {\n        key: key,\n        axis: axis,\n        coordSys: coordSys,\n        axisPointerModel: axisPointerModel,\n        triggerTooltip: triggerTooltip,\n        involveSeries: involveSeries,\n        snap: snap,\n        useHandle: isHandleTrigger(axisPointerModel),\n        seriesModels: []\n      };\n      axesInfoInCoordSys[key] = axisInfo;\n      result.seriesInvolved |= involveSeries;\n      var groupIndex = getLinkGroupIndex(linksOption, axis);\n\n      if (groupIndex != null) {\n        var linkGroup = linkGroups[groupIndex] || (linkGroups[groupIndex] = {\n          axesInfo: {}\n        });\n        linkGroup.axesInfo[key] = axisInfo;\n        linkGroup.mapper = linksOption[groupIndex].mapper;\n        axisInfo.linkGroup = linkGroup;\n      }\n    }\n  });\n}\n\nfunction makeAxisPointerModel(axis, baseTooltipModel, globalAxisPointerModel, ecModel, fromTooltip, triggerTooltip) {\n  var tooltipAxisPointerModel = baseTooltipModel.getModel('axisPointer');\n  var volatileOption = {};\n  each(['type', 'snap', 'lineStyle', 'shadowStyle', 'label', 'animation', 'animationDurationUpdate', 'animationEasingUpdate', 'z'], function (field) {\n    volatileOption[field] = zrUtil.clone(tooltipAxisPointerModel.get(field));\n  }); // category axis do not auto snap, otherwise some tick that do not\n  // has value can not be hovered. value/time/log axis default snap if\n  // triggered from tooltip and trigger tooltip.\n\n  volatileOption.snap = axis.type !== 'category' && !!triggerTooltip; // Compatibel with previous behavior, tooltip axis do not show label by default.\n  // Only these properties can be overrided from tooltip to axisPointer.\n\n  if (tooltipAxisPointerModel.get('type') === 'cross') {\n    volatileOption.type = 'line';\n  }\n\n  var labelOption = volatileOption.label || (volatileOption.label = {}); // Follow the convention, do not show label when triggered by tooltip by default.\n\n  labelOption.show == null && (labelOption.show = false);\n\n  if (fromTooltip === 'cross') {\n    // When 'cross', both axes show labels.\n    labelOption.show = true; // If triggerTooltip, this is a base axis, which should better not use cross style\n    // (cross style is dashed by default)\n\n    if (!triggerTooltip) {\n      var crossStyle = volatileOption.lineStyle = tooltipAxisPointerModel.get('crossStyle');\n      crossStyle && zrUtil.defaults(labelOption, crossStyle.textStyle);\n    }\n  }\n\n  return axis.model.getModel('axisPointer', new Model(volatileOption, globalAxisPointerModel, ecModel));\n}\n\nfunction collectSeriesInfo(result, ecModel) {\n  // Prepare data for axis trigger\n  ecModel.eachSeries(function (seriesModel) {\n    // Notice this case: this coordSys is `cartesian2D` but not `grid`.\n    var coordSys = seriesModel.coordinateSystem;\n    var seriesTooltipTrigger = seriesModel.get('tooltip.trigger', true);\n    var seriesTooltipShow = seriesModel.get('tooltip.show', true);\n\n    if (!coordSys || seriesTooltipTrigger === 'none' || seriesTooltipTrigger === false || seriesTooltipTrigger === 'item' || seriesTooltipShow === false || seriesModel.get('axisPointer.show', true) === false) {\n      return;\n    }\n\n    each(result.coordSysAxesInfo[makeKey(coordSys.model)], function (axisInfo) {\n      var axis = axisInfo.axis;\n\n      if (coordSys.getAxis(axis.dim) === axis) {\n        axisInfo.seriesModels.push(seriesModel);\n        axisInfo.seriesDataCount == null && (axisInfo.seriesDataCount = 0);\n        axisInfo.seriesDataCount += seriesModel.getData().count();\n      }\n    });\n  }, this);\n}\n/**\n * For example:\n * {\n *     axisPointer: {\n *         links: [{\n *             xAxisIndex: [2, 4],\n *             yAxisIndex: 'all'\n *         }, {\n *             xAxisId: ['a5', 'a7'],\n *             xAxisName: 'xxx'\n *         }]\n *     }\n * }\n */\n\n\nfunction getLinkGroupIndex(linksOption, axis) {\n  var axisModel = axis.model;\n  var dim = axis.dim;\n\n  for (var i = 0; i < linksOption.length; i++) {\n    var linkOption = linksOption[i] || {};\n\n    if (checkPropInLink(linkOption[dim + 'AxisId'], axisModel.id) || checkPropInLink(linkOption[dim + 'AxisIndex'], axisModel.componentIndex) || checkPropInLink(linkOption[dim + 'AxisName'], axisModel.name)) {\n      return i;\n    }\n  }\n}\n\nfunction checkPropInLink(linkPropValue, axisPropValue) {\n  return linkPropValue === 'all' || zrUtil.isArray(linkPropValue) && zrUtil.indexOf(linkPropValue, axisPropValue) >= 0 || linkPropValue === axisPropValue;\n}\n\nfunction fixValue(axisModel) {\n  var axisInfo = getAxisInfo(axisModel);\n\n  if (!axisInfo) {\n    return;\n  }\n\n  var axisPointerModel = axisInfo.axisPointerModel;\n  var scale = axisInfo.axis.scale;\n  var option = axisPointerModel.option;\n  var status = axisPointerModel.get('status');\n  var value = axisPointerModel.get('value'); // Parse init value for category and time axis.\n\n  if (value != null) {\n    value = scale.parse(value);\n  }\n\n  var useHandle = isHandleTrigger(axisPointerModel); // If `handle` used, `axisPointer` will always be displayed, so value\n  // and status should be initialized.\n\n  if (status == null) {\n    option.status = useHandle ? 'show' : 'hide';\n  }\n\n  var extent = scale.getExtent().slice();\n  extent[0] > extent[1] && extent.reverse();\n\n  if ( // Pick a value on axis when initializing.\n  value == null // If both `handle` and `dataZoom` are used, value may be out of axis extent,\n  // where we should re-pick a value to keep `handle` displaying normally.\n  || value > extent[1]) {\n    // Make handle displayed on the end of the axis when init, which looks better.\n    value = extent[1];\n  }\n\n  if (value < extent[0]) {\n    value = extent[0];\n  }\n\n  option.value = value;\n\n  if (useHandle) {\n    option.status = axisInfo.axis.scale.isBlank() ? 'hide' : 'show';\n  }\n}\n\nfunction getAxisInfo(axisModel) {\n  var coordSysAxesInfo = (axisModel.ecModel.getComponent('axisPointer') || {}).coordSysAxesInfo;\n  return coordSysAxesInfo && coordSysAxesInfo.axesInfo[makeKey(axisModel)];\n}\n\nfunction getAxisPointerModel(axisModel) {\n  var axisInfo = getAxisInfo(axisModel);\n  return axisInfo && axisInfo.axisPointerModel;\n}\n\nfunction isHandleTrigger(axisPointerModel) {\n  return !!axisPointerModel.get('handle.show');\n}\n/**\n * @param {module:echarts/model/Model} model\n * @return {string} unique key\n */\n\n\nfunction makeKey(model) {\n  return model.type + '||' + model.id;\n}\n\nexports.collect = collect;\nexports.fixValue = fixValue;\nexports.getAxisInfo = getAxisInfo;\nexports.getAxisPointerModel = getAxisPointerModel;\nexports.makeKey = makeKey;\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/echarts/lib/component/axisPointer/modelHelper.js\n// module id = QCrJ\n// module chunks = 1 2","var zrUtil = require(\"zrender/lib/core/util\");\n\nvar Axis = require(\"../Axis\");\n\n/**\n * Extend axis 2d\n * @constructor module:echarts/coord/cartesian/Axis2D\n * @extends {module:echarts/coord/cartesian/Axis}\n * @param {string} dim\n * @param {*} scale\n * @param {Array.<number>} coordExtent\n * @param {string} axisType\n * @param {string} position\n */\nvar Axis2D = function (dim, scale, coordExtent, axisType, position) {\n  Axis.call(this, dim, scale, coordExtent);\n  /**\n   * Axis type\n   *  - 'category'\n   *  - 'value'\n   *  - 'time'\n   *  - 'log'\n   * @type {string}\n   */\n\n  this.type = axisType || 'value';\n  /**\n   * Axis position\n   *  - 'top'\n   *  - 'bottom'\n   *  - 'left'\n   *  - 'right'\n   */\n\n  this.position = position || 'bottom';\n};\n\nAxis2D.prototype = {\n  constructor: Axis2D,\n\n  /**\n   * Index of axis, can be used as key\n   */\n  index: 0,\n\n  /**\n   * If axis is on the zero position of the other axis\n   * @type {boolean}\n   */\n  onZero: false,\n\n  /**\n   * Axis model\n   * @param {module:echarts/coord/cartesian/AxisModel}\n   */\n  model: null,\n  isHorizontal: function () {\n    var position = this.position;\n    return position === 'top' || position === 'bottom';\n  },\n\n  /**\n   * Each item cooresponds to this.getExtent(), which\n   * means globalExtent[0] may greater than globalExtent[1],\n   * unless `asc` is input.\n   *\n   * @param {boolean} [asc]\n   * @return {Array.<number>}\n   */\n  getGlobalExtent: function (asc) {\n    var ret = this.getExtent();\n    ret[0] = this.toGlobalCoord(ret[0]);\n    ret[1] = this.toGlobalCoord(ret[1]);\n    asc && ret[0] > ret[1] && ret.reverse();\n    return ret;\n  },\n  getOtherAxis: function () {\n    this.grid.getOtherAxis();\n  },\n\n  /**\n   * If label is ignored.\n   * Automatically used when axis is category and label can not be all shown\n   * @param  {number}  idx\n   * @return {boolean}\n   */\n  isLabelIgnored: function (idx) {\n    if (this.type === 'category') {\n      var labelInterval = this.getLabelInterval();\n      return typeof labelInterval === 'function' && !labelInterval(idx, this.scale.getLabel(idx)) || idx % (labelInterval + 1);\n    }\n  },\n\n  /**\n   * @override\n   */\n  pointToData: function (point, clamp) {\n    return this.coordToData(this.toLocalCoord(point[this.dim === 'x' ? 0 : 1]), clamp);\n  },\n\n  /**\n   * Transform global coord to local coord,\n   * i.e. var localCoord = axis.toLocalCoord(80);\n   * designate by module:echarts/coord/cartesian/Grid.\n   * @type {Function}\n   */\n  toLocalCoord: null,\n\n  /**\n   * Transform global coord to local coord,\n   * i.e. var globalCoord = axis.toLocalCoord(40);\n   * designate by module:echarts/coord/cartesian/Grid.\n   * @type {Function}\n   */\n  toGlobalCoord: null\n};\nzrUtil.inherits(Axis2D, Axis);\nvar _default = Axis2D;\nmodule.exports = _default;\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/echarts/lib/coord/cartesian/Axis2D.js\n// module id = RKzr\n// module chunks = 1 2","var echarts = require(\"../../../echarts\");\n\nvar zrUtil = require(\"zrender/lib/core/util\");\n\nvar lang = require(\"../../../lang\");\n\nvar featureManager = require(\"../featureManager\");\n\nvar magicTypeLang = lang.toolbox.magicType;\n\nfunction MagicType(model) {\n  this.model = model;\n}\n\nMagicType.defaultOption = {\n  show: true,\n  type: [],\n  // Icon group\n  icon: {\n    line: 'M4.1,28.9h7.1l9.3-22l7.4,38l9.7-19.7l3,12.8h14.9M4.1,58h51.4',\n    bar: 'M6.7,22.9h10V48h-10V22.9zM24.9,13h10v35h-10V13zM43.2,2h10v46h-10V2zM3.1,58h53.7',\n    stack: 'M8.2,38.4l-8.4,4.1l30.6,15.3L60,42.5l-8.1-4.1l-21.5,11L8.2,38.4z M51.9,30l-8.1,4.2l-13.4,6.9l-13.9-6.9L8.2,30l-8.4,4.2l8.4,4.2l22.2,11l21.5-11l8.1-4.2L51.9,30z M51.9,21.7l-8.1,4.2L35.7,30l-5.3,2.8L24.9,30l-8.4-4.1l-8.3-4.2l-8.4,4.2L8.2,30l8.3,4.2l13.9,6.9l13.4-6.9l8.1-4.2l8.1-4.1L51.9,21.7zM30.4,2.2L-0.2,17.5l8.4,4.1l8.3,4.2l8.4,4.2l5.5,2.7l5.3-2.7l8.1-4.2l8.1-4.2l8.1-4.1L30.4,2.2z',\n    // jshint ignore:line\n    tiled: 'M2.3,2.2h22.8V25H2.3V2.2z M35,2.2h22.8V25H35V2.2zM2.3,35h22.8v22.8H2.3V35z M35,35h22.8v22.8H35V35z'\n  },\n  // `line`, `bar`, `stack`, `tiled`\n  title: zrUtil.clone(magicTypeLang.title),\n  option: {},\n  seriesIndex: {}\n};\nvar proto = MagicType.prototype;\n\nproto.getIcons = function () {\n  var model = this.model;\n  var availableIcons = model.get('icon');\n  var icons = {};\n  zrUtil.each(model.get('type'), function (type) {\n    if (availableIcons[type]) {\n      icons[type] = availableIcons[type];\n    }\n  });\n  return icons;\n};\n\nvar seriesOptGenreator = {\n  'line': function (seriesType, seriesId, seriesModel, model) {\n    if (seriesType === 'bar') {\n      return zrUtil.merge({\n        id: seriesId,\n        type: 'line',\n        // Preserve data related option\n        data: seriesModel.get('data'),\n        stack: seriesModel.get('stack'),\n        markPoint: seriesModel.get('markPoint'),\n        markLine: seriesModel.get('markLine')\n      }, model.get('option.line') || {}, true);\n    }\n  },\n  'bar': function (seriesType, seriesId, seriesModel, model) {\n    if (seriesType === 'line') {\n      return zrUtil.merge({\n        id: seriesId,\n        type: 'bar',\n        // Preserve data related option\n        data: seriesModel.get('data'),\n        stack: seriesModel.get('stack'),\n        markPoint: seriesModel.get('markPoint'),\n        markLine: seriesModel.get('markLine')\n      }, model.get('option.bar') || {}, true);\n    }\n  },\n  'stack': function (seriesType, seriesId, seriesModel, model) {\n    if (seriesType === 'line' || seriesType === 'bar') {\n      return zrUtil.merge({\n        id: seriesId,\n        stack: '__ec_magicType_stack__'\n      }, model.get('option.stack') || {}, true);\n    }\n  },\n  'tiled': function (seriesType, seriesId, seriesModel, model) {\n    if (seriesType === 'line' || seriesType === 'bar') {\n      return zrUtil.merge({\n        id: seriesId,\n        stack: ''\n      }, model.get('option.tiled') || {}, true);\n    }\n  }\n};\nvar radioTypes = [['line', 'bar'], ['stack', 'tiled']];\n\nproto.onclick = function (ecModel, api, type) {\n  var model = this.model;\n  var seriesIndex = model.get('seriesIndex.' + type); // Not supported magicType\n\n  if (!seriesOptGenreator[type]) {\n    return;\n  }\n\n  var newOption = {\n    series: []\n  };\n\n  var generateNewSeriesTypes = function (seriesModel) {\n    var seriesType = seriesModel.subType;\n    var seriesId = seriesModel.id;\n    var newSeriesOpt = seriesOptGenreator[type](seriesType, seriesId, seriesModel, model);\n\n    if (newSeriesOpt) {\n      // PENDING If merge original option?\n      zrUtil.defaults(newSeriesOpt, seriesModel.option);\n      newOption.series.push(newSeriesOpt);\n    } // Modify boundaryGap\n\n\n    var coordSys = seriesModel.coordinateSystem;\n\n    if (coordSys && coordSys.type === 'cartesian2d' && (type === 'line' || type === 'bar')) {\n      var categoryAxis = coordSys.getAxesByScale('ordinal')[0];\n\n      if (categoryAxis) {\n        var axisDim = categoryAxis.dim;\n        var axisType = axisDim + 'Axis';\n        var axisModel = ecModel.queryComponents({\n          mainType: axisType,\n          index: seriesModel.get(name + 'Index'),\n          id: seriesModel.get(name + 'Id')\n        })[0];\n        var axisIndex = axisModel.componentIndex;\n        newOption[axisType] = newOption[axisType] || [];\n\n        for (var i = 0; i <= axisIndex; i++) {\n          newOption[axisType][axisIndex] = newOption[axisType][axisIndex] || {};\n        }\n\n        newOption[axisType][axisIndex].boundaryGap = type === 'bar' ? true : false;\n      }\n    }\n  };\n\n  zrUtil.each(radioTypes, function (radio) {\n    if (zrUtil.indexOf(radio, type) >= 0) {\n      zrUtil.each(radio, function (item) {\n        model.setIconStatus(item, 'normal');\n      });\n    }\n  });\n  model.setIconStatus(type, 'emphasis');\n  ecModel.eachComponent({\n    mainType: 'series',\n    query: seriesIndex == null ? null : {\n      seriesIndex: seriesIndex\n    }\n  }, generateNewSeriesTypes);\n  api.dispatchAction({\n    type: 'changeMagicType',\n    currentType: type,\n    newOption: newOption\n  });\n};\n\necharts.registerAction({\n  type: 'changeMagicType',\n  event: 'magicTypeChanged',\n  update: 'prepareAndUpdate'\n}, function (payload, ecModel) {\n  ecModel.mergeOption(payload.newOption);\n});\nfeatureManager.register('magicType', MagicType);\nvar _default = MagicType;\nmodule.exports = _default;\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/echarts/lib/component/toolbox/feature/MagicType.js\n// module id = RTd5\n// module chunks = 1 2","var _model = require(\"../../util/model\");\n\nvar otherDimToDataDim = _model.otherDimToDataDim;\n\n/**\n * @module echarts/chart/helper/Symbol\n */\nfunction findLabelValueDim(data) {\n  var valueDim;\n  var labelDims = otherDimToDataDim(data, 'label');\n\n  if (labelDims.length) {\n    valueDim = labelDims[0];\n  } else {\n    // Get last value dim\n    var dimensions = data.dimensions.slice();\n    var dataType;\n\n    while (dimensions.length && (valueDim = dimensions.pop(), dataType = data.getDimensionInfo(valueDim).type, dataType === 'ordinal' || dataType === 'time')) {} // jshint ignore:line\n\n  }\n\n  return valueDim;\n}\n\nexports.findLabelValueDim = findLabelValueDim;\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/echarts/lib/chart/helper/labelHelper.js\n// module id = RjA7\n// module chunks = 1 2","var echarts = require(\"../../echarts\");\n\nvar zrUtil = require(\"zrender/lib/core/util\");\n\nvar _default = echarts.extendComponentView({\n  type: 'marker',\n  init: function () {\n    /**\n     * Markline grouped by series\n     * @private\n     * @type {module:zrender/core/util.HashMap}\n     */\n    this.markerGroupMap = zrUtil.createHashMap();\n  },\n  render: function (markerModel, ecModel, api) {\n    var markerGroupMap = this.markerGroupMap;\n    markerGroupMap.each(function (item) {\n      item.__keep = false;\n    });\n    var markerModelKey = this.type + 'Model';\n    ecModel.eachSeries(function (seriesModel) {\n      var markerModel = seriesModel[markerModelKey];\n      markerModel && this.renderSeries(seriesModel, markerModel, ecModel, api);\n    }, this);\n    markerGroupMap.each(function (item) {\n      !item.__keep && this.group.remove(item.group);\n    }, this);\n  },\n  renderSeries: function () {}\n});\n\nmodule.exports = _default;\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/echarts/lib/component/marker/MarkerView.js\n// module id = SZjP\n// module chunks = 1 2","// var arrayDiff = require('zrender/src/core/arrayDiff');\n// 'zrender/src/core/arrayDiff' has been used before, but it did\n// not do well in performance when roam with fixed dataZoom window.\nfunction sign(val) {\n  return val >= 0 ? 1 : -1;\n}\n\nfunction getStackedOnPoint(coordSys, data, idx) {\n  var baseAxis = coordSys.getBaseAxis();\n  var valueAxis = coordSys.getOtherAxis(baseAxis);\n  var valueStart = baseAxis.onZero ? 0 : valueAxis.scale.getExtent()[0];\n  var valueDim = valueAxis.dim;\n  var baseDataOffset = valueDim === 'x' || valueDim === 'radius' ? 1 : 0;\n  var stackedOnSameSign;\n  var stackedOn = data.stackedOn;\n  var val = data.get(valueDim, idx); // Find first stacked value with same sign\n\n  while (stackedOn && sign(stackedOn.get(valueDim, idx)) === sign(val)) {\n    stackedOnSameSign = stackedOn;\n    break;\n  }\n\n  var stackedData = [];\n  stackedData[baseDataOffset] = data.get(baseAxis.dim, idx);\n  stackedData[1 - baseDataOffset] = stackedOnSameSign ? stackedOnSameSign.get(valueDim, idx, true) : valueStart;\n  return coordSys.dataToPoint(stackedData);\n} // function convertToIntId(newIdList, oldIdList) {\n//     // Generate int id instead of string id.\n//     // Compare string maybe slow in score function of arrDiff\n//     // Assume id in idList are all unique\n//     var idIndicesMap = {};\n//     var idx = 0;\n//     for (var i = 0; i < newIdList.length; i++) {\n//         idIndicesMap[newIdList[i]] = idx;\n//         newIdList[i] = idx++;\n//     }\n//     for (var i = 0; i < oldIdList.length; i++) {\n//         var oldId = oldIdList[i];\n//         // Same with newIdList\n//         if (idIndicesMap[oldId]) {\n//             oldIdList[i] = idIndicesMap[oldId];\n//         }\n//         else {\n//             oldIdList[i] = idx++;\n//         }\n//     }\n// }\n\n\nfunction diffData(oldData, newData) {\n  var diffResult = [];\n  newData.diff(oldData).add(function (idx) {\n    diffResult.push({\n      cmd: '+',\n      idx: idx\n    });\n  }).update(function (newIdx, oldIdx) {\n    diffResult.push({\n      cmd: '=',\n      idx: oldIdx,\n      idx1: newIdx\n    });\n  }).remove(function (idx) {\n    diffResult.push({\n      cmd: '-',\n      idx: idx\n    });\n  }).execute();\n  return diffResult;\n}\n\nfunction _default(oldData, newData, oldStackedOnPoints, newStackedOnPoints, oldCoordSys, newCoordSys) {\n  var diff = diffData(oldData, newData); // var newIdList = newData.mapArray(newData.getId);\n  // var oldIdList = oldData.mapArray(oldData.getId);\n  // convertToIntId(newIdList, oldIdList);\n  // // FIXME One data ?\n  // diff = arrayDiff(oldIdList, newIdList);\n\n  var currPoints = [];\n  var nextPoints = []; // Points for stacking base line\n\n  var currStackedPoints = [];\n  var nextStackedPoints = [];\n  var status = [];\n  var sortedIndices = [];\n  var rawIndices = [];\n  var dims = newCoordSys.dimensions;\n\n  for (var i = 0; i < diff.length; i++) {\n    var diffItem = diff[i];\n    var pointAdded = true; // FIXME, animation is not so perfect when dataZoom window moves fast\n    // Which is in case remvoing or add more than one data in the tail or head\n\n    switch (diffItem.cmd) {\n      case '=':\n        var currentPt = oldData.getItemLayout(diffItem.idx);\n        var nextPt = newData.getItemLayout(diffItem.idx1); // If previous data is NaN, use next point directly\n\n        if (isNaN(currentPt[0]) || isNaN(currentPt[1])) {\n          currentPt = nextPt.slice();\n        }\n\n        currPoints.push(currentPt);\n        nextPoints.push(nextPt);\n        currStackedPoints.push(oldStackedOnPoints[diffItem.idx]);\n        nextStackedPoints.push(newStackedOnPoints[diffItem.idx1]);\n        rawIndices.push(newData.getRawIndex(diffItem.idx1));\n        break;\n\n      case '+':\n        var idx = diffItem.idx;\n        currPoints.push(oldCoordSys.dataToPoint([newData.get(dims[0], idx, true), newData.get(dims[1], idx, true)]));\n        nextPoints.push(newData.getItemLayout(idx).slice());\n        currStackedPoints.push(getStackedOnPoint(oldCoordSys, newData, idx));\n        nextStackedPoints.push(newStackedOnPoints[idx]);\n        rawIndices.push(newData.getRawIndex(idx));\n        break;\n\n      case '-':\n        var idx = diffItem.idx;\n        var rawIndex = oldData.getRawIndex(idx); // Data is replaced. In the case of dynamic data queue\n        // FIXME FIXME FIXME\n\n        if (rawIndex !== idx) {\n          currPoints.push(oldData.getItemLayout(idx));\n          nextPoints.push(newCoordSys.dataToPoint([oldData.get(dims[0], idx, true), oldData.get(dims[1], idx, true)]));\n          currStackedPoints.push(oldStackedOnPoints[idx]);\n          nextStackedPoints.push(getStackedOnPoint(newCoordSys, oldData, idx));\n          rawIndices.push(rawIndex);\n        } else {\n          pointAdded = false;\n        }\n\n    } // Original indices\n\n\n    if (pointAdded) {\n      status.push(diffItem);\n      sortedIndices.push(sortedIndices.length);\n    }\n  } // Diff result may be crossed if all items are changed\n  // Sort by data index\n\n\n  sortedIndices.sort(function (a, b) {\n    return rawIndices[a] - rawIndices[b];\n  });\n  var sortedCurrPoints = [];\n  var sortedNextPoints = [];\n  var sortedCurrStackedPoints = [];\n  var sortedNextStackedPoints = [];\n  var sortedStatus = [];\n\n  for (var i = 0; i < sortedIndices.length; i++) {\n    var idx = sortedIndices[i];\n    sortedCurrPoints[i] = currPoints[idx];\n    sortedNextPoints[i] = nextPoints[idx];\n    sortedCurrStackedPoints[i] = currStackedPoints[idx];\n    sortedNextStackedPoints[i] = nextStackedPoints[idx];\n    sortedStatus[i] = status[idx];\n  }\n\n  return {\n    current: sortedCurrPoints,\n    next: sortedNextPoints,\n    stackedOnCurrent: sortedCurrStackedPoints,\n    stackedOnNext: sortedNextStackedPoints,\n    status: sortedStatus\n  };\n}\n\nmodule.exports = _default;\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/echarts/lib/chart/line/lineAnimationDiff.js\n// module id = SlE6\n// module chunks = 1 2","var echarts = require(\"../../echarts\");\n\nvar AxisPointerModel = echarts.extendComponentModel({\n  type: 'axisPointer',\n  coordSysAxesInfo: null,\n  defaultOption: {\n    // 'auto' means that show when triggered by tooltip or handle.\n    show: 'auto',\n    // 'click' | 'mousemove' | 'none'\n    triggerOn: null,\n    // set default in AxisPonterView.js\n    zlevel: 0,\n    z: 50,\n    type: 'line',\n    // axispointer triggered by tootip determine snap automatically,\n    // see `modelHelper`.\n    snap: false,\n    triggerTooltip: true,\n    value: null,\n    status: null,\n    // Init value depends on whether handle is used.\n    // [group0, group1, ...]\n    // Each group can be: {\n    //      mapper: function () {},\n    //      singleTooltip: 'multiple',  // 'multiple' or 'single'\n    //      xAxisId: ...,\n    //      yAxisName: ...,\n    //      angleAxisIndex: ...\n    // }\n    // mapper: can be ignored.\n    //      input: {axisInfo, value}\n    //      output: {axisInfo, value}\n    link: [],\n    // Do not set 'auto' here, otherwise global animation: false\n    // will not effect at this axispointer.\n    animation: null,\n    animationDurationUpdate: 200,\n    lineStyle: {\n      color: '#aaa',\n      width: 1,\n      type: 'solid'\n    },\n    shadowStyle: {\n      color: 'rgba(150,150,150,0.3)'\n    },\n    label: {\n      show: true,\n      formatter: null,\n      // string | Function\n      precision: 'auto',\n      // Or a number like 0, 1, 2 ...\n      margin: 3,\n      color: '#fff',\n      padding: [5, 7, 5, 7],\n      backgroundColor: 'auto',\n      // default: axis line color\n      borderColor: null,\n      borderWidth: 0,\n      shadowBlur: 3,\n      shadowColor: '#aaa' // Considering applicability, common style should\n      // better not have shadowOffset.\n      // shadowOffsetX: 0,\n      // shadowOffsetY: 2\n\n    },\n    handle: {\n      show: false,\n      icon: 'M10.7,11.9v-1.3H9.3v1.3c-4.9,0.3-8.8,4.4-8.8,9.4c0,5,3.9,9.1,8.8,9.4h1.3c4.9-0.3,8.8-4.4,8.8-9.4C19.5,16.3,15.6,12.2,10.7,11.9z M13.3,24.4H6.7v-1.2h6.6z M13.3,22H6.7v-1.2h6.6z M13.3,19.6H6.7v-1.2h6.6z',\n      // jshint ignore:line\n      size: 45,\n      // handle margin is from symbol center to axis, which is stable when circular move.\n      margin: 50,\n      // color: '#1b8bbd'\n      // color: '#2f4554'\n      color: '#333',\n      shadowBlur: 3,\n      shadowColor: '#aaa',\n      shadowOffsetX: 0,\n      shadowOffsetY: 2,\n      // For mobile performance\n      throttle: 40\n    }\n  }\n});\nvar _default = AxisPointerModel;\nmodule.exports = _default;\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/echarts/lib/component/axisPointer/AxisPointerModel.js\n// module id = TCXJ\n// module chunks = 1 2","var echarts = require(\"../echarts\");\n\nvar zrUtil = require(\"zrender/lib/core/util\");\n\nvar graphic = require(\"../util/graphic\");\n\nrequire(\"../coord/cartesian/Grid\");\n\nrequire(\"./axis\");\n\n// Grid view\necharts.extendComponentView({\n  type: 'grid',\n  render: function (gridModel, ecModel) {\n    this.group.removeAll();\n\n    if (gridModel.get('show')) {\n      this.group.add(new graphic.Rect({\n        shape: gridModel.coordinateSystem.getRect(),\n        style: zrUtil.defaults({\n          fill: gridModel.get('backgroundColor')\n        }, gridModel.getItemStyle()),\n        silent: true,\n        z2: -1\n      }));\n    }\n  }\n});\necharts.registerPreprocessor(function (option) {\n  // Only create grid when need\n  if (option.xAxis && option.yAxis && !option.grid) {\n    option.grid = {};\n  }\n});\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/echarts/lib/component/gridSimple.js\n// module id = UkNE\n// module chunks = 1 2","var DataZoomView = require(\"./DataZoomView\");\n\nvar _default = DataZoomView.extend({\n  type: 'dataZoom.select'\n});\n\nmodule.exports = _default;\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/echarts/lib/component/dataZoom/SelectZoomView.js\n// module id = WO3U\n// module chunks = 1 2","var echarts = require(\"../../echarts\");\n\nvar zrUtil = require(\"zrender/lib/core/util\");\n\nvar env = require(\"zrender/lib/core/env\");\n\nvar TooltipContent = require(\"./TooltipContent\");\n\nvar formatUtil = require(\"../../util/format\");\n\nvar numberUtil = require(\"../../util/number\");\n\nvar graphic = require(\"../../util/graphic\");\n\nvar findPointFromSeries = require(\"../axisPointer/findPointFromSeries\");\n\nvar layoutUtil = require(\"../../util/layout\");\n\nvar Model = require(\"../../model/Model\");\n\nvar globalListener = require(\"../axisPointer/globalListener\");\n\nvar axisHelper = require(\"../../coord/axisHelper\");\n\nvar axisPointerViewHelper = require(\"../axisPointer/viewHelper\");\n\nvar bind = zrUtil.bind;\nvar each = zrUtil.each;\nvar parsePercent = numberUtil.parsePercent;\nvar proxyRect = new graphic.Rect({\n  shape: {\n    x: -1,\n    y: -1,\n    width: 2,\n    height: 2\n  }\n});\n\nvar _default = echarts.extendComponentView({\n  type: 'tooltip',\n  init: function (ecModel, api) {\n    if (env.node) {\n      return;\n    }\n\n    var tooltipContent = new TooltipContent(api.getDom(), api);\n    this._tooltipContent = tooltipContent;\n  },\n  render: function (tooltipModel, ecModel, api) {\n    if (env.node) {\n      return;\n    } // Reset\n\n\n    this.group.removeAll();\n    /**\n     * @private\n     * @type {module:echarts/component/tooltip/TooltipModel}\n     */\n\n    this._tooltipModel = tooltipModel;\n    /**\n     * @private\n     * @type {module:echarts/model/Global}\n     */\n\n    this._ecModel = ecModel;\n    /**\n     * @private\n     * @type {module:echarts/ExtensionAPI}\n     */\n\n    this._api = api;\n    /**\n     * Should be cleaned when render.\n     * @private\n     * @type {Array.<Array.<Object>>}\n     */\n\n    this._lastDataByCoordSys = null;\n    /**\n     * @private\n     * @type {boolean}\n     */\n\n    this._alwaysShowContent = tooltipModel.get('alwaysShowContent');\n    var tooltipContent = this._tooltipContent;\n    tooltipContent.update();\n    tooltipContent.setEnterable(tooltipModel.get('enterable'));\n\n    this._initGlobalListener();\n\n    this._keepShow();\n  },\n  _initGlobalListener: function () {\n    var tooltipModel = this._tooltipModel;\n    var triggerOn = tooltipModel.get('triggerOn');\n    globalListener.register('itemTooltip', this._api, bind(function (currTrigger, e, dispatchAction) {\n      // If 'none', it is not controlled by mouse totally.\n      if (triggerOn !== 'none') {\n        if (triggerOn.indexOf(currTrigger) >= 0) {\n          this._tryShow(e, dispatchAction);\n        } else if (currTrigger === 'leave') {\n          this._hide(dispatchAction);\n        }\n      }\n    }, this));\n  },\n  _keepShow: function () {\n    var tooltipModel = this._tooltipModel;\n    var ecModel = this._ecModel;\n    var api = this._api; // Try to keep the tooltip show when refreshing\n\n    if (this._lastX != null && this._lastY != null // When user is willing to control tooltip totally using API,\n    // self.manuallyShowTip({x, y}) might cause tooltip hide,\n    // which is not expected.\n    && tooltipModel.get('triggerOn') !== 'none') {\n      var self = this;\n      clearTimeout(this._refreshUpdateTimeout);\n      this._refreshUpdateTimeout = setTimeout(function () {\n        // Show tip next tick after other charts are rendered\n        // In case highlight action has wrong result\n        // FIXME\n        self.manuallyShowTip(tooltipModel, ecModel, api, {\n          x: self._lastX,\n          y: self._lastY\n        });\n      });\n    }\n  },\n\n  /**\n   * Show tip manually by\n   * dispatchAction({\n   *     type: 'showTip',\n   *     x: 10,\n   *     y: 10\n   * });\n   * Or\n   * dispatchAction({\n   *      type: 'showTip',\n   *      seriesIndex: 0,\n   *      dataIndex or dataIndexInside or name\n   * });\n   *\n   *  TODO Batch\n   */\n  manuallyShowTip: function (tooltipModel, ecModel, api, payload) {\n    if (payload.from === this.uid || env.node) {\n      return;\n    }\n\n    var dispatchAction = makeDispatchAction(payload, api); // Reset ticket\n\n    this._ticket = ''; // When triggered from axisPointer.\n\n    var dataByCoordSys = payload.dataByCoordSys;\n\n    if (payload.tooltip && payload.x != null && payload.y != null) {\n      var el = proxyRect;\n      el.position = [payload.x, payload.y];\n      el.update();\n      el.tooltip = payload.tooltip; // Manually show tooltip while view is not using zrender elements.\n\n      this._tryShow({\n        offsetX: payload.x,\n        offsetY: payload.y,\n        target: el\n      }, dispatchAction);\n    } else if (dataByCoordSys) {\n      this._tryShow({\n        offsetX: payload.x,\n        offsetY: payload.y,\n        position: payload.position,\n        event: {},\n        dataByCoordSys: payload.dataByCoordSys,\n        tooltipOption: payload.tooltipOption\n      }, dispatchAction);\n    } else if (payload.seriesIndex != null) {\n      if (this._manuallyAxisShowTip(tooltipModel, ecModel, api, payload)) {\n        return;\n      }\n\n      var pointInfo = findPointFromSeries(payload, ecModel);\n      var cx = pointInfo.point[0];\n      var cy = pointInfo.point[1];\n\n      if (cx != null && cy != null) {\n        this._tryShow({\n          offsetX: cx,\n          offsetY: cy,\n          position: payload.position,\n          target: pointInfo.el,\n          event: {}\n        }, dispatchAction);\n      }\n    } else if (payload.x != null && payload.y != null) {\n      // FIXME\n      // should wrap dispatchAction like `axisPointer/globalListener` ?\n      api.dispatchAction({\n        type: 'updateAxisPointer',\n        x: payload.x,\n        y: payload.y\n      });\n\n      this._tryShow({\n        offsetX: payload.x,\n        offsetY: payload.y,\n        position: payload.position,\n        target: api.getZr().findHover(payload.x, payload.y).target,\n        event: {}\n      }, dispatchAction);\n    }\n  },\n  manuallyHideTip: function (tooltipModel, ecModel, api, payload) {\n    var tooltipContent = this._tooltipContent;\n\n    if (!this._alwaysShowContent) {\n      tooltipContent.hideLater(this._tooltipModel.get('hideDelay'));\n    }\n\n    this._lastX = this._lastY = null;\n\n    if (payload.from !== this.uid) {\n      this._hide(makeDispatchAction(payload, api));\n    }\n  },\n  // Be compatible with previous design, that is, when tooltip.type is 'axis' and\n  // dispatchAction 'showTip' with seriesIndex and dataIndex will trigger axis pointer\n  // and tooltip.\n  _manuallyAxisShowTip: function (tooltipModel, ecModel, api, payload) {\n    var seriesIndex = payload.seriesIndex;\n    var dataIndex = payload.dataIndex;\n    var coordSysAxesInfo = ecModel.getComponent('axisPointer').coordSysAxesInfo;\n\n    if (seriesIndex == null || dataIndex == null || coordSysAxesInfo == null) {\n      return;\n    }\n\n    var seriesModel = ecModel.getSeriesByIndex(seriesIndex);\n\n    if (!seriesModel) {\n      return;\n    }\n\n    var data = seriesModel.getData();\n    var tooltipModel = buildTooltipModel([data.getItemModel(dataIndex), seriesModel, (seriesModel.coordinateSystem || {}).model, tooltipModel]);\n\n    if (tooltipModel.get('trigger') !== 'axis') {\n      return;\n    }\n\n    api.dispatchAction({\n      type: 'updateAxisPointer',\n      seriesIndex: seriesIndex,\n      dataIndex: dataIndex,\n      position: payload.position\n    });\n    return true;\n  },\n  _tryShow: function (e, dispatchAction) {\n    var el = e.target;\n    var tooltipModel = this._tooltipModel;\n\n    if (!tooltipModel) {\n      return;\n    } // Save mouse x, mouse y. So we can try to keep showing the tip if chart is refreshed\n\n\n    this._lastX = e.offsetX;\n    this._lastY = e.offsetY;\n    var dataByCoordSys = e.dataByCoordSys;\n\n    if (dataByCoordSys && dataByCoordSys.length) {\n      this._showAxisTooltip(dataByCoordSys, e);\n    } // Always show item tooltip if mouse is on the element with dataIndex\n    else if (el && el.dataIndex != null) {\n        this._lastDataByCoordSys = null;\n\n        this._showSeriesItemTooltip(e, el, dispatchAction);\n      } // Tooltip provided directly. Like legend.\n      else if (el && el.tooltip) {\n          this._lastDataByCoordSys = null;\n\n          this._showComponentItemTooltip(e, el, dispatchAction);\n        } else {\n          this._lastDataByCoordSys = null;\n\n          this._hide(dispatchAction);\n        }\n  },\n  _showOrMove: function (tooltipModel, cb) {\n    // showDelay is used in this case: tooltip.enterable is set\n    // as true. User intent to move mouse into tooltip and click\n    // something. `showDelay` makes it easyer to enter the content\n    // but tooltip do not move immediately.\n    var delay = tooltipModel.get('showDelay');\n    cb = zrUtil.bind(cb, this);\n    clearTimeout(this._showTimout);\n    delay > 0 ? this._showTimout = setTimeout(cb, delay) : cb();\n  },\n  _showAxisTooltip: function (dataByCoordSys, e) {\n    var ecModel = this._ecModel;\n    var globalTooltipModel = this._tooltipModel;\n    var point = [e.offsetX, e.offsetY];\n    var singleDefaultHTML = [];\n    var singleParamsList = [];\n    var singleTooltipModel = buildTooltipModel([e.tooltipOption, globalTooltipModel]);\n    each(dataByCoordSys, function (itemCoordSys) {\n      // var coordParamList = [];\n      // var coordDefaultHTML = [];\n      // var coordTooltipModel = buildTooltipModel([\n      //     e.tooltipOption,\n      //     itemCoordSys.tooltipOption,\n      //     ecModel.getComponent(itemCoordSys.coordSysMainType, itemCoordSys.coordSysIndex),\n      //     globalTooltipModel\n      // ]);\n      // var displayMode = coordTooltipModel.get('displayMode');\n      // var paramsList = displayMode === 'single' ? singleParamsList : [];\n      each(itemCoordSys.dataByAxis, function (item) {\n        var axisModel = ecModel.getComponent(item.axisDim + 'Axis', item.axisIndex);\n        var axisValue = item.value;\n        var seriesDefaultHTML = [];\n\n        if (!axisModel || axisValue == null) {\n          return;\n        }\n\n        var valueLabel = axisPointerViewHelper.getValueLabel(axisValue, axisModel.axis, ecModel, item.seriesDataIndices, item.valueLabelOpt);\n        zrUtil.each(item.seriesDataIndices, function (idxItem) {\n          var series = ecModel.getSeriesByIndex(idxItem.seriesIndex);\n          var dataIndex = idxItem.dataIndexInside;\n          var dataParams = series && series.getDataParams(dataIndex);\n          dataParams.axisDim = item.axisDim;\n          dataParams.axisIndex = item.axisIndex;\n          dataParams.axisType = item.axisType;\n          dataParams.axisId = item.axisId;\n          dataParams.axisValue = axisHelper.getAxisRawValue(axisModel.axis, axisValue);\n          dataParams.axisValueLabel = valueLabel;\n\n          if (dataParams) {\n            singleParamsList.push(dataParams);\n            seriesDefaultHTML.push(series.formatTooltip(dataIndex, true));\n          }\n        }); // Default tooltip content\n        // FIXME\n        // (1) shold be the first data which has name?\n        // (2) themeRiver, firstDataIndex is array, and first line is unnecessary.\n\n        var firstLine = valueLabel;\n        singleDefaultHTML.push((firstLine ? formatUtil.encodeHTML(firstLine) + '<br />' : '') + seriesDefaultHTML.join('<br />'));\n      });\n    }, this); // In most case, the second axis is shown upper than the first one.\n\n    singleDefaultHTML.reverse();\n    singleDefaultHTML = singleDefaultHTML.join('<br /><br />');\n    var positionExpr = e.position;\n\n    this._showOrMove(singleTooltipModel, function () {\n      if (this._updateContentNotChangedOnAxis(dataByCoordSys)) {\n        this._updatePosition(singleTooltipModel, positionExpr, point[0], point[1], this._tooltipContent, singleParamsList);\n      } else {\n        this._showTooltipContent(singleTooltipModel, singleDefaultHTML, singleParamsList, Math.random(), point[0], point[1], positionExpr);\n      }\n    }); // Do not trigger events here, because this branch only be entered\n    // from dispatchAction.\n\n  },\n  _showSeriesItemTooltip: function (e, el, dispatchAction) {\n    var ecModel = this._ecModel; // Use dataModel in element if possible\n    // Used when mouseover on a element like markPoint or edge\n    // In which case, the data is not main data in series.\n\n    var seriesIndex = el.seriesIndex;\n    var seriesModel = ecModel.getSeriesByIndex(seriesIndex); // For example, graph link.\n\n    var dataModel = el.dataModel || seriesModel;\n    var dataIndex = el.dataIndex;\n    var dataType = el.dataType;\n    var data = dataModel.getData();\n    var tooltipModel = buildTooltipModel([data.getItemModel(dataIndex), dataModel, seriesModel && (seriesModel.coordinateSystem || {}).model, this._tooltipModel]);\n    var tooltipTrigger = tooltipModel.get('trigger');\n\n    if (tooltipTrigger != null && tooltipTrigger !== 'item') {\n      return;\n    }\n\n    var params = dataModel.getDataParams(dataIndex, dataType);\n    var defaultHtml = dataModel.formatTooltip(dataIndex, false, dataType);\n    var asyncTicket = 'item_' + dataModel.name + '_' + dataIndex;\n\n    this._showOrMove(tooltipModel, function () {\n      this._showTooltipContent(tooltipModel, defaultHtml, params, asyncTicket, e.offsetX, e.offsetY, e.position, e.target);\n    }); // FIXME\n    // duplicated showtip if manuallyShowTip is called from dispatchAction.\n\n\n    dispatchAction({\n      type: 'showTip',\n      dataIndexInside: dataIndex,\n      dataIndex: data.getRawIndex(dataIndex),\n      seriesIndex: seriesIndex,\n      from: this.uid\n    });\n  },\n  _showComponentItemTooltip: function (e, el, dispatchAction) {\n    var tooltipOpt = el.tooltip;\n\n    if (typeof tooltipOpt === 'string') {\n      var content = tooltipOpt;\n      tooltipOpt = {\n        content: content,\n        // Fixed formatter\n        formatter: content\n      };\n    }\n\n    var subTooltipModel = new Model(tooltipOpt, this._tooltipModel, this._ecModel);\n    var defaultHtml = subTooltipModel.get('content');\n    var asyncTicket = Math.random(); // Do not check whether `trigger` is 'none' here, because `trigger`\n    // only works on cooridinate system. In fact, we have not found case\n    // that requires setting `trigger` nothing on component yet.\n\n    this._showOrMove(subTooltipModel, function () {\n      this._showTooltipContent(subTooltipModel, defaultHtml, subTooltipModel.get('formatterParams') || {}, asyncTicket, e.offsetX, e.offsetY, e.position, el);\n    }); // If not dispatch showTip, tip may be hide triggered by axis.\n\n\n    dispatchAction({\n      type: 'showTip',\n      from: this.uid\n    });\n  },\n  _showTooltipContent: function (tooltipModel, defaultHtml, params, asyncTicket, x, y, positionExpr, el) {\n    // Reset ticket\n    this._ticket = '';\n\n    if (!tooltipModel.get('showContent') || !tooltipModel.get('show')) {\n      return;\n    }\n\n    var tooltipContent = this._tooltipContent;\n    var formatter = tooltipModel.get('formatter');\n    positionExpr = positionExpr || tooltipModel.get('position');\n    var html = defaultHtml;\n\n    if (formatter && typeof formatter === 'string') {\n      html = formatUtil.formatTpl(formatter, params, true);\n    } else if (typeof formatter === 'function') {\n      var callback = bind(function (cbTicket, html) {\n        if (cbTicket === this._ticket) {\n          tooltipContent.setContent(html);\n\n          this._updatePosition(tooltipModel, positionExpr, x, y, tooltipContent, params, el);\n        }\n      }, this);\n      this._ticket = asyncTicket;\n      html = formatter(params, asyncTicket, callback);\n    }\n\n    tooltipContent.setContent(html);\n    tooltipContent.show(tooltipModel);\n\n    this._updatePosition(tooltipModel, positionExpr, x, y, tooltipContent, params, el);\n  },\n\n  /**\n   * @param  {string|Function|Array.<number>|Object} positionExpr\n   * @param  {number} x Mouse x\n   * @param  {number} y Mouse y\n   * @param  {boolean} confine Whether confine tooltip content in view rect.\n   * @param  {Object|<Array.<Object>} params\n   * @param  {module:zrender/Element} el target element\n   * @param  {module:echarts/ExtensionAPI} api\n   * @return {Array.<number>}\n   */\n  _updatePosition: function (tooltipModel, positionExpr, x, y, content, params, el) {\n    var viewWidth = this._api.getWidth();\n\n    var viewHeight = this._api.getHeight();\n\n    positionExpr = positionExpr || tooltipModel.get('position');\n    var contentSize = content.getSize();\n    var align = tooltipModel.get('align');\n    var vAlign = tooltipModel.get('verticalAlign');\n    var rect = el && el.getBoundingRect().clone();\n    el && rect.applyTransform(el.transform);\n\n    if (typeof positionExpr === 'function') {\n      // Callback of position can be an array or a string specify the position\n      positionExpr = positionExpr([x, y], params, content.el, rect, {\n        viewSize: [viewWidth, viewHeight],\n        contentSize: contentSize.slice()\n      });\n    }\n\n    if (zrUtil.isArray(positionExpr)) {\n      x = parsePercent(positionExpr[0], viewWidth);\n      y = parsePercent(positionExpr[1], viewHeight);\n    } else if (zrUtil.isObject(positionExpr)) {\n      positionExpr.width = contentSize[0];\n      positionExpr.height = contentSize[1];\n      var layoutRect = layoutUtil.getLayoutRect(positionExpr, {\n        width: viewWidth,\n        height: viewHeight\n      });\n      x = layoutRect.x;\n      y = layoutRect.y;\n      align = null; // When positionExpr is left/top/right/bottom,\n      // align and verticalAlign will not work.\n\n      vAlign = null;\n    } // Specify tooltip position by string 'top' 'bottom' 'left' 'right' around graphic element\n    else if (typeof positionExpr === 'string' && el) {\n        var pos = calcTooltipPosition(positionExpr, rect, contentSize);\n        x = pos[0];\n        y = pos[1];\n      } else {\n        var pos = refixTooltipPosition(x, y, content.el, viewWidth, viewHeight, align ? null : 20, vAlign ? null : 20);\n        x = pos[0];\n        y = pos[1];\n      }\n\n    align && (x -= isCenterAlign(align) ? contentSize[0] / 2 : align === 'right' ? contentSize[0] : 0);\n    vAlign && (y -= isCenterAlign(vAlign) ? contentSize[1] / 2 : vAlign === 'bottom' ? contentSize[1] : 0);\n\n    if (tooltipModel.get('confine')) {\n      var pos = confineTooltipPosition(x, y, content.el, viewWidth, viewHeight);\n      x = pos[0];\n      y = pos[1];\n    }\n\n    content.moveTo(x, y);\n  },\n  // FIXME\n  // Should we remove this but leave this to user?\n  _updateContentNotChangedOnAxis: function (dataByCoordSys) {\n    var lastCoordSys = this._lastDataByCoordSys;\n    var contentNotChanged = !!lastCoordSys && lastCoordSys.length === dataByCoordSys.length;\n    contentNotChanged && each(lastCoordSys, function (lastItemCoordSys, indexCoordSys) {\n      var lastDataByAxis = lastItemCoordSys.dataByAxis || {};\n      var thisItemCoordSys = dataByCoordSys[indexCoordSys] || {};\n      var thisDataByAxis = thisItemCoordSys.dataByAxis || [];\n      contentNotChanged &= lastDataByAxis.length === thisDataByAxis.length;\n      contentNotChanged && each(lastDataByAxis, function (lastItem, indexAxis) {\n        var thisItem = thisDataByAxis[indexAxis] || {};\n        var lastIndices = lastItem.seriesDataIndices || [];\n        var newIndices = thisItem.seriesDataIndices || [];\n        contentNotChanged &= lastItem.value === thisItem.value && lastItem.axisType === thisItem.axisType && lastItem.axisId === thisItem.axisId && lastIndices.length === newIndices.length;\n        contentNotChanged && each(lastIndices, function (lastIdxItem, j) {\n          var newIdxItem = newIndices[j];\n          contentNotChanged &= lastIdxItem.seriesIndex === newIdxItem.seriesIndex && lastIdxItem.dataIndex === newIdxItem.dataIndex;\n        });\n      });\n    });\n    this._lastDataByCoordSys = dataByCoordSys;\n    return !!contentNotChanged;\n  },\n  _hide: function (dispatchAction) {\n    // Do not directly hideLater here, because this behavior may be prevented\n    // in dispatchAction when showTip is dispatched.\n    // FIXME\n    // duplicated hideTip if manuallyHideTip is called from dispatchAction.\n    this._lastDataByCoordSys = null;\n    dispatchAction({\n      type: 'hideTip',\n      from: this.uid\n    });\n  },\n  dispose: function (ecModel, api) {\n    if (env.node) {\n      return;\n    }\n\n    this._tooltipContent.hide();\n\n    globalListener.unregister('itemTooltip', api);\n  }\n});\n/**\n * @param {Array.<Object|module:echarts/model/Model>} modelCascade\n * From top to bottom. (the last one should be globalTooltipModel);\n */\n\n\nfunction buildTooltipModel(modelCascade) {\n  var resultModel = modelCascade.pop();\n\n  while (modelCascade.length) {\n    var tooltipOpt = modelCascade.pop();\n\n    if (tooltipOpt) {\n      if (tooltipOpt instanceof Model) {\n        tooltipOpt = tooltipOpt.get('tooltip', true);\n      } // In each data item tooltip can be simply write:\n      // {\n      //  value: 10,\n      //  tooltip: 'Something you need to know'\n      // }\n\n\n      if (typeof tooltipOpt === 'string') {\n        tooltipOpt = {\n          formatter: tooltipOpt\n        };\n      }\n\n      resultModel = new Model(tooltipOpt, resultModel, resultModel.ecModel);\n    }\n  }\n\n  return resultModel;\n}\n\nfunction makeDispatchAction(payload, api) {\n  return payload.dispatchAction || zrUtil.bind(api.dispatchAction, api);\n}\n\nfunction refixTooltipPosition(x, y, el, viewWidth, viewHeight, gapH, gapV) {\n  var size = getOuterSize(el);\n  var width = size.width;\n  var height = size.height;\n\n  if (gapH != null) {\n    if (x + width + gapH > viewWidth) {\n      x -= width + gapH;\n    } else {\n      x += gapH;\n    }\n  }\n\n  if (gapV != null) {\n    if (y + height + gapV > viewHeight) {\n      y -= height + gapV;\n    } else {\n      y += gapV;\n    }\n  }\n\n  return [x, y];\n}\n\nfunction confineTooltipPosition(x, y, el, viewWidth, viewHeight) {\n  var size = getOuterSize(el);\n  var width = size.width;\n  var height = size.height;\n  x = Math.min(x + width, viewWidth) - width;\n  y = Math.min(y + height, viewHeight) - height;\n  x = Math.max(x, 0);\n  y = Math.max(y, 0);\n  return [x, y];\n}\n\nfunction getOuterSize(el) {\n  var width = el.clientWidth;\n  var height = el.clientHeight; // Consider browser compatibility.\n  // IE8 does not support getComputedStyle.\n\n  if (document.defaultView && document.defaultView.getComputedStyle) {\n    var stl = document.defaultView.getComputedStyle(el);\n\n    if (stl) {\n      width += parseInt(stl.paddingLeft, 10) + parseInt(stl.paddingRight, 10) + parseInt(stl.borderLeftWidth, 10) + parseInt(stl.borderRightWidth, 10);\n      height += parseInt(stl.paddingTop, 10) + parseInt(stl.paddingBottom, 10) + parseInt(stl.borderTopWidth, 10) + parseInt(stl.borderBottomWidth, 10);\n    }\n  }\n\n  return {\n    width: width,\n    height: height\n  };\n}\n\nfunction calcTooltipPosition(position, rect, contentSize) {\n  var domWidth = contentSize[0];\n  var domHeight = contentSize[1];\n  var gap = 5;\n  var x = 0;\n  var y = 0;\n  var rectWidth = rect.width;\n  var rectHeight = rect.height;\n\n  switch (position) {\n    case 'inside':\n      x = rect.x + rectWidth / 2 - domWidth / 2;\n      y = rect.y + rectHeight / 2 - domHeight / 2;\n      break;\n\n    case 'top':\n      x = rect.x + rectWidth / 2 - domWidth / 2;\n      y = rect.y - domHeight - gap;\n      break;\n\n    case 'bottom':\n      x = rect.x + rectWidth / 2 - domWidth / 2;\n      y = rect.y + rectHeight + gap;\n      break;\n\n    case 'left':\n      x = rect.x - domWidth - gap;\n      y = rect.y + rectHeight / 2 - domHeight / 2;\n      break;\n\n    case 'right':\n      x = rect.x + rectWidth + gap;\n      y = rect.y + rectHeight / 2 - domHeight / 2;\n  }\n\n  return [x, y];\n}\n\nfunction isCenterAlign(align) {\n  return align === 'center' || align === 'middle';\n}\n\nmodule.exports = _default;\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/echarts/lib/component/tooltip/TooltipView.js\n// module id = XAC3\n// module chunks = 1 2","var _config = require(\"../../config\");\n\nvar __DEV__ = _config.__DEV__;\n\nvar zrUtil = require(\"zrender/lib/core/util\");\n\nvar graphic = require(\"../../util/graphic\");\n\nvar modelUtil = require(\"../../util/model\");\n\nvar brushHelper = require(\"./brushHelper\");\n\nvar each = zrUtil.each;\nvar indexOf = zrUtil.indexOf;\nvar curry = zrUtil.curry;\nvar COORD_CONVERTS = ['dataToPoint', 'pointToData']; // FIXME\n// how to genarialize to more coordinate systems.\n\nvar INCLUDE_FINDER_MAIN_TYPES = ['grid', 'xAxis', 'yAxis', 'geo', 'graph', 'polar', 'radiusAxis', 'angleAxis', 'bmap'];\n/**\n * [option in constructor]:\n * {\n *     Index/Id/Name of geo, xAxis, yAxis, grid: See util/model#parseFinder.\n * }\n *\n *\n * [targetInfo]:\n *\n * There can be multiple axes in a single targetInfo. Consider the case\n * of `grid` component, a targetInfo represents a grid which contains one or more\n * cartesian and one or more axes. And consider the case of parallel system,\n * which has multiple axes in a coordinate system.\n * Can be {\n *     panelId: ...,\n *     coordSys: <a representitive cartesian in grid (first cartesian by default)>,\n *     coordSyses: all cartesians.\n *     gridModel: <grid component>\n *     xAxes: correspond to coordSyses on index\n *     yAxes: correspond to coordSyses on index\n * }\n * or {\n *     panelId: ...,\n *     coordSys: <geo coord sys>\n *     coordSyses: [<geo coord sys>]\n *     geoModel: <geo component>\n * }\n *\n *\n * [panelOpt]:\n *\n * Make from targetInfo. Input to BrushController.\n * {\n *     panelId: ...,\n *     rect: ...\n * }\n *\n *\n * [area]:\n *\n * Generated by BrushController or user input.\n * {\n *     panelId: Used to locate coordInfo directly. If user inpput, no panelId.\n *     brushType: determine how to convert to/from coord('rect' or 'polygon' or 'lineX/Y').\n *     Index/Id/Name of geo, xAxis, yAxis, grid: See util/model#parseFinder.\n *     range: pixel range.\n *     coordRange: representitive coord range (the first one of coordRanges).\n *     coordRanges: <Array> coord ranges, used in multiple cartesian in one grid.\n * }\n */\n\n/**\n * @param {Object} option contains Index/Id/Name of xAxis/yAxis/geo/grid\n *        Each can be {number|Array.<number>}. like: {xAxisIndex: [3, 4]}\n * @param {module:echarts/model/Global} ecModel\n * @param {Object} [opt]\n * @param {Array.<string>} [opt.include] include coordinate system types.\n */\n\nfunction BrushTargetManager(option, ecModel, opt) {\n  /**\n   * @private\n   * @type {Array.<Object>}\n   */\n  var targetInfoList = this._targetInfoList = [];\n  var info = {};\n  var foundCpts = parseFinder(ecModel, option);\n  each(targetInfoBuilders, function (builder, type) {\n    if (!opt || !opt.include || indexOf(opt.include, type) >= 0) {\n      builder(foundCpts, targetInfoList, info);\n    }\n  });\n}\n\nvar proto = BrushTargetManager.prototype;\n\nproto.setOutputRanges = function (areas, ecModel) {\n  this.matchOutputRanges(areas, ecModel, function (area, coordRange, coordSys) {\n    (area.coordRanges || (area.coordRanges = [])).push(coordRange); // area.coordRange is the first of area.coordRanges\n\n    if (!area.coordRange) {\n      area.coordRange = coordRange; // In 'category' axis, coord to pixel is not reversible, so we can not\n      // rebuild range by coordRange accrately, which may bring trouble when\n      // brushing only one item. So we use __rangeOffset to rebuilding range\n      // by coordRange. And this it only used in brush component so it is no\n      // need to be adapted to coordRanges.\n\n      var result = coordConvert[area.brushType](0, coordSys, coordRange);\n      area.__rangeOffset = {\n        offset: diffProcessor[area.brushType](result.values, area.range, [1, 1]),\n        xyMinMax: result.xyMinMax\n      };\n    }\n  });\n};\n\nproto.matchOutputRanges = function (areas, ecModel, cb) {\n  each(areas, function (area) {\n    var targetInfo = this.findTargetInfo(area, ecModel);\n\n    if (targetInfo && targetInfo !== true) {\n      zrUtil.each(targetInfo.coordSyses, function (coordSys) {\n        var result = coordConvert[area.brushType](1, coordSys, area.range);\n        cb(area, result.values, coordSys, ecModel);\n      });\n    }\n  }, this);\n};\n\nproto.setInputRanges = function (areas, ecModel) {\n  each(areas, function (area) {\n    var targetInfo = this.findTargetInfo(area, ecModel);\n    area.range = area.range || []; // convert coordRange to global range and set panelId.\n\n    if (targetInfo && targetInfo !== true) {\n      area.panelId = targetInfo.panelId; // (1) area.range shoule always be calculate from coordRange but does\n      // not keep its original value, for the sake of the dataZoom scenario,\n      // where area.coordRange remains unchanged but area.range may be changed.\n      // (2) Only support converting one coordRange to pixel range in brush\n      // component. So do not consider `coordRanges`.\n      // (3) About __rangeOffset, see comment above.\n\n      var result = coordConvert[area.brushType](0, targetInfo.coordSys, area.coordRange);\n      var rangeOffset = area.__rangeOffset;\n      area.range = rangeOffset ? diffProcessor[area.brushType](result.values, rangeOffset.offset, getScales(result.xyMinMax, rangeOffset.xyMinMax)) : result.values;\n    }\n  }, this);\n};\n\nproto.makePanelOpts = function (api, getDefaultBrushType) {\n  return zrUtil.map(this._targetInfoList, function (targetInfo) {\n    var rect = targetInfo.getPanelRect();\n    return {\n      panelId: targetInfo.panelId,\n      defaultBrushType: getDefaultBrushType && getDefaultBrushType(targetInfo),\n      clipPath: brushHelper.makeRectPanelClipPath(rect),\n      isTargetByCursor: brushHelper.makeRectIsTargetByCursor(rect, api, targetInfo.coordSysModel),\n      getLinearBrushOtherExtent: brushHelper.makeLinearBrushOtherExtent(rect)\n    };\n  });\n};\n\nproto.controlSeries = function (area, seriesModel, ecModel) {\n  // Check whether area is bound in coord, and series do not belong to that coord.\n  // If do not do this check, some brush (like lineX) will controll all axes.\n  var targetInfo = this.findTargetInfo(area, ecModel);\n  return targetInfo === true || targetInfo && indexOf(targetInfo.coordSyses, seriesModel.coordinateSystem) >= 0;\n};\n/**\n * If return Object, a coord found.\n * If reutrn true, global found.\n * Otherwise nothing found.\n *\n * @param {Object} area\n * @param {Array} targetInfoList\n * @return {Object|boolean}\n */\n\n\nproto.findTargetInfo = function (area, ecModel) {\n  var targetInfoList = this._targetInfoList;\n  var foundCpts = parseFinder(ecModel, area);\n\n  for (var i = 0; i < targetInfoList.length; i++) {\n    var targetInfo = targetInfoList[i];\n    var areaPanelId = area.panelId;\n\n    if (areaPanelId) {\n      if (targetInfo.panelId === areaPanelId) {\n        return targetInfo;\n      }\n    } else {\n      for (var i = 0; i < targetInfoMatchers.length; i++) {\n        if (targetInfoMatchers[i](foundCpts, targetInfo)) {\n          return targetInfo;\n        }\n      }\n    }\n  }\n\n  return true;\n};\n\nfunction formatMinMax(minMax) {\n  minMax[0] > minMax[1] && minMax.reverse();\n  return minMax;\n}\n\nfunction parseFinder(ecModel, option) {\n  return modelUtil.parseFinder(ecModel, option, {\n    includeMainTypes: INCLUDE_FINDER_MAIN_TYPES\n  });\n}\n\nvar targetInfoBuilders = {\n  grid: function (foundCpts, targetInfoList) {\n    var xAxisModels = foundCpts.xAxisModels;\n    var yAxisModels = foundCpts.yAxisModels;\n    var gridModels = foundCpts.gridModels; // Remove duplicated.\n\n    var gridModelMap = zrUtil.createHashMap();\n    var xAxesHas = {};\n    var yAxesHas = {};\n\n    if (!xAxisModels && !yAxisModels && !gridModels) {\n      return;\n    }\n\n    each(xAxisModels, function (axisModel) {\n      var gridModel = axisModel.axis.grid.model;\n      gridModelMap.set(gridModel.id, gridModel);\n      xAxesHas[gridModel.id] = true;\n    });\n    each(yAxisModels, function (axisModel) {\n      var gridModel = axisModel.axis.grid.model;\n      gridModelMap.set(gridModel.id, gridModel);\n      yAxesHas[gridModel.id] = true;\n    });\n    each(gridModels, function (gridModel) {\n      gridModelMap.set(gridModel.id, gridModel);\n      xAxesHas[gridModel.id] = true;\n      yAxesHas[gridModel.id] = true;\n    });\n    gridModelMap.each(function (gridModel) {\n      var grid = gridModel.coordinateSystem;\n      var cartesians = [];\n      each(grid.getCartesians(), function (cartesian, index) {\n        if (indexOf(xAxisModels, cartesian.getAxis('x').model) >= 0 || indexOf(yAxisModels, cartesian.getAxis('y').model) >= 0) {\n          cartesians.push(cartesian);\n        }\n      });\n      targetInfoList.push({\n        panelId: 'grid--' + gridModel.id,\n        gridModel: gridModel,\n        coordSysModel: gridModel,\n        // Use the first one as the representitive coordSys.\n        coordSys: cartesians[0],\n        coordSyses: cartesians,\n        getPanelRect: panelRectBuilder.grid,\n        xAxisDeclared: xAxesHas[gridModel.id],\n        yAxisDeclared: yAxesHas[gridModel.id]\n      });\n    });\n  },\n  geo: function (foundCpts, targetInfoList) {\n    each(foundCpts.geoModels, function (geoModel) {\n      var coordSys = geoModel.coordinateSystem;\n      targetInfoList.push({\n        panelId: 'geo--' + geoModel.id,\n        geoModel: geoModel,\n        coordSysModel: geoModel,\n        coordSys: coordSys,\n        coordSyses: [coordSys],\n        getPanelRect: panelRectBuilder.geo\n      });\n    });\n  }\n};\nvar targetInfoMatchers = [// grid\nfunction (foundCpts, targetInfo) {\n  var xAxisModel = foundCpts.xAxisModel;\n  var yAxisModel = foundCpts.yAxisModel;\n  var gridModel = foundCpts.gridModel;\n  !gridModel && xAxisModel && (gridModel = xAxisModel.axis.grid.model);\n  !gridModel && yAxisModel && (gridModel = yAxisModel.axis.grid.model);\n  return gridModel && gridModel === targetInfo.gridModel;\n}, // geo\nfunction (foundCpts, targetInfo) {\n  var geoModel = foundCpts.geoModel;\n  return geoModel && geoModel === targetInfo.geoModel;\n}];\nvar panelRectBuilder = {\n  grid: function () {\n    // grid is not Transformable.\n    return this.coordSys.grid.getRect().clone();\n  },\n  geo: function () {\n    var coordSys = this.coordSys;\n    var rect = coordSys.getBoundingRect().clone(); // geo roam and zoom transform\n\n    rect.applyTransform(graphic.getTransform(coordSys));\n    return rect;\n  }\n};\nvar coordConvert = {\n  lineX: curry(axisConvert, 0),\n  lineY: curry(axisConvert, 1),\n  rect: function (to, coordSys, rangeOrCoordRange) {\n    var xminymin = coordSys[COORD_CONVERTS[to]]([rangeOrCoordRange[0][0], rangeOrCoordRange[1][0]]);\n    var xmaxymax = coordSys[COORD_CONVERTS[to]]([rangeOrCoordRange[0][1], rangeOrCoordRange[1][1]]);\n    var values = [formatMinMax([xminymin[0], xmaxymax[0]]), formatMinMax([xminymin[1], xmaxymax[1]])];\n    return {\n      values: values,\n      xyMinMax: values\n    };\n  },\n  polygon: function (to, coordSys, rangeOrCoordRange) {\n    var xyMinMax = [[Infinity, -Infinity], [Infinity, -Infinity]];\n    var values = zrUtil.map(rangeOrCoordRange, function (item) {\n      var p = coordSys[COORD_CONVERTS[to]](item);\n      xyMinMax[0][0] = Math.min(xyMinMax[0][0], p[0]);\n      xyMinMax[1][0] = Math.min(xyMinMax[1][0], p[1]);\n      xyMinMax[0][1] = Math.max(xyMinMax[0][1], p[0]);\n      xyMinMax[1][1] = Math.max(xyMinMax[1][1], p[1]);\n      return p;\n    });\n    return {\n      values: values,\n      xyMinMax: xyMinMax\n    };\n  }\n};\n\nfunction axisConvert(axisNameIndex, to, coordSys, rangeOrCoordRange) {\n  var axis = coordSys.getAxis(['x', 'y'][axisNameIndex]);\n  var values = formatMinMax(zrUtil.map([0, 1], function (i) {\n    return to ? axis.coordToData(axis.toLocalCoord(rangeOrCoordRange[i])) : axis.toGlobalCoord(axis.dataToCoord(rangeOrCoordRange[i]));\n  }));\n  var xyMinMax = [];\n  xyMinMax[axisNameIndex] = values;\n  xyMinMax[1 - axisNameIndex] = [NaN, NaN];\n  return {\n    values: values,\n    xyMinMax: xyMinMax\n  };\n}\n\nvar diffProcessor = {\n  lineX: curry(axisDiffProcessor, 0),\n  lineY: curry(axisDiffProcessor, 1),\n  rect: function (values, refer, scales) {\n    return [[values[0][0] - scales[0] * refer[0][0], values[0][1] - scales[0] * refer[0][1]], [values[1][0] - scales[1] * refer[1][0], values[1][1] - scales[1] * refer[1][1]]];\n  },\n  polygon: function (values, refer, scales) {\n    return zrUtil.map(values, function (item, idx) {\n      return [item[0] - scales[0] * refer[idx][0], item[1] - scales[1] * refer[idx][1]];\n    });\n  }\n};\n\nfunction axisDiffProcessor(axisNameIndex, values, refer, scales) {\n  return [values[0] - scales[axisNameIndex] * refer[0], values[1] - scales[axisNameIndex] * refer[1]];\n} // We have to process scale caused by dataZoom manually,\n// although it might be not accurate.\n\n\nfunction getScales(xyMinMaxCurr, xyMinMaxOrigin) {\n  var sizeCurr = getSize(xyMinMaxCurr);\n  var sizeOrigin = getSize(xyMinMaxOrigin);\n  var scales = [sizeCurr[0] / sizeOrigin[0], sizeCurr[1] / sizeOrigin[1]];\n  isNaN(scales[0]) && (scales[0] = 1);\n  isNaN(scales[1]) && (scales[1] = 1);\n  return scales;\n}\n\nfunction getSize(xyMinMax) {\n  return xyMinMax ? [xyMinMax[0][1] - xyMinMax[0][0], xyMinMax[1][1] - xyMinMax[1][0]] : [NaN, NaN];\n}\n\nvar _default = BrushTargetManager;\nmodule.exports = _default;\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/echarts/lib/component/helper/BrushTargetManager.js\n// module id = XCrL\n// module chunks = 1 2","require(\"./toolbox/ToolboxModel\");\n\nrequire(\"./toolbox/ToolboxView\");\n\nrequire(\"./toolbox/feature/SaveAsImage\");\n\nrequire(\"./toolbox/feature/MagicType\");\n\nrequire(\"./toolbox/feature/DataView\");\n\nrequire(\"./toolbox/feature/DataZoom\");\n\nrequire(\"./toolbox/feature/Restore\");\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/echarts/lib/component/toolbox.js\n// module id = YsUA\n// module chunks = 1 2","var BoundingRect = require(\"zrender/lib/core/BoundingRect\");\n\nvar _cursorHelper = require(\"./cursorHelper\");\n\nvar onIrrelevantElement = _cursorHelper.onIrrelevantElement;\n\nvar graphicUtil = require(\"../../util/graphic\");\n\nfunction makeRectPanelClipPath(rect) {\n  rect = normalizeRect(rect);\n  return function (localPoints, transform) {\n    return graphicUtil.clipPointsByRect(localPoints, rect);\n  };\n}\n\nfunction makeLinearBrushOtherExtent(rect, specifiedXYIndex) {\n  rect = normalizeRect(rect);\n  return function (xyIndex) {\n    var idx = specifiedXYIndex != null ? specifiedXYIndex : xyIndex;\n    var brushWidth = idx ? rect.width : rect.height;\n    var base = idx ? rect.x : rect.y;\n    return [base, base + (brushWidth || 0)];\n  };\n}\n\nfunction makeRectIsTargetByCursor(rect, api, targetModel) {\n  rect = normalizeRect(rect);\n  return function (e, localCursorPoint, transform) {\n    return rect.contain(localCursorPoint[0], localCursorPoint[1]) && !onIrrelevantElement(e, api, targetModel);\n  };\n} // Consider width/height is negative.\n\n\nfunction normalizeRect(rect) {\n  return BoundingRect.create(rect);\n}\n\nexports.makeRectPanelClipPath = makeRectPanelClipPath;\nexports.makeLinearBrushOtherExtent = makeLinearBrushOtherExtent;\nexports.makeRectIsTargetByCursor = makeRectIsTargetByCursor;\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/echarts/lib/component/helper/brushHelper.js\n// module id = ZJ+T\n// module chunks = 1 2","var zrUtil = require(\"zrender/lib/core/util\");\n\nvar zrColor = require(\"zrender/lib/tool/color\");\n\nvar eventUtil = require(\"zrender/lib/core/event\");\n\nvar env = require(\"zrender/lib/core/env\");\n\nvar formatUtil = require(\"../../util/format\");\n\nvar each = zrUtil.each;\nvar toCamelCase = formatUtil.toCamelCase;\nvar vendors = ['', '-webkit-', '-moz-', '-o-'];\nvar gCssText = 'position:absolute;display:block;border-style:solid;white-space:nowrap;z-index:9999999;';\n/**\n * @param {number} duration\n * @return {string}\n * @inner\n */\n\nfunction assembleTransition(duration) {\n  var transitionCurve = 'cubic-bezier(0.23, 1, 0.32, 1)';\n  var transitionText = 'left ' + duration + 's ' + transitionCurve + ',' + 'top ' + duration + 's ' + transitionCurve;\n  return zrUtil.map(vendors, function (vendorPrefix) {\n    return vendorPrefix + 'transition:' + transitionText;\n  }).join(';');\n}\n/**\n * @param {Object} textStyle\n * @return {string}\n * @inner\n */\n\n\nfunction assembleFont(textStyleModel) {\n  var cssText = [];\n  var fontSize = textStyleModel.get('fontSize');\n  var color = textStyleModel.getTextColor();\n  color && cssText.push('color:' + color);\n  cssText.push('font:' + textStyleModel.getFont());\n  fontSize && cssText.push('line-height:' + Math.round(fontSize * 3 / 2) + 'px');\n  each(['decoration', 'align'], function (name) {\n    var val = textStyleModel.get(name);\n    val && cssText.push('text-' + name + ':' + val);\n  });\n  return cssText.join(';');\n}\n/**\n * @param {Object} tooltipModel\n * @return {string}\n * @inner\n */\n\n\nfunction assembleCssText(tooltipModel) {\n  var cssText = [];\n  var transitionDuration = tooltipModel.get('transitionDuration');\n  var backgroundColor = tooltipModel.get('backgroundColor');\n  var textStyleModel = tooltipModel.getModel('textStyle');\n  var padding = tooltipModel.get('padding'); // Animation transition. Do not animate when transitionDuration is 0.\n\n  transitionDuration && cssText.push(assembleTransition(transitionDuration));\n\n  if (backgroundColor) {\n    if (env.canvasSupported) {\n      cssText.push('background-Color:' + backgroundColor);\n    } else {\n      // for ie\n      cssText.push('background-Color:#' + zrColor.toHex(backgroundColor));\n      cssText.push('filter:alpha(opacity=70)');\n    }\n  } // Border style\n\n\n  each(['width', 'color', 'radius'], function (name) {\n    var borderName = 'border-' + name;\n    var camelCase = toCamelCase(borderName);\n    var val = tooltipModel.get(camelCase);\n    val != null && cssText.push(borderName + ':' + val + (name === 'color' ? '' : 'px'));\n  }); // Text style\n\n  cssText.push(assembleFont(textStyleModel)); // Padding\n\n  if (padding != null) {\n    cssText.push('padding:' + formatUtil.normalizeCssArray(padding).join('px ') + 'px');\n  }\n\n  return cssText.join(';') + ';';\n}\n/**\n * @alias module:echarts/component/tooltip/TooltipContent\n * @constructor\n */\n\n\nfunction TooltipContent(container, api) {\n  var el = document.createElement('div');\n  var zr = this._zr = api.getZr();\n  this.el = el;\n  this._x = api.getWidth() / 2;\n  this._y = api.getHeight() / 2;\n  container.appendChild(el);\n  this._container = container;\n  this._show = false;\n  /**\n   * @private\n   */\n\n  this._hideTimeout;\n  var self = this;\n\n  el.onmouseenter = function () {\n    // clear the timeout in hideLater and keep showing tooltip\n    if (self._enterable) {\n      clearTimeout(self._hideTimeout);\n      self._show = true;\n    }\n\n    self._inContent = true;\n  };\n\n  el.onmousemove = function (e) {\n    e = e || window.event;\n\n    if (!self._enterable) {\n      // Try trigger zrender event to avoid mouse\n      // in and out shape too frequently\n      var handler = zr.handler;\n      eventUtil.normalizeEvent(container, e, true);\n      handler.dispatch('mousemove', e);\n    }\n  };\n\n  el.onmouseleave = function () {\n    if (self._enterable) {\n      if (self._show) {\n        self.hideLater(self._hideDelay);\n      }\n    }\n\n    self._inContent = false;\n  };\n}\n\nTooltipContent.prototype = {\n  constructor: TooltipContent,\n\n  /**\n   * @private\n   * @type {boolean}\n   */\n  _enterable: true,\n\n  /**\n   * Update when tooltip is rendered\n   */\n  update: function () {\n    // FIXME\n    // Move this logic to ec main?\n    var container = this._container;\n    var stl = container.currentStyle || document.defaultView.getComputedStyle(container);\n    var domStyle = container.style;\n\n    if (domStyle.position !== 'absolute' && stl.position !== 'absolute') {\n      domStyle.position = 'relative';\n    } // Hide the tooltip\n    // PENDING\n    // this.hide();\n\n  },\n  show: function (tooltipModel) {\n    clearTimeout(this._hideTimeout);\n    var el = this.el;\n    el.style.cssText = gCssText + assembleCssText(tooltipModel) // http://stackoverflow.com/questions/21125587/css3-transition-not-working-in-chrome-anymore\n    + ';left:' + this._x + 'px;top:' + this._y + 'px;' + (tooltipModel.get('extraCssText') || '');\n    el.style.display = el.innerHTML ? 'block' : 'none';\n    this._show = true;\n  },\n  setContent: function (content) {\n    this.el.innerHTML = content == null ? '' : content;\n  },\n  setEnterable: function (enterable) {\n    this._enterable = enterable;\n  },\n  getSize: function () {\n    var el = this.el;\n    return [el.clientWidth, el.clientHeight];\n  },\n  moveTo: function (x, y) {\n    // xy should be based on canvas root. But tooltipContent is\n    // the sibling of canvas root. So padding of ec container\n    // should be considered here.\n    var zr = this._zr;\n    var viewportRootOffset;\n\n    if (zr && zr.painter && (viewportRootOffset = zr.painter.getViewportRootOffset())) {\n      x += viewportRootOffset.offsetLeft;\n      y += viewportRootOffset.offsetTop;\n    }\n\n    var style = this.el.style;\n    style.left = x + 'px';\n    style.top = y + 'px';\n    this._x = x;\n    this._y = y;\n  },\n  hide: function () {\n    this.el.style.display = 'none';\n    this._show = false;\n  },\n  hideLater: function (time) {\n    if (this._show && !(this._inContent && this._enterable)) {\n      if (time) {\n        this._hideDelay = time; // Set show false to avoid invoke hideLater mutiple times\n\n        this._show = false;\n        this._hideTimeout = setTimeout(zrUtil.bind(this.hide, this), time);\n      } else {\n        this.hide();\n      }\n    }\n  },\n  isShow: function () {\n    return this._show;\n  }\n};\nvar _default = TooltipContent;\nmodule.exports = _default;\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/echarts/lib/component/tooltip/TooltipContent.js\n// module id = aYad\n// module chunks = 1 2","var echarts = require(\"../../echarts\");\n\nvar zrUtil = require(\"zrender/lib/core/util\");\n\nvar featureManager = require(\"./featureManager\");\n\nvar ToolboxModel = echarts.extendComponentModel({\n  type: 'toolbox',\n  layoutMode: {\n    type: 'box',\n    ignoreSize: true\n  },\n  mergeDefaultAndTheme: function (option) {\n    ToolboxModel.superApply(this, 'mergeDefaultAndTheme', arguments);\n    zrUtil.each(this.option.feature, function (featureOpt, featureName) {\n      var Feature = featureManager.get(featureName);\n      Feature && zrUtil.merge(featureOpt, Feature.defaultOption);\n    });\n  },\n  defaultOption: {\n    show: true,\n    z: 6,\n    zlevel: 0,\n    orient: 'horizontal',\n    left: 'right',\n    top: 'top',\n    // right\n    // bottom\n    backgroundColor: 'transparent',\n    borderColor: '#ccc',\n    borderRadius: 0,\n    borderWidth: 0,\n    padding: 5,\n    itemSize: 15,\n    itemGap: 8,\n    showTitle: true,\n    iconStyle: {\n      normal: {\n        borderColor: '#666',\n        color: 'none'\n      },\n      emphasis: {\n        borderColor: '#3E98C5'\n      } // textStyle: {},\n      // feature\n\n    }\n  }\n});\nvar _default = ToolboxModel;\nmodule.exports = _default;\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/echarts/lib/component/toolbox/ToolboxModel.js\n// module id = auIi\n// module chunks = 1 2","var echarts = require(\"../../echarts\");\n\necharts.registerProcessor(function (ecModel, api) {\n  ecModel.eachComponent('dataZoom', function (dataZoomModel) {\n    // We calculate window and reset axis here but not in model\n    // init stage and not after action dispatch handler, because\n    // reset should be called after seriesData.restoreData.\n    dataZoomModel.eachTargetAxis(resetSingleAxis); // Caution: data zoom filtering is order sensitive when using\n    // percent range and no min/max/scale set on axis.\n    // For example, we have dataZoom definition:\n    // [\n    //      {xAxisIndex: 0, start: 30, end: 70},\n    //      {yAxisIndex: 0, start: 20, end: 80}\n    // ]\n    // In this case, [20, 80] of y-dataZoom should be based on data\n    // that have filtered by x-dataZoom using range of [30, 70],\n    // but should not be based on full raw data. Thus sliding\n    // x-dataZoom will change both ranges of xAxis and yAxis,\n    // while sliding y-dataZoom will only change the range of yAxis.\n    // So we should filter x-axis after reset x-axis immediately,\n    // and then reset y-axis and filter y-axis.\n\n    dataZoomModel.eachTargetAxis(filterSingleAxis);\n  });\n  ecModel.eachComponent('dataZoom', function (dataZoomModel) {\n    // Fullfill all of the range props so that user\n    // is able to get them from chart.getOption().\n    var axisProxy = dataZoomModel.findRepresentativeAxisProxy();\n    var percentRange = axisProxy.getDataPercentWindow();\n    var valueRange = axisProxy.getDataValueWindow();\n    dataZoomModel.setRawRange({\n      start: percentRange[0],\n      end: percentRange[1],\n      startValue: valueRange[0],\n      endValue: valueRange[1]\n    }, true);\n  });\n});\n\nfunction resetSingleAxis(dimNames, axisIndex, dataZoomModel) {\n  dataZoomModel.getAxisProxy(dimNames.name, axisIndex).reset(dataZoomModel);\n}\n\nfunction filterSingleAxis(dimNames, axisIndex, dataZoomModel) {\n  dataZoomModel.getAxisProxy(dimNames.name, axisIndex).filterData(dataZoomModel);\n}\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/echarts/lib/component/dataZoom/dataZoomProcessor.js\n// module id = b/SY\n// module chunks = 1 2","module.exports = { \"default\": require(\"core-js/library/fn/array/from\"), __esModule: true };\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/babel-runtime/core-js/array/from.js\n// module id = c/Tr\n// module chunks = 2","var _config = require(\"../../config\");\n\nvar __DEV__ = _config.__DEV__;\n\nvar zrUtil = require(\"zrender/lib/core/util\");\n\nvar SymbolDraw = require(\"../helper/SymbolDraw\");\n\nvar SymbolClz = require(\"../helper/Symbol\");\n\nvar lineAnimationDiff = require(\"./lineAnimationDiff\");\n\nvar graphic = require(\"../../util/graphic\");\n\nvar modelUtil = require(\"../../util/model\");\n\nvar _poly = require(\"./poly\");\n\nvar Polyline = _poly.Polyline;\nvar Polygon = _poly.Polygon;\n\nvar ChartView = require(\"../../view/Chart\");\n\n// FIXME step not support polar\nfunction isPointsSame(points1, points2) {\n  if (points1.length !== points2.length) {\n    return;\n  }\n\n  for (var i = 0; i < points1.length; i++) {\n    var p1 = points1[i];\n    var p2 = points2[i];\n\n    if (p1[0] !== p2[0] || p1[1] !== p2[1]) {\n      return;\n    }\n  }\n\n  return true;\n}\n\nfunction getSmooth(smooth) {\n  return typeof smooth === 'number' ? smooth : smooth ? 0.3 : 0;\n}\n\nfunction getAxisExtentWithGap(axis) {\n  var extent = axis.getGlobalExtent();\n\n  if (axis.onBand) {\n    // Remove extra 1px to avoid line miter in clipped edge\n    var halfBandWidth = axis.getBandWidth() / 2 - 1;\n    var dir = extent[1] > extent[0] ? 1 : -1;\n    extent[0] += dir * halfBandWidth;\n    extent[1] -= dir * halfBandWidth;\n  }\n\n  return extent;\n}\n\nfunction sign(val) {\n  return val >= 0 ? 1 : -1;\n}\n/**\n * @param {module:echarts/coord/cartesian/Cartesian2D|module:echarts/coord/polar/Polar} coordSys\n * @param {module:echarts/data/List} data\n * @param {Array.<Array.<number>>} points\n * @private\n */\n\n\nfunction getStackedOnPoints(coordSys, data) {\n  var baseAxis = coordSys.getBaseAxis();\n  var valueAxis = coordSys.getOtherAxis(baseAxis);\n  var valueStart = 0;\n\n  if (!baseAxis.onZero) {\n    var extent = valueAxis.scale.getExtent();\n\n    if (extent[0] > 0) {\n      // Both positive\n      valueStart = extent[0];\n    } else if (extent[1] < 0) {\n      // Both negative\n      valueStart = extent[1];\n    } // If is one positive, and one negative, onZero shall be true\n\n  }\n\n  var valueDim = valueAxis.dim;\n  var baseDataOffset = valueDim === 'x' || valueDim === 'radius' ? 1 : 0;\n  return data.mapArray([valueDim], function (val, idx) {\n    var stackedOnSameSign;\n    var stackedOn = data.stackedOn; // Find first stacked value with same sign\n\n    while (stackedOn && sign(stackedOn.get(valueDim, idx)) === sign(val)) {\n      stackedOnSameSign = stackedOn;\n      break;\n    }\n\n    var stackedData = [];\n    stackedData[baseDataOffset] = data.get(baseAxis.dim, idx);\n    stackedData[1 - baseDataOffset] = stackedOnSameSign ? stackedOnSameSign.get(valueDim, idx, true) : valueStart;\n    return coordSys.dataToPoint(stackedData);\n  }, true);\n}\n\nfunction createGridClipShape(cartesian, hasAnimation, seriesModel) {\n  var xExtent = getAxisExtentWithGap(cartesian.getAxis('x'));\n  var yExtent = getAxisExtentWithGap(cartesian.getAxis('y'));\n  var isHorizontal = cartesian.getBaseAxis().isHorizontal();\n  var x = Math.min(xExtent[0], xExtent[1]);\n  var y = Math.min(yExtent[0], yExtent[1]);\n  var width = Math.max(xExtent[0], xExtent[1]) - x;\n  var height = Math.max(yExtent[0], yExtent[1]) - y;\n  var lineWidth = seriesModel.get('lineStyle.normal.width') || 2; // Expand clip shape to avoid clipping when line value exceeds axis\n\n  var expandSize = seriesModel.get('clipOverflow') ? lineWidth / 2 : Math.max(width, height);\n\n  if (isHorizontal) {\n    y -= expandSize;\n    height += expandSize * 2;\n  } else {\n    x -= expandSize;\n    width += expandSize * 2;\n  }\n\n  var clipPath = new graphic.Rect({\n    shape: {\n      x: x,\n      y: y,\n      width: width,\n      height: height\n    }\n  });\n\n  if (hasAnimation) {\n    clipPath.shape[isHorizontal ? 'width' : 'height'] = 0;\n    graphic.initProps(clipPath, {\n      shape: {\n        width: width,\n        height: height\n      }\n    }, seriesModel);\n  }\n\n  return clipPath;\n}\n\nfunction createPolarClipShape(polar, hasAnimation, seriesModel) {\n  var angleAxis = polar.getAngleAxis();\n  var radiusAxis = polar.getRadiusAxis();\n  var radiusExtent = radiusAxis.getExtent();\n  var angleExtent = angleAxis.getExtent();\n  var RADIAN = Math.PI / 180;\n  var clipPath = new graphic.Sector({\n    shape: {\n      cx: polar.cx,\n      cy: polar.cy,\n      r0: radiusExtent[0],\n      r: radiusExtent[1],\n      startAngle: -angleExtent[0] * RADIAN,\n      endAngle: -angleExtent[1] * RADIAN,\n      clockwise: angleAxis.inverse\n    }\n  });\n\n  if (hasAnimation) {\n    clipPath.shape.endAngle = -angleExtent[0] * RADIAN;\n    graphic.initProps(clipPath, {\n      shape: {\n        endAngle: -angleExtent[1] * RADIAN\n      }\n    }, seriesModel);\n  }\n\n  return clipPath;\n}\n\nfunction createClipShape(coordSys, hasAnimation, seriesModel) {\n  return coordSys.type === 'polar' ? createPolarClipShape(coordSys, hasAnimation, seriesModel) : createGridClipShape(coordSys, hasAnimation, seriesModel);\n}\n\nfunction turnPointsIntoStep(points, coordSys, stepTurnAt) {\n  var baseAxis = coordSys.getBaseAxis();\n  var baseIndex = baseAxis.dim === 'x' || baseAxis.dim === 'radius' ? 0 : 1;\n  var stepPoints = [];\n\n  for (var i = 0; i < points.length - 1; i++) {\n    var nextPt = points[i + 1];\n    var pt = points[i];\n    stepPoints.push(pt);\n    var stepPt = [];\n\n    switch (stepTurnAt) {\n      case 'end':\n        stepPt[baseIndex] = nextPt[baseIndex];\n        stepPt[1 - baseIndex] = pt[1 - baseIndex]; // default is start\n\n        stepPoints.push(stepPt);\n        break;\n\n      case 'middle':\n        // default is start\n        var middle = (pt[baseIndex] + nextPt[baseIndex]) / 2;\n        var stepPt2 = [];\n        stepPt[baseIndex] = stepPt2[baseIndex] = middle;\n        stepPt[1 - baseIndex] = pt[1 - baseIndex];\n        stepPt2[1 - baseIndex] = nextPt[1 - baseIndex];\n        stepPoints.push(stepPt);\n        stepPoints.push(stepPt2);\n        break;\n\n      default:\n        stepPt[baseIndex] = pt[baseIndex];\n        stepPt[1 - baseIndex] = nextPt[1 - baseIndex]; // default is start\n\n        stepPoints.push(stepPt);\n    }\n  } // Last points\n\n\n  points[i] && stepPoints.push(points[i]);\n  return stepPoints;\n}\n\nfunction getVisualGradient(data, coordSys) {\n  var visualMetaList = data.getVisual('visualMeta');\n\n  if (!visualMetaList || !visualMetaList.length || !data.count()) {\n    // When data.count() is 0, gradient range can not be calculated.\n    return;\n  }\n\n  var visualMeta;\n\n  for (var i = visualMetaList.length - 1; i >= 0; i--) {\n    // Can only be x or y\n    if (visualMetaList[i].dimension < 2) {\n      visualMeta = visualMetaList[i];\n      break;\n    }\n  }\n\n  if (!visualMeta || coordSys.type !== 'cartesian2d') {\n    return;\n  } // If the area to be rendered is bigger than area defined by LinearGradient,\n  // the canvas spec prescribes that the color of the first stop and the last\n  // stop should be used. But if two stops are added at offset 0, in effect\n  // browsers use the color of the second stop to render area outside\n  // LinearGradient. So we can only infinitesimally extend area defined in\n  // LinearGradient to render `outerColors`.\n\n\n  var dimension = visualMeta.dimension;\n  var dimName = data.dimensions[dimension];\n  var axis = coordSys.getAxis(dimName); // dataToCoor mapping may not be linear, but must be monotonic.\n\n  var colorStops = zrUtil.map(visualMeta.stops, function (stop) {\n    return {\n      coord: axis.toGlobalCoord(axis.dataToCoord(stop.value)),\n      color: stop.color\n    };\n  });\n  var stopLen = colorStops.length;\n  var outerColors = visualMeta.outerColors.slice();\n\n  if (stopLen && colorStops[0].coord > colorStops[stopLen - 1].coord) {\n    colorStops.reverse();\n    outerColors.reverse();\n  }\n\n  var tinyExtent = 10; // Arbitrary value: 10px\n\n  var minCoord = colorStops[0].coord - tinyExtent;\n  var maxCoord = colorStops[stopLen - 1].coord + tinyExtent;\n  var coordSpan = maxCoord - minCoord;\n\n  if (coordSpan < 1e-3) {\n    return 'transparent';\n  }\n\n  zrUtil.each(colorStops, function (stop) {\n    stop.offset = (stop.coord - minCoord) / coordSpan;\n  });\n  colorStops.push({\n    offset: stopLen ? colorStops[stopLen - 1].offset : 0.5,\n    color: outerColors[1] || 'transparent'\n  });\n  colorStops.unshift({\n    // notice colorStops.length have been changed.\n    offset: stopLen ? colorStops[0].offset : 0.5,\n    color: outerColors[0] || 'transparent'\n  }); // zrUtil.each(colorStops, function (colorStop) {\n  //     // Make sure each offset has rounded px to avoid not sharp edge\n  //     colorStop.offset = (Math.round(colorStop.offset * (end - start) + start) - start) / (end - start);\n  // });\n\n  var gradient = new graphic.LinearGradient(0, 0, 0, 0, colorStops, true);\n  gradient[dimName] = minCoord;\n  gradient[dimName + '2'] = maxCoord;\n  return gradient;\n}\n\nvar _default = ChartView.extend({\n  type: 'line',\n  init: function () {\n    var lineGroup = new graphic.Group();\n    var symbolDraw = new SymbolDraw();\n    this.group.add(symbolDraw.group);\n    this._symbolDraw = symbolDraw;\n    this._lineGroup = lineGroup;\n  },\n  render: function (seriesModel, ecModel, api) {\n    var coordSys = seriesModel.coordinateSystem;\n    var group = this.group;\n    var data = seriesModel.getData();\n    var lineStyleModel = seriesModel.getModel('lineStyle.normal');\n    var areaStyleModel = seriesModel.getModel('areaStyle.normal');\n    var points = data.mapArray(data.getItemLayout, true);\n    var isCoordSysPolar = coordSys.type === 'polar';\n    var prevCoordSys = this._coordSys;\n    var symbolDraw = this._symbolDraw;\n    var polyline = this._polyline;\n    var polygon = this._polygon;\n    var lineGroup = this._lineGroup;\n    var hasAnimation = seriesModel.get('animation');\n    var isAreaChart = !areaStyleModel.isEmpty();\n    var stackedOnPoints = getStackedOnPoints(coordSys, data);\n    var showSymbol = seriesModel.get('showSymbol');\n\n    var isSymbolIgnore = showSymbol && !isCoordSysPolar && !seriesModel.get('showAllSymbol') && this._getSymbolIgnoreFunc(data, coordSys); // Remove temporary symbols\n\n\n    var oldData = this._data;\n    oldData && oldData.eachItemGraphicEl(function (el, idx) {\n      if (el.__temp) {\n        group.remove(el);\n        oldData.setItemGraphicEl(idx, null);\n      }\n    }); // Remove previous created symbols if showSymbol changed to false\n\n    if (!showSymbol) {\n      symbolDraw.remove();\n    }\n\n    group.add(lineGroup); // FIXME step not support polar\n\n    var step = !isCoordSysPolar && seriesModel.get('step'); // Initialization animation or coordinate system changed\n\n    if (!(polyline && prevCoordSys.type === coordSys.type && step === this._step)) {\n      showSymbol && symbolDraw.updateData(data, isSymbolIgnore);\n\n      if (step) {\n        // TODO If stacked series is not step\n        points = turnPointsIntoStep(points, coordSys, step);\n        stackedOnPoints = turnPointsIntoStep(stackedOnPoints, coordSys, step);\n      }\n\n      polyline = this._newPolyline(points, coordSys, hasAnimation);\n\n      if (isAreaChart) {\n        polygon = this._newPolygon(points, stackedOnPoints, coordSys, hasAnimation);\n      }\n\n      lineGroup.setClipPath(createClipShape(coordSys, true, seriesModel));\n    } else {\n      if (isAreaChart && !polygon) {\n        // If areaStyle is added\n        polygon = this._newPolygon(points, stackedOnPoints, coordSys, hasAnimation);\n      } else if (polygon && !isAreaChart) {\n        // If areaStyle is removed\n        lineGroup.remove(polygon);\n        polygon = this._polygon = null;\n      } // Update clipPath\n\n\n      lineGroup.setClipPath(createClipShape(coordSys, false, seriesModel)); // Always update, or it is wrong in the case turning on legend\n      // because points are not changed\n\n      showSymbol && symbolDraw.updateData(data, isSymbolIgnore); // Stop symbol animation and sync with line points\n      // FIXME performance?\n\n      data.eachItemGraphicEl(function (el) {\n        el.stopAnimation(true);\n      }); // In the case data zoom triggerred refreshing frequently\n      // Data may not change if line has a category axis. So it should animate nothing\n\n      if (!isPointsSame(this._stackedOnPoints, stackedOnPoints) || !isPointsSame(this._points, points)) {\n        if (hasAnimation) {\n          this._updateAnimation(data, stackedOnPoints, coordSys, api, step);\n        } else {\n          // Not do it in update with animation\n          if (step) {\n            // TODO If stacked series is not step\n            points = turnPointsIntoStep(points, coordSys, step);\n            stackedOnPoints = turnPointsIntoStep(stackedOnPoints, coordSys, step);\n          }\n\n          polyline.setShape({\n            points: points\n          });\n          polygon && polygon.setShape({\n            points: points,\n            stackedOnPoints: stackedOnPoints\n          });\n        }\n      }\n    }\n\n    var visualColor = getVisualGradient(data, coordSys) || data.getVisual('color');\n    polyline.useStyle(zrUtil.defaults( // Use color in lineStyle first\n    lineStyleModel.getLineStyle(), {\n      fill: 'none',\n      stroke: visualColor,\n      lineJoin: 'bevel'\n    }));\n    var smooth = seriesModel.get('smooth');\n    smooth = getSmooth(seriesModel.get('smooth'));\n    polyline.setShape({\n      smooth: smooth,\n      smoothMonotone: seriesModel.get('smoothMonotone'),\n      connectNulls: seriesModel.get('connectNulls')\n    });\n\n    if (polygon) {\n      var stackedOn = data.stackedOn;\n      var stackedOnSmooth = 0;\n      polygon.useStyle(zrUtil.defaults(areaStyleModel.getAreaStyle(), {\n        fill: visualColor,\n        opacity: 0.7,\n        lineJoin: 'bevel'\n      }));\n\n      if (stackedOn) {\n        var stackedOnSeries = stackedOn.hostModel;\n        stackedOnSmooth = getSmooth(stackedOnSeries.get('smooth'));\n      }\n\n      polygon.setShape({\n        smooth: smooth,\n        stackedOnSmooth: stackedOnSmooth,\n        smoothMonotone: seriesModel.get('smoothMonotone'),\n        connectNulls: seriesModel.get('connectNulls')\n      });\n    }\n\n    this._data = data; // Save the coordinate system for transition animation when data changed\n\n    this._coordSys = coordSys;\n    this._stackedOnPoints = stackedOnPoints;\n    this._points = points;\n    this._step = step;\n  },\n  dispose: function () {},\n  highlight: function (seriesModel, ecModel, api, payload) {\n    var data = seriesModel.getData();\n    var dataIndex = modelUtil.queryDataIndex(data, payload);\n\n    if (!(dataIndex instanceof Array) && dataIndex != null && dataIndex >= 0) {\n      var symbol = data.getItemGraphicEl(dataIndex);\n\n      if (!symbol) {\n        // Create a temporary symbol if it is not exists\n        var pt = data.getItemLayout(dataIndex);\n\n        if (!pt) {\n          // Null data\n          return;\n        }\n\n        symbol = new SymbolClz(data, dataIndex);\n        symbol.position = pt;\n        symbol.setZ(seriesModel.get('zlevel'), seriesModel.get('z'));\n        symbol.ignore = isNaN(pt[0]) || isNaN(pt[1]);\n        symbol.__temp = true;\n        data.setItemGraphicEl(dataIndex, symbol); // Stop scale animation\n\n        symbol.stopSymbolAnimation(true);\n        this.group.add(symbol);\n      }\n\n      symbol.highlight();\n    } else {\n      // Highlight whole series\n      ChartView.prototype.highlight.call(this, seriesModel, ecModel, api, payload);\n    }\n  },\n  downplay: function (seriesModel, ecModel, api, payload) {\n    var data = seriesModel.getData();\n    var dataIndex = modelUtil.queryDataIndex(data, payload);\n\n    if (dataIndex != null && dataIndex >= 0) {\n      var symbol = data.getItemGraphicEl(dataIndex);\n\n      if (symbol) {\n        if (symbol.__temp) {\n          data.setItemGraphicEl(dataIndex, null);\n          this.group.remove(symbol);\n        } else {\n          symbol.downplay();\n        }\n      }\n    } else {\n      // FIXME\n      // can not downplay completely.\n      // Downplay whole series\n      ChartView.prototype.downplay.call(this, seriesModel, ecModel, api, payload);\n    }\n  },\n\n  /**\n   * @param {module:zrender/container/Group} group\n   * @param {Array.<Array.<number>>} points\n   * @private\n   */\n  _newPolyline: function (points) {\n    var polyline = this._polyline; // Remove previous created polyline\n\n    if (polyline) {\n      this._lineGroup.remove(polyline);\n    }\n\n    polyline = new Polyline({\n      shape: {\n        points: points\n      },\n      silent: true,\n      z2: 10\n    });\n\n    this._lineGroup.add(polyline);\n\n    this._polyline = polyline;\n    return polyline;\n  },\n\n  /**\n   * @param {module:zrender/container/Group} group\n   * @param {Array.<Array.<number>>} stackedOnPoints\n   * @param {Array.<Array.<number>>} points\n   * @private\n   */\n  _newPolygon: function (points, stackedOnPoints) {\n    var polygon = this._polygon; // Remove previous created polygon\n\n    if (polygon) {\n      this._lineGroup.remove(polygon);\n    }\n\n    polygon = new Polygon({\n      shape: {\n        points: points,\n        stackedOnPoints: stackedOnPoints\n      },\n      silent: true\n    });\n\n    this._lineGroup.add(polygon);\n\n    this._polygon = polygon;\n    return polygon;\n  },\n\n  /**\n   * @private\n   */\n  _getSymbolIgnoreFunc: function (data, coordSys) {\n    var categoryAxis = coordSys.getAxesByScale('ordinal')[0]; // `getLabelInterval` is provided by echarts/component/axis\n\n    if (categoryAxis && categoryAxis.isLabelIgnored) {\n      return zrUtil.bind(categoryAxis.isLabelIgnored, categoryAxis);\n    }\n  },\n\n  /**\n   * @private\n   */\n  // FIXME Two value axis\n  _updateAnimation: function (data, stackedOnPoints, coordSys, api, step) {\n    var polyline = this._polyline;\n    var polygon = this._polygon;\n    var seriesModel = data.hostModel;\n    var diff = lineAnimationDiff(this._data, data, this._stackedOnPoints, stackedOnPoints, this._coordSys, coordSys);\n    var current = diff.current;\n    var stackedOnCurrent = diff.stackedOnCurrent;\n    var next = diff.next;\n    var stackedOnNext = diff.stackedOnNext;\n\n    if (step) {\n      // TODO If stacked series is not step\n      current = turnPointsIntoStep(diff.current, coordSys, step);\n      stackedOnCurrent = turnPointsIntoStep(diff.stackedOnCurrent, coordSys, step);\n      next = turnPointsIntoStep(diff.next, coordSys, step);\n      stackedOnNext = turnPointsIntoStep(diff.stackedOnNext, coordSys, step);\n    } // `diff.current` is subset of `current` (which should be ensured by\n    // turnPointsIntoStep), so points in `__points` can be updated when\n    // points in `current` are update during animation.\n\n\n    polyline.shape.__points = diff.current;\n    polyline.shape.points = current;\n    graphic.updateProps(polyline, {\n      shape: {\n        points: next\n      }\n    }, seriesModel);\n\n    if (polygon) {\n      polygon.setShape({\n        points: current,\n        stackedOnPoints: stackedOnCurrent\n      });\n      graphic.updateProps(polygon, {\n        shape: {\n          points: next,\n          stackedOnPoints: stackedOnNext\n        }\n      }, seriesModel);\n    }\n\n    var updatedDataInfo = [];\n    var diffStatus = diff.status;\n\n    for (var i = 0; i < diffStatus.length; i++) {\n      var cmd = diffStatus[i].cmd;\n\n      if (cmd === '=') {\n        var el = data.getItemGraphicEl(diffStatus[i].idx1);\n\n        if (el) {\n          updatedDataInfo.push({\n            el: el,\n            ptIdx: i // Index of points\n\n          });\n        }\n      }\n    }\n\n    if (polyline.animators && polyline.animators.length) {\n      polyline.animators[0].during(function () {\n        for (var i = 0; i < updatedDataInfo.length; i++) {\n          var el = updatedDataInfo[i].el;\n          el.attr('position', polyline.shape.__points[updatedDataInfo[i].ptIdx]);\n        }\n      });\n    }\n  },\n  remove: function (ecModel) {\n    var group = this.group;\n    var oldData = this._data;\n\n    this._lineGroup.removeAll();\n\n    this._symbolDraw.remove(true); // Remove temporary created elements when highlighting\n\n\n    oldData && oldData.eachItemGraphicEl(function (el, idx) {\n      if (el.__temp) {\n        group.remove(el);\n        oldData.setItemGraphicEl(idx, null);\n      }\n    });\n    this._polyline = this._polygon = this._coordSys = this._points = this._stackedOnPoints = this._data = null;\n  }\n});\n\nmodule.exports = _default;\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/echarts/lib/chart/line/LineView.js\n// module id = cO/Q\n// module chunks = 1 2","var zrUtil = require(\"zrender/lib/core/util\");\n\n/**\n * Cartesian coordinate system\n * @module  echarts/coord/Cartesian\n *\n */\nfunction dimAxisMapper(dim) {\n  return this._axes[dim];\n}\n/**\n * @alias module:echarts/coord/Cartesian\n * @constructor\n */\n\n\nvar Cartesian = function (name) {\n  this._axes = {};\n  this._dimList = [];\n  /**\n   * @type {string}\n   */\n\n  this.name = name || '';\n};\n\nCartesian.prototype = {\n  constructor: Cartesian,\n  type: 'cartesian',\n\n  /**\n   * Get axis\n   * @param  {number|string} dim\n   * @return {module:echarts/coord/Cartesian~Axis}\n   */\n  getAxis: function (dim) {\n    return this._axes[dim];\n  },\n\n  /**\n   * Get axes list\n   * @return {Array.<module:echarts/coord/Cartesian~Axis>}\n   */\n  getAxes: function () {\n    return zrUtil.map(this._dimList, dimAxisMapper, this);\n  },\n\n  /**\n   * Get axes list by given scale type\n   */\n  getAxesByScale: function (scaleType) {\n    scaleType = scaleType.toLowerCase();\n    return zrUtil.filter(this.getAxes(), function (axis) {\n      return axis.scale.type === scaleType;\n    });\n  },\n\n  /**\n   * Add axis\n   * @param {module:echarts/coord/Cartesian.Axis}\n   */\n  addAxis: function (axis) {\n    var dim = axis.dim;\n    this._axes[dim] = axis;\n\n    this._dimList.push(dim);\n  },\n\n  /**\n   * Convert data to coord in nd space\n   * @param {Array.<number>|Object.<string, number>} val\n   * @return {Array.<number>|Object.<string, number>}\n   */\n  dataToCoord: function (val) {\n    return this._dataCoordConvert(val, 'dataToCoord');\n  },\n\n  /**\n   * Convert coord in nd space to data\n   * @param  {Array.<number>|Object.<string, number>} val\n   * @return {Array.<number>|Object.<string, number>}\n   */\n  coordToData: function (val) {\n    return this._dataCoordConvert(val, 'coordToData');\n  },\n  _dataCoordConvert: function (input, method) {\n    var dimList = this._dimList;\n    var output = input instanceof Array ? [] : {};\n\n    for (var i = 0; i < dimList.length; i++) {\n      var dim = dimList[i];\n      var axis = this._axes[dim];\n      output[dim] = axis[method](input[dim]);\n    }\n\n    return output;\n  }\n};\nvar _default = Cartesian;\nmodule.exports = _default;\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/echarts/lib/coord/cartesian/Cartesian.js\n// module id = ct4P\n// module chunks = 1 2","var Component = require(\"../../model/Component\");\n\nComponent.registerSubTypeDefaulter('dataZoom', function () {\n  // Default 'slider' when no type specified.\n  return 'slider';\n});\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/echarts/lib/component/dataZoom/typeDefaulter.js\n// module id = cuL/\n// module chunks = 1 2","var features = {};\n\nfunction register(name, ctor) {\n  features[name] = ctor;\n}\n\nfunction get(name) {\n  return features[name];\n}\n\nexports.register = register;\nexports.get = get;\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/echarts/lib/component/toolbox/featureManager.js\n// module id = dCQY\n// module chunks = 1 2","var graphic = require(\"../../util/graphic\");\n\nvar SymbolClz = require(\"./Symbol\");\n\n/**\n * @module echarts/chart/helper/SymbolDraw\n */\n\n/**\n * @constructor\n * @alias module:echarts/chart/helper/SymbolDraw\n * @param {module:zrender/graphic/Group} [symbolCtor]\n */\nfunction SymbolDraw(symbolCtor) {\n  this.group = new graphic.Group();\n  this._symbolCtor = symbolCtor || SymbolClz;\n}\n\nvar symbolDrawProto = SymbolDraw.prototype;\n\nfunction symbolNeedsDraw(data, idx, isIgnore) {\n  var point = data.getItemLayout(idx); // Is an object\n  // if (point && point.hasOwnProperty('point')) {\n  //     point = point.point;\n  // }\n\n  return point && !isNaN(point[0]) && !isNaN(point[1]) && !(isIgnore && isIgnore(idx)) && data.getItemVisual(idx, 'symbol') !== 'none';\n}\n/**\n * Update symbols draw by new data\n * @param {module:echarts/data/List} data\n * @param {Array.<boolean>} [isIgnore]\n */\n\n\nsymbolDrawProto.updateData = function (data, isIgnore) {\n  var group = this.group;\n  var seriesModel = data.hostModel;\n  var oldData = this._data;\n  var SymbolCtor = this._symbolCtor;\n  var seriesScope = {\n    itemStyle: seriesModel.getModel('itemStyle.normal').getItemStyle(['color']),\n    hoverItemStyle: seriesModel.getModel('itemStyle.emphasis').getItemStyle(),\n    symbolRotate: seriesModel.get('symbolRotate'),\n    symbolOffset: seriesModel.get('symbolOffset'),\n    hoverAnimation: seriesModel.get('hoverAnimation'),\n    labelModel: seriesModel.getModel('label.normal'),\n    hoverLabelModel: seriesModel.getModel('label.emphasis'),\n    cursorStyle: seriesModel.get('cursor')\n  };\n  data.diff(oldData).add(function (newIdx) {\n    var point = data.getItemLayout(newIdx);\n\n    if (symbolNeedsDraw(data, newIdx, isIgnore)) {\n      var symbolEl = new SymbolCtor(data, newIdx, seriesScope);\n      symbolEl.attr('position', point);\n      data.setItemGraphicEl(newIdx, symbolEl);\n      group.add(symbolEl);\n    }\n  }).update(function (newIdx, oldIdx) {\n    var symbolEl = oldData.getItemGraphicEl(oldIdx);\n    var point = data.getItemLayout(newIdx);\n\n    if (!symbolNeedsDraw(data, newIdx, isIgnore)) {\n      group.remove(symbolEl);\n      return;\n    }\n\n    if (!symbolEl) {\n      symbolEl = new SymbolCtor(data, newIdx);\n      symbolEl.attr('position', point);\n    } else {\n      symbolEl.updateData(data, newIdx, seriesScope);\n      graphic.updateProps(symbolEl, {\n        position: point\n      }, seriesModel);\n    } // Add back\n\n\n    group.add(symbolEl);\n    data.setItemGraphicEl(newIdx, symbolEl);\n  }).remove(function (oldIdx) {\n    var el = oldData.getItemGraphicEl(oldIdx);\n    el && el.fadeOut(function () {\n      group.remove(el);\n    });\n  }).execute();\n  this._data = data;\n};\n\nsymbolDrawProto.updateLayout = function () {\n  var data = this._data;\n\n  if (data) {\n    // Not use animation\n    data.eachItemGraphicEl(function (el, idx) {\n      var point = data.getItemLayout(idx);\n      el.attr('position', point);\n    });\n  }\n};\n\nsymbolDrawProto.remove = function (enableAnimation) {\n  var group = this.group;\n  var data = this._data;\n\n  if (data) {\n    if (enableAnimation) {\n      data.eachItemGraphicEl(function (el) {\n        el.fadeOut(function () {\n          group.remove(el);\n        });\n      });\n    } else {\n      group.removeAll();\n    }\n  }\n};\n\nvar _default = SymbolDraw;\nmodule.exports = _default;\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/echarts/lib/chart/helper/SymbolDraw.js\n// module id = dZZy\n// module chunks = 1 2","var zrUtil = require(\"zrender/lib/core/util\");\n\nvar modelUtil = require(\"../../util/model\");\n\nvar modelHelper = require(\"./modelHelper\");\n\nvar findPointFromSeries = require(\"./findPointFromSeries\");\n\nvar each = zrUtil.each;\nvar curry = zrUtil.curry;\nvar get = modelUtil.makeGetter();\n/**\n * Basic logic: check all axis, if they do not demand show/highlight,\n * then hide/downplay them.\n *\n * @param {Object} coordSysAxesInfo\n * @param {Object} payload\n * @param {string} [payload.currTrigger] 'click' | 'mousemove' | 'leave'\n * @param {Array.<number>} [payload.x] x and y, which are mandatory, specify a point to\n *              trigger axisPointer and tooltip.\n * @param {Array.<number>} [payload.y] x and y, which are mandatory, specify a point to\n *              trigger axisPointer and tooltip.\n * @param {Object} [payload.seriesIndex] finder, optional, restrict target axes.\n * @param {Object} [payload.dataIndex] finder, restrict target axes.\n * @param {Object} [payload.axesInfo] finder, restrict target axes.\n *        [{\n *          axisDim: 'x'|'y'|'angle'|...,\n *          axisIndex: ...,\n *          value: ...\n *        }, ...]\n * @param {Function} [payload.dispatchAction]\n * @param {Object} [payload.tooltipOption]\n * @param {Object|Array.<number>|Function} [payload.position] Tooltip position,\n *        which can be specified in dispatchAction\n * @param {module:echarts/model/Global} ecModel\n * @param {module:echarts/ExtensionAPI} api\n * @return {Object} content of event obj for echarts.connect.\n */\n\nfunction _default(payload, ecModel, api) {\n  var currTrigger = payload.currTrigger;\n  var point = [payload.x, payload.y];\n  var finder = payload;\n  var dispatchAction = payload.dispatchAction || zrUtil.bind(api.dispatchAction, api);\n  var coordSysAxesInfo = ecModel.getComponent('axisPointer').coordSysAxesInfo; // Pending\n  // See #6121. But we are not able to reproduce it yet.\n\n  if (!coordSysAxesInfo) {\n    return;\n  }\n\n  if (illegalPoint(point)) {\n    // Used in the default behavior of `connection`: use the sample seriesIndex\n    // and dataIndex. And also used in the tooltipView trigger.\n    point = findPointFromSeries({\n      seriesIndex: finder.seriesIndex,\n      // Do not use dataIndexInside from other ec instance.\n      // FIXME: auto detect it?\n      dataIndex: finder.dataIndex\n    }, ecModel).point;\n  }\n\n  var isIllegalPoint = illegalPoint(point); // Axis and value can be specified when calling dispatchAction({type: 'updateAxisPointer'}).\n  // Notice: In this case, it is difficult to get the `point` (which is necessary to show\n  // tooltip, so if point is not given, we just use the point found by sample seriesIndex\n  // and dataIndex.\n\n  var inputAxesInfo = finder.axesInfo;\n  var axesInfo = coordSysAxesInfo.axesInfo;\n  var shouldHide = currTrigger === 'leave' || illegalPoint(point);\n  var outputFinder = {};\n  var showValueMap = {};\n  var dataByCoordSys = {\n    list: [],\n    map: {}\n  };\n  var updaters = {\n    showPointer: curry(showPointer, showValueMap),\n    showTooltip: curry(showTooltip, dataByCoordSys)\n  }; // Process for triggered axes.\n\n  each(coordSysAxesInfo.coordSysMap, function (coordSys, coordSysKey) {\n    // If a point given, it must be contained by the coordinate system.\n    var coordSysContainsPoint = isIllegalPoint || coordSys.containPoint(point);\n    each(coordSysAxesInfo.coordSysAxesInfo[coordSysKey], function (axisInfo, key) {\n      var axis = axisInfo.axis;\n      var inputAxisInfo = findInputAxisInfo(inputAxesInfo, axisInfo); // If no inputAxesInfo, no axis is restricted.\n\n      if (!shouldHide && coordSysContainsPoint && (!inputAxesInfo || inputAxisInfo)) {\n        var val = inputAxisInfo && inputAxisInfo.value;\n\n        if (val == null && !isIllegalPoint) {\n          val = axis.pointToData(point);\n        }\n\n        val != null && processOnAxis(axisInfo, val, updaters, false, outputFinder);\n      }\n    });\n  }); // Process for linked axes.\n\n  var linkTriggers = {};\n  each(axesInfo, function (tarAxisInfo, tarKey) {\n    var linkGroup = tarAxisInfo.linkGroup; // If axis has been triggered in the previous stage, it should not be triggered by link.\n\n    if (linkGroup && !showValueMap[tarKey]) {\n      each(linkGroup.axesInfo, function (srcAxisInfo, srcKey) {\n        var srcValItem = showValueMap[srcKey]; // If srcValItem exist, source axis is triggered, so link to target axis.\n\n        if (srcAxisInfo !== tarAxisInfo && srcValItem) {\n          var val = srcValItem.value;\n          linkGroup.mapper && (val = tarAxisInfo.axis.scale.parse(linkGroup.mapper(val, makeMapperParam(srcAxisInfo), makeMapperParam(tarAxisInfo))));\n          linkTriggers[tarAxisInfo.key] = val;\n        }\n      });\n    }\n  });\n  each(linkTriggers, function (val, tarKey) {\n    processOnAxis(axesInfo[tarKey], val, updaters, true, outputFinder);\n  });\n  updateModelActually(showValueMap, axesInfo, outputFinder);\n  dispatchTooltipActually(dataByCoordSys, point, payload, dispatchAction);\n  dispatchHighDownActually(axesInfo, dispatchAction, api);\n  return outputFinder;\n}\n\nfunction processOnAxis(axisInfo, newValue, updaters, dontSnap, outputFinder) {\n  var axis = axisInfo.axis;\n\n  if (axis.scale.isBlank() || !axis.containData(newValue)) {\n    return;\n  }\n\n  if (!axisInfo.involveSeries) {\n    updaters.showPointer(axisInfo, newValue);\n    return;\n  } // Heavy calculation. So put it after axis.containData checking.\n\n\n  var payloadInfo = buildPayloadsBySeries(newValue, axisInfo);\n  var payloadBatch = payloadInfo.payloadBatch;\n  var snapToValue = payloadInfo.snapToValue; // Fill content of event obj for echarts.connect.\n  // By defualt use the first involved series data as a sample to connect.\n\n  if (payloadBatch[0] && outputFinder.seriesIndex == null) {\n    zrUtil.extend(outputFinder, payloadBatch[0]);\n  } // If no linkSource input, this process is for collecting link\n  // target, where snap should not be accepted.\n\n\n  if (!dontSnap && axisInfo.snap) {\n    if (axis.containData(snapToValue) && snapToValue != null) {\n      newValue = snapToValue;\n    }\n  }\n\n  updaters.showPointer(axisInfo, newValue, payloadBatch, outputFinder); // Tooltip should always be snapToValue, otherwise there will be\n  // incorrect \"axis value ~ series value\" mapping displayed in tooltip.\n\n  updaters.showTooltip(axisInfo, payloadInfo, snapToValue);\n}\n\nfunction buildPayloadsBySeries(value, axisInfo) {\n  var axis = axisInfo.axis;\n  var dim = axis.dim;\n  var snapToValue = value;\n  var payloadBatch = [];\n  var minDist = Number.MAX_VALUE;\n  var minDiff = -1;\n  each(axisInfo.seriesModels, function (series, idx) {\n    var dataDim = series.coordDimToDataDim(dim);\n    var seriesNestestValue;\n    var dataIndices;\n\n    if (series.getAxisTooltipData) {\n      var result = series.getAxisTooltipData(dataDim, value, axis);\n      dataIndices = result.dataIndices;\n      seriesNestestValue = result.nestestValue;\n    } else {\n      dataIndices = series.getData().indicesOfNearest(dataDim[0], value, // Add a threshold to avoid find the wrong dataIndex\n      // when data length is not same.\n      false, axis.type === 'category' ? 0.5 : null);\n\n      if (!dataIndices.length) {\n        return;\n      }\n\n      seriesNestestValue = series.getData().get(dataDim[0], dataIndices[0]);\n    }\n\n    if (seriesNestestValue == null || !isFinite(seriesNestestValue)) {\n      return;\n    }\n\n    var diff = value - seriesNestestValue;\n    var dist = Math.abs(diff); // Consider category case\n\n    if (dist <= minDist) {\n      if (dist < minDist || diff >= 0 && minDiff < 0) {\n        minDist = dist;\n        minDiff = diff;\n        snapToValue = seriesNestestValue;\n        payloadBatch.length = 0;\n      }\n\n      each(dataIndices, function (dataIndex) {\n        payloadBatch.push({\n          seriesIndex: series.seriesIndex,\n          dataIndexInside: dataIndex,\n          dataIndex: series.getData().getRawIndex(dataIndex)\n        });\n      });\n    }\n  });\n  return {\n    payloadBatch: payloadBatch,\n    snapToValue: snapToValue\n  };\n}\n\nfunction showPointer(showValueMap, axisInfo, value, payloadBatch) {\n  showValueMap[axisInfo.key] = {\n    value: value,\n    payloadBatch: payloadBatch\n  };\n}\n\nfunction showTooltip(dataByCoordSys, axisInfo, payloadInfo, value) {\n  var payloadBatch = payloadInfo.payloadBatch;\n  var axis = axisInfo.axis;\n  var axisModel = axis.model;\n  var axisPointerModel = axisInfo.axisPointerModel; // If no data, do not create anything in dataByCoordSys,\n  // whose length will be used to judge whether dispatch action.\n\n  if (!axisInfo.triggerTooltip || !payloadBatch.length) {\n    return;\n  }\n\n  var coordSysModel = axisInfo.coordSys.model;\n  var coordSysKey = modelHelper.makeKey(coordSysModel);\n  var coordSysItem = dataByCoordSys.map[coordSysKey];\n\n  if (!coordSysItem) {\n    coordSysItem = dataByCoordSys.map[coordSysKey] = {\n      coordSysId: coordSysModel.id,\n      coordSysIndex: coordSysModel.componentIndex,\n      coordSysType: coordSysModel.type,\n      coordSysMainType: coordSysModel.mainType,\n      dataByAxis: []\n    };\n    dataByCoordSys.list.push(coordSysItem);\n  }\n\n  coordSysItem.dataByAxis.push({\n    axisDim: axis.dim,\n    axisIndex: axisModel.componentIndex,\n    axisType: axisModel.type,\n    axisId: axisModel.id,\n    value: value,\n    // Caustion: viewHelper.getValueLabel is actually on \"view stage\", which\n    // depends that all models have been updated. So it should not be performed\n    // here. Considering axisPointerModel used here is volatile, which is hard\n    // to be retrieve in TooltipView, we prepare parameters here.\n    valueLabelOpt: {\n      precision: axisPointerModel.get('label.precision'),\n      formatter: axisPointerModel.get('label.formatter')\n    },\n    seriesDataIndices: payloadBatch.slice()\n  });\n}\n\nfunction updateModelActually(showValueMap, axesInfo, outputFinder) {\n  var outputAxesInfo = outputFinder.axesInfo = []; // Basic logic: If no 'show' required, 'hide' this axisPointer.\n\n  each(axesInfo, function (axisInfo, key) {\n    var option = axisInfo.axisPointerModel.option;\n    var valItem = showValueMap[key];\n\n    if (valItem) {\n      !axisInfo.useHandle && (option.status = 'show');\n      option.value = valItem.value; // For label formatter param and highlight.\n\n      option.seriesDataIndices = (valItem.payloadBatch || []).slice();\n    } // When always show (e.g., handle used), remain\n    // original value and status.\n    else {\n        // If hide, value still need to be set, consider\n        // click legend to toggle axis blank.\n        !axisInfo.useHandle && (option.status = 'hide');\n      } // If status is 'hide', should be no info in payload.\n\n\n    option.status === 'show' && outputAxesInfo.push({\n      axisDim: axisInfo.axis.dim,\n      axisIndex: axisInfo.axis.model.componentIndex,\n      value: option.value\n    });\n  });\n}\n\nfunction dispatchTooltipActually(dataByCoordSys, point, payload, dispatchAction) {\n  // Basic logic: If no showTip required, hideTip will be dispatched.\n  if (illegalPoint(point) || !dataByCoordSys.list.length) {\n    dispatchAction({\n      type: 'hideTip'\n    });\n    return;\n  } // In most case only one axis (or event one series is used). It is\n  // convinient to fetch payload.seriesIndex and payload.dataIndex\n  // dirtectly. So put the first seriesIndex and dataIndex of the first\n  // axis on the payload.\n\n\n  var sampleItem = ((dataByCoordSys.list[0].dataByAxis[0] || {}).seriesDataIndices || [])[0] || {};\n  dispatchAction({\n    type: 'showTip',\n    escapeConnect: true,\n    x: point[0],\n    y: point[1],\n    tooltipOption: payload.tooltipOption,\n    position: payload.position,\n    dataIndexInside: sampleItem.dataIndexInside,\n    dataIndex: sampleItem.dataIndex,\n    seriesIndex: sampleItem.seriesIndex,\n    dataByCoordSys: dataByCoordSys.list\n  });\n}\n\nfunction dispatchHighDownActually(axesInfo, dispatchAction, api) {\n  // FIXME\n  // highlight status modification shoule be a stage of main process?\n  // (Consider confilct (e.g., legend and axisPointer) and setOption)\n  var zr = api.getZr();\n  var highDownKey = 'axisPointerLastHighlights';\n  var lastHighlights = get(zr)[highDownKey] || {};\n  var newHighlights = get(zr)[highDownKey] = {}; // Update highlight/downplay status according to axisPointer model.\n  // Build hash map and remove duplicate incidentally.\n\n  each(axesInfo, function (axisInfo, key) {\n    var option = axisInfo.axisPointerModel.option;\n    option.status === 'show' && each(option.seriesDataIndices, function (batchItem) {\n      var key = batchItem.seriesIndex + ' | ' + batchItem.dataIndex;\n      newHighlights[key] = batchItem;\n    });\n  }); // Diff.\n\n  var toHighlight = [];\n  var toDownplay = [];\n  zrUtil.each(lastHighlights, function (batchItem, key) {\n    !newHighlights[key] && toDownplay.push(batchItem);\n  });\n  zrUtil.each(newHighlights, function (batchItem, key) {\n    !lastHighlights[key] && toHighlight.push(batchItem);\n  });\n  toDownplay.length && api.dispatchAction({\n    type: 'downplay',\n    escapeConnect: true,\n    batch: toDownplay\n  });\n  toHighlight.length && api.dispatchAction({\n    type: 'highlight',\n    escapeConnect: true,\n    batch: toHighlight\n  });\n}\n\nfunction findInputAxisInfo(inputAxesInfo, axisInfo) {\n  for (var i = 0; i < (inputAxesInfo || []).length; i++) {\n    var inputAxisInfo = inputAxesInfo[i];\n\n    if (axisInfo.axis.dim === inputAxisInfo.axisDim && axisInfo.axis.model.componentIndex === inputAxisInfo.axisIndex) {\n      return inputAxisInfo;\n    }\n  }\n}\n\nfunction makeMapperParam(axisInfo) {\n  var axisModel = axisInfo.axis.model;\n  var item = {};\n  var dim = item.axisDim = axisInfo.axis.dim;\n  item.axisIndex = item[dim + 'AxisIndex'] = axisModel.componentIndex;\n  item.axisName = item[dim + 'AxisName'] = axisModel.name;\n  item.axisId = item[dim + 'AxisId'] = axisModel.id;\n  return item;\n}\n\nfunction illegalPoint(point) {\n  return !point || point[0] == null || isNaN(point[0]) || point[1] == null || isNaN(point[1]);\n}\n\nmodule.exports = _default;\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/echarts/lib/component/axisPointer/axisTrigger.js\n// module id = dtW/\n// module chunks = 1 2","var graphic = require(\"../../util/graphic\");\n\nfunction setLabel(normalStyle, hoverStyle, itemModel, color, seriesModel, dataIndex, labelPositionOutside) {\n  var labelModel = itemModel.getModel('label.normal');\n  var hoverLabelModel = itemModel.getModel('label.emphasis');\n  graphic.setLabelStyle(normalStyle, hoverStyle, labelModel, hoverLabelModel, {\n    labelFetcher: seriesModel,\n    labelDataIndex: dataIndex,\n    defaultText: seriesModel.getRawValue(dataIndex),\n    isRectText: true,\n    autoColor: color\n  });\n  fixPosition(normalStyle);\n  fixPosition(hoverStyle);\n}\n\nfunction fixPosition(style, labelPositionOutside) {\n  if (style.textPosition === 'outside') {\n    style.textPosition = labelPositionOutside;\n  }\n}\n\nexports.setLabel = setLabel;\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/echarts/lib/chart/bar/helper.js\n// module id = dzlV\n// module chunks = 1 2","var zrUtil = require(\"zrender/lib/core/util\");\n\nvar axisDefault = require(\"./axisDefault\");\n\nvar ComponentModel = require(\"../model/Component\");\n\nvar _layout = require(\"../util/layout\");\n\nvar getLayoutParams = _layout.getLayoutParams;\nvar mergeLayoutParam = _layout.mergeLayoutParam;\n// FIXME axisType is fixed ?\nvar AXIS_TYPES = ['value', 'category', 'time', 'log'];\n/**\n * Generate sub axis model class\n * @param {string} axisName 'x' 'y' 'radius' 'angle' 'parallel'\n * @param {module:echarts/model/Component} BaseAxisModelClass\n * @param {Function} axisTypeDefaulter\n * @param {Object} [extraDefaultOption]\n */\n\nfunction _default(axisName, BaseAxisModelClass, axisTypeDefaulter, extraDefaultOption) {\n  zrUtil.each(AXIS_TYPES, function (axisType) {\n    BaseAxisModelClass.extend({\n      type: axisName + 'Axis.' + axisType,\n      mergeDefaultAndTheme: function (option, ecModel) {\n        var layoutMode = this.layoutMode;\n        var inputPositionParams = layoutMode ? getLayoutParams(option) : {};\n        var themeModel = ecModel.getTheme();\n        zrUtil.merge(option, themeModel.get(axisType + 'Axis'));\n        zrUtil.merge(option, this.getDefaultOption());\n        option.type = axisTypeDefaulter(axisName, option);\n\n        if (layoutMode) {\n          mergeLayoutParam(option, inputPositionParams, layoutMode);\n        }\n      },\n      defaultOption: zrUtil.mergeAll([{}, axisDefault[axisType + 'Axis'], extraDefaultOption], true)\n    });\n  });\n  ComponentModel.registerSubTypeDefaulter(axisName + 'Axis', zrUtil.curry(axisTypeDefaulter, axisName));\n}\n\nmodule.exports = _default;\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/echarts/lib/coord/axisModelCreator.js\n// module id = eH0a\n// module chunks = 1 2","var _config = require(\"../../config\");\n\nvar __DEV__ = _config.__DEV__;\n\nvar echarts = require(\"../../echarts\");\n\nvar zrUtil = require(\"zrender/lib/core/util\");\n\nvar graphic = require(\"../../util/graphic\");\n\nvar _helper = require(\"./helper\");\n\nvar setLabel = _helper.setLabel;\n\nvar Model = require(\"../../model/Model\");\n\nvar barItemStyle = require(\"./barItemStyle\");\n\nvar BAR_BORDER_WIDTH_QUERY = ['itemStyle', 'normal', 'barBorderWidth']; // FIXME\n// Just for compatible with ec2.\n\nzrUtil.extend(Model.prototype, barItemStyle);\n\nvar _default = echarts.extendChartView({\n  type: 'bar',\n  render: function (seriesModel, ecModel, api) {\n    var coordinateSystemType = seriesModel.get('coordinateSystem');\n\n    if (coordinateSystemType === 'cartesian2d' || coordinateSystemType === 'polar') {\n      this._render(seriesModel, ecModel, api);\n    } else {}\n\n    return this.group;\n  },\n  dispose: zrUtil.noop,\n  _render: function (seriesModel, ecModel, api) {\n    var group = this.group;\n    var data = seriesModel.getData();\n    var oldData = this._data;\n    var coord = seriesModel.coordinateSystem;\n    var baseAxis = coord.getBaseAxis();\n    var isHorizontalOrRadial;\n\n    if (coord.type === 'cartesian2d') {\n      isHorizontalOrRadial = baseAxis.isHorizontal();\n    } else if (coord.type === 'polar') {\n      isHorizontalOrRadial = baseAxis.dim === 'angle';\n    }\n\n    var animationModel = seriesModel.isAnimationEnabled() ? seriesModel : null;\n    data.diff(oldData).add(function (dataIndex) {\n      if (!data.hasValue(dataIndex)) {\n        return;\n      }\n\n      var itemModel = data.getItemModel(dataIndex);\n      var layout = getLayout[coord.type](data, dataIndex, itemModel);\n      var el = elementCreator[coord.type](data, dataIndex, itemModel, layout, isHorizontalOrRadial, animationModel);\n      data.setItemGraphicEl(dataIndex, el);\n      group.add(el);\n      updateStyle(el, data, dataIndex, itemModel, layout, seriesModel, isHorizontalOrRadial, coord.type === 'polar');\n    }).update(function (newIndex, oldIndex) {\n      var el = oldData.getItemGraphicEl(oldIndex);\n\n      if (!data.hasValue(newIndex)) {\n        group.remove(el);\n        return;\n      }\n\n      var itemModel = data.getItemModel(newIndex);\n      var layout = getLayout[coord.type](data, newIndex, itemModel);\n\n      if (el) {\n        graphic.updateProps(el, {\n          shape: layout\n        }, animationModel, newIndex);\n      } else {\n        el = elementCreator[coord.type](data, newIndex, itemModel, layout, isHorizontalOrRadial, animationModel, true);\n      }\n\n      data.setItemGraphicEl(newIndex, el); // Add back\n\n      group.add(el);\n      updateStyle(el, data, newIndex, itemModel, layout, seriesModel, isHorizontalOrRadial, coord.type === 'polar');\n    }).remove(function (dataIndex) {\n      var el = oldData.getItemGraphicEl(dataIndex);\n\n      if (coord.type === 'cartesian2d') {\n        el && removeRect(dataIndex, animationModel, el);\n      } else {\n        el && removeSector(dataIndex, animationModel, el);\n      }\n    }).execute();\n    this._data = data;\n  },\n  remove: function (ecModel, api) {\n    var group = this.group;\n    var data = this._data;\n\n    if (ecModel.get('animation')) {\n      if (data) {\n        data.eachItemGraphicEl(function (el) {\n          if (el.type === 'sector') {\n            removeSector(el.dataIndex, ecModel, el);\n          } else {\n            removeRect(el.dataIndex, ecModel, el);\n          }\n        });\n      }\n    } else {\n      group.removeAll();\n    }\n  }\n});\n\nvar elementCreator = {\n  cartesian2d: function (data, dataIndex, itemModel, layout, isHorizontal, animationModel, isUpdate) {\n    var rect = new graphic.Rect({\n      shape: zrUtil.extend({}, layout)\n    }); // Animation\n\n    if (animationModel) {\n      var rectShape = rect.shape;\n      var animateProperty = isHorizontal ? 'height' : 'width';\n      var animateTarget = {};\n      rectShape[animateProperty] = 0;\n      animateTarget[animateProperty] = layout[animateProperty];\n      graphic[isUpdate ? 'updateProps' : 'initProps'](rect, {\n        shape: animateTarget\n      }, animationModel, dataIndex);\n    }\n\n    return rect;\n  },\n  polar: function (data, dataIndex, itemModel, layout, isRadial, animationModel, isUpdate) {\n    var sector = new graphic.Sector({\n      shape: zrUtil.extend({}, layout)\n    }); // Animation\n\n    if (animationModel) {\n      var sectorShape = sector.shape;\n      var animateProperty = isRadial ? 'r' : 'endAngle';\n      var animateTarget = {};\n      sectorShape[animateProperty] = isRadial ? 0 : layout.startAngle;\n      animateTarget[animateProperty] = layout[animateProperty];\n      graphic[isUpdate ? 'updateProps' : 'initProps'](sector, {\n        shape: animateTarget\n      }, animationModel, dataIndex);\n    }\n\n    return sector;\n  }\n};\n\nfunction removeRect(dataIndex, animationModel, el) {\n  // Not show text when animating\n  el.style.text = null;\n  graphic.updateProps(el, {\n    shape: {\n      width: 0\n    }\n  }, animationModel, dataIndex, function () {\n    el.parent && el.parent.remove(el);\n  });\n}\n\nfunction removeSector(dataIndex, animationModel, el) {\n  // Not show text when animating\n  el.style.text = null;\n  graphic.updateProps(el, {\n    shape: {\n      r: el.shape.r0\n    }\n  }, animationModel, dataIndex, function () {\n    el.parent && el.parent.remove(el);\n  });\n}\n\nvar getLayout = {\n  cartesian2d: function (data, dataIndex, itemModel) {\n    var layout = data.getItemLayout(dataIndex);\n    var fixedLineWidth = getLineWidth(itemModel, layout); // fix layout with lineWidth\n\n    var signX = layout.width > 0 ? 1 : -1;\n    var signY = layout.height > 0 ? 1 : -1;\n    return {\n      x: layout.x + signX * fixedLineWidth / 2,\n      y: layout.y + signY * fixedLineWidth / 2,\n      width: layout.width - signX * fixedLineWidth,\n      height: layout.height - signY * fixedLineWidth\n    };\n  },\n  polar: function (data, dataIndex, itemModel) {\n    var layout = data.getItemLayout(dataIndex);\n    return {\n      cx: layout.cx,\n      cy: layout.cy,\n      r0: layout.r0,\n      r: layout.r,\n      startAngle: layout.startAngle,\n      endAngle: layout.endAngle\n    };\n  }\n};\n\nfunction updateStyle(el, data, dataIndex, itemModel, layout, seriesModel, isHorizontal, isPolar) {\n  var color = data.getItemVisual(dataIndex, 'color');\n  var opacity = data.getItemVisual(dataIndex, 'opacity');\n  var itemStyleModel = itemModel.getModel('itemStyle.normal');\n  var hoverStyle = itemModel.getModel('itemStyle.emphasis').getBarItemStyle();\n\n  if (!isPolar) {\n    el.setShape('r', itemStyleModel.get('barBorderRadius') || 0);\n  }\n\n  el.useStyle(zrUtil.defaults({\n    fill: color,\n    opacity: opacity\n  }, itemStyleModel.getBarItemStyle()));\n  var cursorStyle = itemModel.getShallow('cursor');\n  cursorStyle && el.attr('cursor', cursorStyle);\n  var labelPositionOutside = isHorizontal ? layout.height > 0 ? 'bottom' : 'top' : layout.width > 0 ? 'left' : 'right';\n\n  if (!isPolar) {\n    setLabel(el.style, hoverStyle, itemModel, color, seriesModel, dataIndex, labelPositionOutside);\n  }\n\n  graphic.setHoverStyle(el, hoverStyle);\n} // In case width or height are too small.\n\n\nfunction getLineWidth(itemModel, rawLayout) {\n  var lineWidth = itemModel.get(BAR_BORDER_WIDTH_QUERY) || 0;\n  return Math.min(lineWidth, Math.abs(rawLayout.width), Math.abs(rawLayout.height));\n}\n\nmodule.exports = _default;\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/echarts/lib/chart/bar/BarView.js\n// module id = eHPu\n// module chunks = 1 2","var zrUtil = require(\"zrender/lib/core/util\");\n\nvar ComponentModel = require(\"../../model/Component\");\n\nvar axisModelCreator = require(\"../axisModelCreator\");\n\nvar axisModelCommonMixin = require(\"../axisModelCommonMixin\");\n\nvar AxisModel = ComponentModel.extend({\n  type: 'cartesian2dAxis',\n\n  /**\n   * @type {module:echarts/coord/cartesian/Axis2D}\n   */\n  axis: null,\n\n  /**\n   * @override\n   */\n  init: function () {\n    AxisModel.superApply(this, 'init', arguments);\n    this.resetRange();\n  },\n\n  /**\n   * @override\n   */\n  mergeOption: function () {\n    AxisModel.superApply(this, 'mergeOption', arguments);\n    this.resetRange();\n  },\n\n  /**\n   * @override\n   */\n  restoreData: function () {\n    AxisModel.superApply(this, 'restoreData', arguments);\n    this.resetRange();\n  },\n\n  /**\n   * @override\n   * @return {module:echarts/model/Component}\n   */\n  getCoordSysModel: function () {\n    return this.ecModel.queryComponents({\n      mainType: 'grid',\n      index: this.option.gridIndex,\n      id: this.option.gridId\n    })[0];\n  }\n});\n\nfunction getAxisType(axisDim, option) {\n  // Default axis with data is category axis\n  return option.type || (option.data ? 'category' : 'value');\n}\n\nzrUtil.merge(AxisModel.prototype, axisModelCommonMixin);\nvar extraOption = {\n  // gridIndex: 0,\n  // gridId: '',\n  // Offset is for multiple axis on the same position\n  offset: 0\n};\naxisModelCreator('x', AxisModel, getAxisType, extraOption);\naxisModelCreator('y', AxisModel, getAxisType, extraOption);\nvar _default = AxisModel;\nmodule.exports = _default;\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/echarts/lib/coord/cartesian/AxisModel.js\n// module id = ecfp\n// module chunks = 1 2","'use strict';\nvar $defineProperty = require('./_object-dp');\nvar createDesc = require('./_property-desc');\n\nmodule.exports = function (object, index, value) {\n  if (index in object) $defineProperty.f(object, index, createDesc(0, value));\n  else object[index] = value;\n};\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/core-js/library/modules/_create-property.js\n// module id = fBQ2\n// module chunks = 2","var ComponentView = require(\"../../view/Component\");\n\nvar _default = ComponentView.extend({\n  type: 'dataZoom',\n  render: function (dataZoomModel, ecModel, api, payload) {\n    this.dataZoomModel = dataZoomModel;\n    this.ecModel = ecModel;\n    this.api = api;\n  },\n\n  /**\n   * Find the first target coordinate system.\n   *\n   * @protected\n   * @return {Object} {\n   *                   grid: [\n   *                       {model: coord0, axisModels: [axis1, axis3], coordIndex: 1},\n   *                       {model: coord1, axisModels: [axis0, axis2], coordIndex: 0},\n   *                       ...\n   *                   ],  // cartesians must not be null/undefined.\n   *                   polar: [\n   *                       {model: coord0, axisModels: [axis4], coordIndex: 0},\n   *                       ...\n   *                   ],  // polars must not be null/undefined.\n   *                   singleAxis: [\n   *                       {model: coord0, axisModels: [], coordIndex: 0}\n   *                   ]\n   */\n  getTargetCoordInfo: function () {\n    var dataZoomModel = this.dataZoomModel;\n    var ecModel = this.ecModel;\n    var coordSysLists = {};\n    dataZoomModel.eachTargetAxis(function (dimNames, axisIndex) {\n      var axisModel = ecModel.getComponent(dimNames.axis, axisIndex);\n\n      if (axisModel) {\n        var coordModel = axisModel.getCoordSysModel();\n        coordModel && save(coordModel, axisModel, coordSysLists[coordModel.mainType] || (coordSysLists[coordModel.mainType] = []), coordModel.componentIndex);\n      }\n    }, this);\n\n    function save(coordModel, axisModel, store, coordIndex) {\n      var item;\n\n      for (var i = 0; i < store.length; i++) {\n        if (store[i].model === coordModel) {\n          item = store[i];\n          break;\n        }\n      }\n\n      if (!item) {\n        store.push(item = {\n          model: coordModel,\n          axisModels: [],\n          coordIndex: coordIndex\n        });\n      }\n\n      item.axisModels.push(axisModel);\n    }\n\n    return coordSysLists;\n  }\n});\n\nmodule.exports = _default;\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/echarts/lib/component/dataZoom/DataZoomView.js\n// module id = ilLo\n// module chunks = 1 2","var _config = require(\"../../config\");\n\nvar __DEV__ = _config.__DEV__;\n\nvar createListFromArray = require(\"../helper/createListFromArray\");\n\nvar SeriesModel = require(\"../../model/Series\");\n\nvar _default = SeriesModel.extend({\n  type: 'series.line',\n  dependencies: ['grid', 'polar'],\n  getInitialData: function (option, ecModel) {\n    return createListFromArray(option.data, this, ecModel);\n  },\n  defaultOption: {\n    zlevel: 0,\n    // 一级层叠\n    z: 2,\n    // 二级层叠\n    coordinateSystem: 'cartesian2d',\n    legendHoverLink: true,\n    hoverAnimation: true,\n    // stack: null\n    // xAxisIndex: 0,\n    // yAxisIndex: 0,\n    // polarIndex: 0,\n    // If clip the overflow value\n    clipOverflow: true,\n    // cursor: null,\n    label: {\n      normal: {\n        position: 'top'\n      }\n    },\n    // itemStyle: {\n    //     normal: {},\n    //     emphasis: {}\n    // },\n    lineStyle: {\n      normal: {\n        width: 2,\n        type: 'solid'\n      }\n    },\n    // areaStyle: {},\n    // false, 'start', 'end', 'middle'\n    step: false,\n    // Disabled if step is true\n    smooth: false,\n    smoothMonotone: null,\n    // 拐点图形类型\n    symbol: 'emptyCircle',\n    // 拐点图形大小\n    symbolSize: 4,\n    // 拐点图形旋转控制\n    symbolRotate: null,\n    // 是否显示 symbol, 只有在 tooltip hover 的时候显示\n    showSymbol: true,\n    // 标志图形默认只有主轴显示（随主轴标签间隔隐藏策略）\n    showAllSymbol: false,\n    // 是否连接断点\n    connectNulls: false,\n    // 数据过滤，'average', 'max', 'min', 'sum'\n    sampling: 'none',\n    animationEasing: 'linear',\n    // Disable progressive\n    progressive: 0,\n    hoverLayerThreshold: Infinity\n  }\n});\n\nmodule.exports = _default;\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/echarts/lib/chart/line/LineSeries.js\n// module id = jMTz\n// module chunks = 1 2","var zrUtil = require(\"zrender/lib/core/util\");\n\n/**\n * @param {Object} opt {labelInside}\n * @return {Object} {\n *  position, rotation, labelDirection, labelOffset,\n *  tickDirection, labelRotate, labelInterval, z2\n * }\n */\nfunction layout(gridModel, axisModel, opt) {\n  opt = opt || {};\n  var grid = gridModel.coordinateSystem;\n  var axis = axisModel.axis;\n  var layout = {};\n  var rawAxisPosition = axis.position;\n  var axisPosition = axis.onZero ? 'onZero' : rawAxisPosition;\n  var axisDim = axis.dim;\n  var rect = grid.getRect();\n  var rectBound = [rect.x, rect.x + rect.width, rect.y, rect.y + rect.height];\n  var idx = {\n    left: 0,\n    right: 1,\n    top: 0,\n    bottom: 1,\n    onZero: 2\n  };\n  var axisOffset = axisModel.get('offset') || 0;\n  var posBound = axisDim === 'x' ? [rectBound[2] - axisOffset, rectBound[3] + axisOffset] : [rectBound[0] - axisOffset, rectBound[1] + axisOffset];\n\n  if (axis.onZero) {\n    var otherAxis = grid.getAxis(axisDim === 'x' ? 'y' : 'x', axis.onZeroAxisIndex);\n    var onZeroCoord = otherAxis.toGlobalCoord(otherAxis.dataToCoord(0));\n    posBound[idx['onZero']] = Math.max(Math.min(onZeroCoord, posBound[1]), posBound[0]);\n  } // Axis position\n\n\n  layout.position = [axisDim === 'y' ? posBound[idx[axisPosition]] : rectBound[0], axisDim === 'x' ? posBound[idx[axisPosition]] : rectBound[3]]; // Axis rotation\n\n  layout.rotation = Math.PI / 2 * (axisDim === 'x' ? 0 : 1); // Tick and label direction, x y is axisDim\n\n  var dirMap = {\n    top: -1,\n    bottom: 1,\n    left: -1,\n    right: 1\n  };\n  layout.labelDirection = layout.tickDirection = layout.nameDirection = dirMap[rawAxisPosition];\n  layout.labelOffset = axis.onZero ? posBound[idx[rawAxisPosition]] - posBound[idx['onZero']] : 0;\n\n  if (axisModel.get('axisTick.inside')) {\n    layout.tickDirection = -layout.tickDirection;\n  }\n\n  if (zrUtil.retrieve(opt.labelInside, axisModel.get('axisLabel.inside'))) {\n    layout.labelDirection = -layout.labelDirection;\n  } // Special label rotation\n\n\n  var labelRotate = axisModel.get('axisLabel.rotate');\n  layout.labelRotate = axisPosition === 'top' ? -labelRotate : labelRotate; // label interval when auto mode.\n\n  layout.labelInterval = axis.getLabelInterval(); // Over splitLine and splitArea\n\n  layout.z2 = 1;\n  return layout;\n}\n\nexports.layout = layout;\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/echarts/lib/component/axis/cartesianAxisHelper.js\n// module id = koEO\n// module chunks = 1 2","require(\"./dataZoom/typeDefaulter\");\n\nrequire(\"./dataZoom/DataZoomModel\");\n\nrequire(\"./dataZoom/DataZoomView\");\n\nrequire(\"./dataZoom/SelectZoomModel\");\n\nrequire(\"./dataZoom/SelectZoomView\");\n\nrequire(\"./dataZoom/dataZoomProcessor\");\n\nrequire(\"./dataZoom/dataZoomAction\");\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/echarts/lib/component/dataZoomSelect.js\n// module id = l2wH\n// module chunks = 1 2","<template>\r\n    <div class=\"line1\">\r\n        <div id=\"line1\" class=\"\" style=\"width: 90%;height:450px;\"></div>\r\n    </div>\r\n</template>\r\n\r\n<script>\r\n    import echarts from 'echarts/lib/echarts';\r\n    // 引入柱状图\r\n    import 'echarts/lib/chart/bar';\r\n    import 'echarts/lib/chart/line';\r\n    import 'echarts/lib/component/title';\r\n    import 'echarts/lib/component/legend';\r\n    import 'echarts/lib/component/toolbox';\r\n    import 'echarts/lib/component/markPoint';\r\n    import 'echarts/lib/component/tooltip';\r\n    export default {\r\n        mounted(){\r\n            this.myChart = echarts.init(document.getElementById('line1'));\r\n            this.initData();\r\n        },\r\n        props: ['sevenDate', 'sevenDay'],\r\n        methods: {\r\n            initData(){\r\n                const colors = ['#5793f3', '#675bba', '#d14a61'];\r\n                const option = {\r\n                    color: colors,\r\n                    title: {\r\n                        text: '走势图',\r\n                        subtext: ''\r\n                    },\r\n                    tooltip: {\r\n                        trigger: 'axis'\r\n                    },\r\n                    legend: {\r\n                        data:['新注册用户', '新增订单', '新增管理员']\r\n                    },\r\n                    toolbox: {\r\n                        show: true,\r\n                        feature: {\r\n                            dataZoom: {\r\n                                yAxisIndex: 'none'\r\n                            },\r\n                            dataView: {readOnly: false},\r\n                            magicType: {type: ['bar', 'line']},\r\n                            restore: {},\r\n                        }\r\n                    },\r\n                    xAxis:  {\r\n                        type: 'category',\r\n                        boundaryGap: false,\r\n                        data: this.sevenDay\r\n                    },\r\n                    yAxis: [\r\n                        {\r\n                          type: 'value',\r\n                          name: '用户',\r\n                          min: 0,\r\n                          max: 200,\r\n                          position: 'left',\r\n                          axisLine: {\r\n                              lineStyle: {\r\n                                  color: '#999'\r\n                              }\r\n                          },\r\n                          axisLabel: {\r\n                              formatter: '{value}'\r\n                          }\r\n                        },\r\n                        {\r\n                          type: 'value',\r\n                          name: '订单',\r\n                          min: 0,\r\n                          max: 200,\r\n                          position: 'right',\r\n                          axisLine: {\r\n                              lineStyle: {\r\n                                  color: '#999'\r\n                              }\r\n                          },\r\n                          axisLabel: {\r\n                              formatter: '{value}'\r\n                          }\r\n                        },\r\n                    ],\r\n                    series: [\r\n                        {\r\n                            name:'新注册用户',\r\n                            type:'line',\r\n                            data:this.sevenDate[0],\r\n                            yAxisIndex: 1,\r\n                            markPoint: {\r\n                                data: [\r\n                                    {type: 'max', name: '最大值'},\r\n                                    {type: 'min', name: '最小值'}\r\n                                ]\r\n                            },\r\n                        },\r\n                        {\r\n                            name:'新增订单',\r\n                            type:'line',\r\n                            data:this.sevenDate[1],\r\n                            yAxisIndex: 1,\r\n                            markPoint: {\r\n                                data: [\r\n                                    {type: 'max', name: '最大值'},\r\n                                    {type: 'min', name: '最小值'}\r\n                                ]\r\n                            },\r\n                        },\r\n                        {\r\n                            name:'新增管理员',\r\n                            type:'line',\r\n                            data:this.sevenDate[2],\r\n                            yAxisIndex: 1,\r\n                            markPoint: {\r\n                                data: [\r\n                                    {type: 'max', name: '最大值'},\r\n                                    {type: 'min', name: '最小值'}\r\n                                ]\r\n                            },\r\n                        }\r\n                    ]\r\n              };\r\n                this.myChart.setOption(option);\r\n            }\r\n        },\r\n        watch: {\r\n            sevenDate: function (){\r\n                this.initData()\r\n            },\r\n            sevenDay: function (){\r\n                this.initData()\r\n            }\r\n        }\r\n    }\r\n</script>\r\n\r\n<style lang=\"less\">\r\n\t@import '../style/mixin';\r\n    .line1{\r\n        display: flex;\r\n        justify-content: center;\r\n    }\r\n</style>\r\n\n\n\n// WEBPACK FOOTER //\n// src/components/tendency.vue","var render = function () {var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;return _vm._m(0)}\nvar staticRenderFns = [function () {var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;return _c('div',{staticClass:\"line1\"},[_c('div',{staticStyle:{\"width\":\"90%\",\"height\":\"450px\"},attrs:{\"id\":\"line1\"}})])}]\nvar esExports = { render: render, staticRenderFns: staticRenderFns }\nexport default esExports\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/vue-loader/lib/template-compiler?{\"id\":\"data-v-05531745\",\"hasScoped\":false,\"transformToRequire\":{\"video\":[\"src\",\"poster\"],\"source\":\"src\",\"img\":\"src\",\"image\":\"xlink:href\"},\"buble\":{\"transforms\":{}}}!./node_modules/vue-loader/lib/selector.js?type=template&index=0!./src/components/tendency.vue\n// module id = null\n// module chunks = ","function injectStyle (ssrContext) {\n  require(\"!!../../node_modules/extract-text-webpack-plugin/dist/loader.js?{\\\"omit\\\":1,\\\"remove\\\":true}!vue-style-loader!css-loader?{\\\"sourceMap\\\":true}!../../node_modules/vue-loader/lib/style-compiler/index?{\\\"vue\\\":true,\\\"id\\\":\\\"data-v-05531745\\\",\\\"scoped\\\":false,\\\"hasInlineConfig\\\":false}!less-loader?{\\\"sourceMap\\\":true}!../../node_modules/vue-loader/lib/selector?type=styles&index=0!./tendency.vue\")\n}\nvar normalizeComponent = require(\"!../../node_modules/vue-loader/lib/component-normalizer\")\n/* script */\nexport * from \"!!babel-loader!../../node_modules/vue-loader/lib/selector?type=script&index=0!./tendency.vue\"\nimport __vue_script__ from \"!!babel-loader!../../node_modules/vue-loader/lib/selector?type=script&index=0!./tendency.vue\"\n/* template */\nimport __vue_template__ from \"!!../../node_modules/vue-loader/lib/template-compiler/index?{\\\"id\\\":\\\"data-v-05531745\\\",\\\"hasScoped\\\":false,\\\"transformToRequire\\\":{\\\"video\\\":[\\\"src\\\",\\\"poster\\\"],\\\"source\\\":\\\"src\\\",\\\"img\\\":\\\"src\\\",\\\"image\\\":\\\"xlink:href\\\"},\\\"buble\\\":{\\\"transforms\\\":{}}}!../../node_modules/vue-loader/lib/selector?type=template&index=0!./tendency.vue\"\n/* template functional */\nvar __vue_template_functional__ = false\n/* styles */\nvar __vue_styles__ = injectStyle\n/* scopeId */\nvar __vue_scopeId__ = null\n/* moduleIdentifier (server only) */\nvar __vue_module_identifier__ = null\nvar Component = normalizeComponent(\n  __vue_script__,\n  __vue_template__,\n  __vue_template_functional__,\n  __vue_styles__,\n  __vue_scopeId__,\n  __vue_module_identifier__\n)\n\nexport default Component.exports\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/components/tendency.vue\n// module id = null\n// module chunks = ","<template>\n    <div>\n        <head-top></head-top>\n        <div class=\"homepageDiv\">\n            <img src=\"../assets/AI.png\" class=\"homepageDivPNG\">\n        </div>\n    </div>\n</template>\n\n<script>\nimport headTop from '../components/headTop'\nimport tendency from '../components/tendency'\nimport dtime from 'time-formater'\nimport {userCount, orderCount, getUserCount, getOrderCount, adminDayCount, adminCount} from '@/api/getData'\nexport default {\n    \tdata () {\n    \t\treturn {\n    \t\t\tuserCount: null,\n    \t\t\torderCount: null,\n      adminCount: null,\n      allUserCount: null,\n      allOrderCount: null,\n      allAdminCount: null,\n    \t\t\tsevenDay: [],\n    \t\t\tsevenDate: [[], [], []]\n    \t\t}\n    \t},\n    \tcomponents: {\n    \t\theadTop,\n    \t\ttendency\n    \t},\n    \tmounted () {\n    \t\tthis.initData()\n    \t\tfor (let i = 6; i > -1; i--) {\n    \t\t\tconst date = dtime(new Date().getTime() - 86400000 * i).format('YYYY-MM-DD')\n    \t\t\tthis.sevenDay.push(date)\n    \t\t}\n    \t\tthis.getSevenData()\n    \t},\n  computed: {\n\n  },\n    \tmethods: {\n    \t\tasync initData () {\n    \t\t\tconst today = dtime().format('YYYY-MM-DD')\n    \t\t\tPromise.all([userCount(today), orderCount(today), adminDayCount(today), getUserCount(), getOrderCount(), adminCount()])\n    \t\t\t.then(res => {\n    \t\t\t\tthis.userCount = res[0].count\n    \t\t\t\tthis.orderCount = res[1].count\n          this.adminCount = res[2].count\n          this.allUserCount = res[3].count\n          this.allOrderCount = res[4].count\n          this.allAdminCount = res[5].count\n    \t\t\t}).catch(err => {\n    \t\t\t\tconsole.log(err)\n    \t\t\t})\n    \t\t},\n    \t\tasync getSevenData () {\n    \t\t\tconst apiArr = [[], [], []]\n    \t\t\tthis.sevenDay.forEach(item => {\n    \t\t\t\tapiArr[0].push(userCount(item))\n    \t\t\t\tapiArr[1].push(orderCount(item))\n        apiArr[2].push(adminDayCount(item))\n    \t\t\t})\n    \t\t\tconst promiseArr = [...apiArr[0], ...apiArr[1], ...apiArr[2]]\n    \t\t\tPromise.all(promiseArr).then(res => {\n    \t\t\t\tconst resArr = [[], [], []]\n        res.forEach((item, index) => {\n          if (item.status == 1) {\n            resArr[Math.floor(index / 7)].push(item.count)\n          }\n        })\n        this.sevenDate = resArr\n    \t\t\t}).catch(err => {\n    \t\t\t\tconsole.log(err)\n    \t\t\t})\n    \t\t}\n    \t}\n}\n</script>\n\n<style lang=\"less\">\n\t@import '../style/mixin';\n\t.data_section{\n\t\tpadding: 20px;\n\t\tmargin-bottom: 40px;\n\t\t.section_title{\n\t\t\ttext-align: center;\n\t\t\tfont-size: 30px;\n\t\t\tmargin-bottom: 10px;\n\t\t}\n\t\t.data_list{\n\t\t\ttext-align: center;\n\t\t\tfont-size: 14px;\n\t\t\tcolor: #666;\n            border-radius: 6px;\n            background: #E5E9F2;\n            .data_num{\n                color: #333;\n                font-size: 26px;\n\n            }\n            .head{\n                border-radius: 6px;\n                font-size: 22px;\n                padding: 4px 0;\n                color: #fff;\n                display: inline-block;\n            }\n        }\n        .today_head{\n            background: #FF9800;\n        }\n        .all_head{\n            background: #20A0FF;\n        }\n\t}\n    .wan{\n        .sc(16px, #333)\n    }\n    .homepageDiv{\n        width: 100%;\n        display: flex;\n        justify-content: center;\n        align-items: center;\n        .homepageDivPNG {\n            max-width: 100%;\n        }\n\n    }\n</style>\n\n\n\n// WEBPACK FOOTER //\n// src/page/home.vue","var render = function () {var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;return _c('div',[_c('head-top'),_vm._v(\" \"),_vm._m(0)],1)}\nvar staticRenderFns = [function () {var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;return _c('div',{staticClass:\"homepageDiv\"},[_c('img',{staticClass:\"homepageDivPNG\",attrs:{\"src\":require(\"../assets/AI.png\")}})])}]\nvar esExports = { render: render, staticRenderFns: staticRenderFns }\nexport default esExports\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/vue-loader/lib/template-compiler?{\"id\":\"data-v-a489342c\",\"hasScoped\":false,\"transformToRequire\":{\"video\":[\"src\",\"poster\"],\"source\":\"src\",\"img\":\"src\",\"image\":\"xlink:href\"},\"buble\":{\"transforms\":{}}}!./node_modules/vue-loader/lib/selector.js?type=template&index=0!./src/page/home.vue\n// module id = null\n// module chunks = ","function injectStyle (ssrContext) {\n  require(\"!!../../node_modules/extract-text-webpack-plugin/dist/loader.js?{\\\"omit\\\":1,\\\"remove\\\":true}!vue-style-loader!css-loader?{\\\"sourceMap\\\":true}!../../node_modules/vue-loader/lib/style-compiler/index?{\\\"vue\\\":true,\\\"id\\\":\\\"data-v-a489342c\\\",\\\"scoped\\\":false,\\\"hasInlineConfig\\\":false}!less-loader?{\\\"sourceMap\\\":true}!../../node_modules/vue-loader/lib/selector?type=styles&index=0!./home.vue\")\n}\nvar normalizeComponent = require(\"!../../node_modules/vue-loader/lib/component-normalizer\")\n/* script */\nexport * from \"!!babel-loader!../../node_modules/vue-loader/lib/selector?type=script&index=0!./home.vue\"\nimport __vue_script__ from \"!!babel-loader!../../node_modules/vue-loader/lib/selector?type=script&index=0!./home.vue\"\n/* template */\nimport __vue_template__ from \"!!../../node_modules/vue-loader/lib/template-compiler/index?{\\\"id\\\":\\\"data-v-a489342c\\\",\\\"hasScoped\\\":false,\\\"transformToRequire\\\":{\\\"video\\\":[\\\"src\\\",\\\"poster\\\"],\\\"source\\\":\\\"src\\\",\\\"img\\\":\\\"src\\\",\\\"image\\\":\\\"xlink:href\\\"},\\\"buble\\\":{\\\"transforms\\\":{}}}!../../node_modules/vue-loader/lib/selector?type=template&index=0!./home.vue\"\n/* template functional */\nvar __vue_template_functional__ = false\n/* styles */\nvar __vue_styles__ = injectStyle\n/* scopeId */\nvar __vue_scopeId__ = null\n/* moduleIdentifier (server only) */\nvar __vue_module_identifier__ = null\nvar Component = normalizeComponent(\n  __vue_script__,\n  __vue_template__,\n  __vue_template_functional__,\n  __vue_styles__,\n  __vue_scopeId__,\n  __vue_module_identifier__\n)\n\nexport default Component.exports\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/page/home.vue\n// module id = null\n// module chunks = ","var zrUtil = require(\"zrender/lib/core/util\");\n\nvar _number = require(\"../util/number\");\n\nvar parsePercent = _number.parsePercent;\nvar STACK_PREFIX = '__ec_stack_';\n\nfunction getSeriesStackId(seriesModel) {\n  return seriesModel.get('stack') || STACK_PREFIX + seriesModel.seriesIndex;\n}\n\nfunction getAxisKey(axis) {\n  return axis.dim + axis.index;\n}\n/**\n * @param {Object} opt\n * @param {module:echarts/coord/Axis} opt.axis Only support category axis currently.\n * @param {number} opt.count Positive interger.\n * @param {number} [opt.barWidth]\n * @param {number} [opt.barMaxWidth]\n * @param {number} [opt.barGap]\n * @param {number} [opt.barCategoryGap]\n * @return {Object} {width, offset, offsetCenter} If axis.type is not 'category', return undefined.\n */\n\n\nfunction getLayoutOnAxis(opt, api) {\n  var params = [];\n  var baseAxis = opt.axis;\n  var axisKey = 'axis0';\n\n  if (baseAxis.type !== 'category') {\n    return;\n  }\n\n  var bandWidth = baseAxis.getBandWidth();\n\n  for (var i = 0; i < opt.count || 0; i++) {\n    params.push(zrUtil.defaults({\n      bandWidth: bandWidth,\n      axisKey: axisKey,\n      stackId: STACK_PREFIX + i\n    }, opt));\n  }\n\n  var widthAndOffsets = doCalBarWidthAndOffset(params, api);\n  var result = [];\n\n  for (var i = 0; i < opt.count; i++) {\n    var item = widthAndOffsets[axisKey][STACK_PREFIX + i];\n    item.offsetCenter = item.offset + item.width / 2;\n    result.push(item);\n  }\n\n  return result;\n}\n\nfunction calBarWidthAndOffset(barSeries, api) {\n  var seriesInfoList = zrUtil.map(barSeries, function (seriesModel) {\n    var data = seriesModel.getData();\n    var cartesian = seriesModel.coordinateSystem;\n    var baseAxis = cartesian.getBaseAxis();\n    var axisExtent = baseAxis.getExtent();\n    var bandWidth = baseAxis.type === 'category' ? baseAxis.getBandWidth() : Math.abs(axisExtent[1] - axisExtent[0]) / data.count();\n    var barWidth = parsePercent(seriesModel.get('barWidth'), bandWidth);\n    var barMaxWidth = parsePercent(seriesModel.get('barMaxWidth'), bandWidth);\n    var barGap = seriesModel.get('barGap');\n    var barCategoryGap = seriesModel.get('barCategoryGap');\n    return {\n      bandWidth: bandWidth,\n      barWidth: barWidth,\n      barMaxWidth: barMaxWidth,\n      barGap: barGap,\n      barCategoryGap: barCategoryGap,\n      axisKey: getAxisKey(baseAxis),\n      stackId: getSeriesStackId(seriesModel)\n    };\n  });\n  return doCalBarWidthAndOffset(seriesInfoList, api);\n}\n\nfunction doCalBarWidthAndOffset(seriesInfoList, api) {\n  // Columns info on each category axis. Key is cartesian name\n  var columnsMap = {};\n  zrUtil.each(seriesInfoList, function (seriesInfo, idx) {\n    var axisKey = seriesInfo.axisKey;\n    var bandWidth = seriesInfo.bandWidth;\n    var columnsOnAxis = columnsMap[axisKey] || {\n      bandWidth: bandWidth,\n      remainedWidth: bandWidth,\n      autoWidthCount: 0,\n      categoryGap: '20%',\n      gap: '30%',\n      stacks: {}\n    };\n    var stacks = columnsOnAxis.stacks;\n    columnsMap[axisKey] = columnsOnAxis;\n    var stackId = seriesInfo.stackId;\n\n    if (!stacks[stackId]) {\n      columnsOnAxis.autoWidthCount++;\n    }\n\n    stacks[stackId] = stacks[stackId] || {\n      width: 0,\n      maxWidth: 0\n    }; // Caution: In a single coordinate system, these barGrid attributes\n    // will be shared by series. Consider that they have default values,\n    // only the attributes set on the last series will work.\n    // Do not change this fact unless there will be a break change.\n    // TODO\n\n    var barWidth = seriesInfo.barWidth;\n\n    if (barWidth && !stacks[stackId].width) {\n      // See #6312, do not restrict width.\n      stacks[stackId].width = barWidth;\n      barWidth = Math.min(columnsOnAxis.remainedWidth, barWidth);\n      columnsOnAxis.remainedWidth -= barWidth;\n    }\n\n    var barMaxWidth = seriesInfo.barMaxWidth;\n    barMaxWidth && (stacks[stackId].maxWidth = barMaxWidth);\n    var barGap = seriesInfo.barGap;\n    barGap != null && (columnsOnAxis.gap = barGap);\n    var barCategoryGap = seriesInfo.barCategoryGap;\n    barCategoryGap != null && (columnsOnAxis.categoryGap = barCategoryGap);\n  });\n  var result = {};\n  zrUtil.each(columnsMap, function (columnsOnAxis, coordSysName) {\n    result[coordSysName] = {};\n    var stacks = columnsOnAxis.stacks;\n    var bandWidth = columnsOnAxis.bandWidth;\n    var categoryGap = parsePercent(columnsOnAxis.categoryGap, bandWidth);\n    var barGapPercent = parsePercent(columnsOnAxis.gap, 1);\n    var remainedWidth = columnsOnAxis.remainedWidth;\n    var autoWidthCount = columnsOnAxis.autoWidthCount;\n    var autoWidth = (remainedWidth - categoryGap) / (autoWidthCount + (autoWidthCount - 1) * barGapPercent);\n    autoWidth = Math.max(autoWidth, 0); // Find if any auto calculated bar exceeded maxBarWidth\n\n    zrUtil.each(stacks, function (column, stack) {\n      var maxWidth = column.maxWidth;\n\n      if (maxWidth && maxWidth < autoWidth) {\n        maxWidth = Math.min(maxWidth, remainedWidth);\n\n        if (column.width) {\n          maxWidth = Math.min(maxWidth, column.width);\n        }\n\n        remainedWidth -= maxWidth;\n        column.width = maxWidth;\n        autoWidthCount--;\n      }\n    }); // Recalculate width again\n\n    autoWidth = (remainedWidth - categoryGap) / (autoWidthCount + (autoWidthCount - 1) * barGapPercent);\n    autoWidth = Math.max(autoWidth, 0);\n    var widthSum = 0;\n    var lastColumn;\n    zrUtil.each(stacks, function (column, idx) {\n      if (!column.width) {\n        column.width = autoWidth;\n      }\n\n      lastColumn = column;\n      widthSum += column.width * (1 + barGapPercent);\n    });\n\n    if (lastColumn) {\n      widthSum -= lastColumn.width * barGapPercent;\n    }\n\n    var offset = -widthSum / 2;\n    zrUtil.each(stacks, function (column, stackId) {\n      result[coordSysName][stackId] = result[coordSysName][stackId] || {\n        offset: offset,\n        width: column.width\n      };\n      offset += column.width * (1 + barGapPercent);\n    });\n  });\n  return result;\n}\n/**\n * @param {string} seriesType\n * @param {module:echarts/model/Global} ecModel\n * @param {module:echarts/ExtensionAPI} api\n */\n\n\nfunction barLayoutGrid(seriesType, ecModel, api) {\n  var barWidthAndOffset = calBarWidthAndOffset(zrUtil.filter(ecModel.getSeriesByType(seriesType), function (seriesModel) {\n    return !ecModel.isSeriesFiltered(seriesModel) && seriesModel.coordinateSystem && seriesModel.coordinateSystem.type === 'cartesian2d';\n  }));\n  var lastStackCoords = {};\n  var lastStackCoordsOrigin = {};\n  ecModel.eachSeriesByType(seriesType, function (seriesModel) {\n    // Check series coordinate, do layout for cartesian2d only\n    if (seriesModel.coordinateSystem.type !== 'cartesian2d') {\n      return;\n    }\n\n    var data = seriesModel.getData();\n    var cartesian = seriesModel.coordinateSystem;\n    var baseAxis = cartesian.getBaseAxis();\n    var stackId = getSeriesStackId(seriesModel);\n    var columnLayoutInfo = barWidthAndOffset[getAxisKey(baseAxis)][stackId];\n    var columnOffset = columnLayoutInfo.offset;\n    var columnWidth = columnLayoutInfo.width;\n    var valueAxis = cartesian.getOtherAxis(baseAxis);\n    var barMinHeight = seriesModel.get('barMinHeight') || 0;\n    var valueAxisStart = baseAxis.onZero ? valueAxis.toGlobalCoord(valueAxis.dataToCoord(0)) : valueAxis.getGlobalExtent()[0];\n    var coordDims = [seriesModel.coordDimToDataDim('x')[0], seriesModel.coordDimToDataDim('y')[0]];\n    var coords = data.mapArray(coordDims, function (x, y) {\n      return cartesian.dataToPoint([x, y]);\n    }, true);\n    lastStackCoords[stackId] = lastStackCoords[stackId] || [];\n    lastStackCoordsOrigin[stackId] = lastStackCoordsOrigin[stackId] || []; // Fix #4243\n\n    data.setLayout({\n      offset: columnOffset,\n      size: columnWidth\n    });\n    data.each(seriesModel.coordDimToDataDim(valueAxis.dim)[0], function (value, idx) {\n      if (isNaN(value)) {\n        return;\n      }\n\n      if (!lastStackCoords[stackId][idx]) {\n        lastStackCoords[stackId][idx] = {\n          p: valueAxisStart,\n          // Positive stack\n          n: valueAxisStart // Negative stack\n\n        };\n        lastStackCoordsOrigin[stackId][idx] = {\n          p: valueAxisStart,\n          // Positive stack\n          n: valueAxisStart // Negative stack\n\n        };\n      }\n\n      var sign = value >= 0 ? 'p' : 'n';\n      var coord = coords[idx];\n      var lastCoord = lastStackCoords[stackId][idx][sign];\n      var lastCoordOrigin = lastStackCoordsOrigin[stackId][idx][sign];\n      var x;\n      var y;\n      var width;\n      var height;\n\n      if (valueAxis.isHorizontal()) {\n        x = lastCoord;\n        y = coord[1] + columnOffset;\n        width = coord[0] - lastCoordOrigin;\n        height = columnWidth;\n        lastStackCoordsOrigin[stackId][idx][sign] += width;\n\n        if (Math.abs(width) < barMinHeight) {\n          width = (width < 0 ? -1 : 1) * barMinHeight;\n        }\n\n        lastStackCoords[stackId][idx][sign] += width;\n      } else {\n        x = coord[0] + columnOffset;\n        y = lastCoord;\n        width = columnWidth;\n        height = coord[1] - lastCoordOrigin;\n        lastStackCoordsOrigin[stackId][idx][sign] += height;\n\n        if (Math.abs(height) < barMinHeight) {\n          // Include zero to has a positive bar\n          height = (height <= 0 ? -1 : 1) * barMinHeight;\n        }\n\n        lastStackCoords[stackId][idx][sign] += height;\n      }\n\n      data.setItemLayout(idx, {\n        x: x,\n        y: y,\n        width: width,\n        height: height\n      });\n    }, true);\n  }, this);\n}\n\nbarLayoutGrid.getLayoutOnAxis = getLayoutOnAxis;\nvar _default = barLayoutGrid;\nmodule.exports = _default;\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/echarts/lib/layout/barGrid.js\n// module id = m/6y\n// module chunks = 1 2","var echarts = require(\"../../echarts\");\n\nvar ATTR = '\\0_ec_interaction_mutex';\n\nfunction take(zr, resourceKey, userKey) {\n  var store = getStore(zr);\n  store[resourceKey] = userKey;\n}\n\nfunction release(zr, resourceKey, userKey) {\n  var store = getStore(zr);\n  var uKey = store[resourceKey];\n\n  if (uKey === userKey) {\n    store[resourceKey] = null;\n  }\n}\n\nfunction isTaken(zr, resourceKey) {\n  return !!getStore(zr)[resourceKey];\n}\n\nfunction getStore(zr) {\n  return zr[ATTR] || (zr[ATTR] = {});\n}\n/**\n * payload: {\n *     type: 'takeGlobalCursor',\n *     key: 'dataZoomSelect', or 'brush', or ...,\n *         If no userKey, release global cursor.\n * }\n */\n\n\necharts.registerAction({\n  type: 'takeGlobalCursor',\n  event: 'globalCursorTaken',\n  update: 'update'\n}, function () {});\nexports.take = take;\nexports.release = release;\nexports.isTaken = isTaken;\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/echarts/lib/component/helper/interactionMutex.js\n// module id = mcsk\n// module chunks = 1 2","var _config = require(\"../../config\");\n\nvar __DEV__ = _config.__DEV__;\n\nvar zrUtil = require(\"zrender/lib/core/util\");\n\nvar Eventful = require(\"zrender/lib/mixin/Eventful\");\n\nvar graphic = require(\"../../util/graphic\");\n\nvar interactionMutex = require(\"./interactionMutex\");\n\nvar DataDiffer = require(\"../../data/DataDiffer\");\n\nvar curry = zrUtil.curry;\nvar each = zrUtil.each;\nvar map = zrUtil.map;\nvar mathMin = Math.min;\nvar mathMax = Math.max;\nvar mathPow = Math.pow;\nvar COVER_Z = 10000;\nvar UNSELECT_THRESHOLD = 6;\nvar MIN_RESIZE_LINE_WIDTH = 6;\nvar MUTEX_RESOURCE_KEY = 'globalPan';\nvar DIRECTION_MAP = {\n  w: [0, 0],\n  e: [0, 1],\n  n: [1, 0],\n  s: [1, 1]\n};\nvar CURSOR_MAP = {\n  w: 'ew',\n  e: 'ew',\n  n: 'ns',\n  s: 'ns',\n  ne: 'nesw',\n  sw: 'nesw',\n  nw: 'nwse',\n  se: 'nwse'\n};\nvar DEFAULT_BRUSH_OPT = {\n  brushStyle: {\n    lineWidth: 2,\n    stroke: 'rgba(0,0,0,0.3)',\n    fill: 'rgba(0,0,0,0.1)'\n  },\n  transformable: true,\n  brushMode: 'single',\n  removeOnClick: false\n};\nvar baseUID = 0;\n/**\n * @alias module:echarts/component/helper/BrushController\n * @constructor\n * @mixin {module:zrender/mixin/Eventful}\n * @event module:echarts/component/helper/BrushController#brush\n *        params:\n *            areas: Array.<Array>, coord relates to container group,\n *                                    If no container specified, to global.\n *            opt {\n *                isEnd: boolean,\n *                removeOnClick: boolean\n *            }\n *\n * @param {module:zrender/zrender~ZRender} zr\n */\n\nfunction BrushController(zr) {\n  Eventful.call(this);\n  /**\n   * @type {module:zrender/zrender~ZRender}\n   * @private\n   */\n\n  this._zr = zr;\n  /**\n   * @type {module:zrender/container/Group}\n   * @readOnly\n   */\n\n  this.group = new graphic.Group();\n  /**\n   * Only for drawing (after enabledBrush).\n   *     'line', 'rect', 'polygon' or false\n   *     If passing false/null/undefined, disable brush.\n   *     If passing 'auto', determined by panel.defaultBrushType\n   * @private\n   * @type {string}\n   */\n\n  this._brushType;\n  /**\n   * Only for drawing (after enabledBrush).\n   *\n   * @private\n   * @type {Object}\n   */\n\n  this._brushOption;\n  /**\n   * @private\n   * @type {Object}\n   */\n\n  this._panels;\n  /**\n   * @private\n   * @type {Array.<nubmer>}\n   */\n\n  this._track = [];\n  /**\n   * @private\n   * @type {boolean}\n   */\n\n  this._dragging;\n  /**\n   * @private\n   * @type {Array}\n   */\n\n  this._covers = [];\n  /**\n   * @private\n   * @type {moudule:zrender/container/Group}\n   */\n\n  this._creatingCover;\n  /**\n   * `true` means global panel\n   * @private\n   * @type {module:zrender/container/Group|boolean}\n   */\n\n  this._creatingPanel;\n  /**\n   * @private\n   * @type {boolean}\n   */\n\n  this._enableGlobalPan;\n  /**\n   * @private\n   * @type {boolean}\n   */\n\n  /**\n   * @private\n   * @type {string}\n   */\n  this._uid = 'brushController_' + baseUID++;\n  /**\n   * @private\n   * @type {Object}\n   */\n\n  this._handlers = {};\n  each(mouseHandlers, function (handler, eventName) {\n    this._handlers[eventName] = zrUtil.bind(handler, this);\n  }, this);\n}\n\nBrushController.prototype = {\n  constructor: BrushController,\n\n  /**\n   * If set to null/undefined/false, select disabled.\n   * @param {Object} brushOption\n   * @param {string|boolean} brushOption.brushType 'line', 'rect', 'polygon' or false\n   *                          If passing false/null/undefined, disable brush.\n   *                          If passing 'auto', determined by panel.defaultBrushType.\n   *                              ('auto' can not be used in global panel)\n   * @param {number} [brushOption.brushMode='single'] 'single' or 'multiple'\n   * @param {boolean} [brushOption.transformable=true]\n   * @param {boolean} [brushOption.removeOnClick=false]\n   * @param {Object} [brushOption.brushStyle]\n   * @param {number} [brushOption.brushStyle.width]\n   * @param {number} [brushOption.brushStyle.lineWidth]\n   * @param {string} [brushOption.brushStyle.stroke]\n   * @param {string} [brushOption.brushStyle.fill]\n   * @param {number} [brushOption.z]\n   */\n  enableBrush: function (brushOption) {\n    this._brushType && doDisableBrush(this);\n    brushOption.brushType && doEnableBrush(this, brushOption);\n    return this;\n  },\n\n  /**\n   * @param {Array.<Object>} panelOpts If not pass, it is global brush.\n   *        Each items: {\n   *            panelId, // mandatory.\n   *            clipPath, // mandatory. function.\n   *            isTargetByCursor, // mandatory. function.\n   *            defaultBrushType, // optional, only used when brushType is 'auto'.\n   *            getLinearBrushOtherExtent, // optional. function.\n   *        }\n   */\n  setPanels: function (panelOpts) {\n    if (panelOpts && panelOpts.length) {\n      var panels = this._panels = {};\n      zrUtil.each(panelOpts, function (panelOpts) {\n        panels[panelOpts.panelId] = zrUtil.clone(panelOpts);\n      });\n    } else {\n      this._panels = null;\n    }\n\n    return this;\n  },\n\n  /**\n   * @param {Object} [opt]\n   * @return {boolean} [opt.enableGlobalPan=false]\n   */\n  mount: function (opt) {\n    opt = opt || {};\n    this._enableGlobalPan = opt.enableGlobalPan;\n    var thisGroup = this.group;\n\n    this._zr.add(thisGroup);\n\n    thisGroup.attr({\n      position: opt.position || [0, 0],\n      rotation: opt.rotation || 0,\n      scale: opt.scale || [1, 1]\n    });\n    this._transform = thisGroup.getLocalTransform();\n    return this;\n  },\n  eachCover: function (cb, context) {\n    each(this._covers, cb, context);\n  },\n\n  /**\n   * Update covers.\n   * @param {Array.<Object>} brushOptionList Like:\n   *        [\n   *            {id: 'xx', brushType: 'line', range: [23, 44], brushStyle, transformable},\n   *            {id: 'yy', brushType: 'rect', range: [[23, 44], [23, 54]]},\n   *            ...\n   *        ]\n   *        `brushType` is required in each cover info. (can not be 'auto')\n   *        `id` is not mandatory.\n   *        `brushStyle`, `transformable` is not mandatory, use DEFAULT_BRUSH_OPT by default.\n   *        If brushOptionList is null/undefined, all covers removed.\n   */\n  updateCovers: function (brushOptionList) {\n    brushOptionList = zrUtil.map(brushOptionList, function (brushOption) {\n      return zrUtil.merge(zrUtil.clone(DEFAULT_BRUSH_OPT), brushOption, true);\n    });\n    var tmpIdPrefix = '\\0-brush-index-';\n    var oldCovers = this._covers;\n    var newCovers = this._covers = [];\n    var controller = this;\n    var creatingCover = this._creatingCover;\n    new DataDiffer(oldCovers, brushOptionList, oldGetKey, getKey).add(addOrUpdate).update(addOrUpdate).remove(remove).execute();\n    return this;\n\n    function getKey(brushOption, index) {\n      return (brushOption.id != null ? brushOption.id : tmpIdPrefix + index) + '-' + brushOption.brushType;\n    }\n\n    function oldGetKey(cover, index) {\n      return getKey(cover.__brushOption, index);\n    }\n\n    function addOrUpdate(newIndex, oldIndex) {\n      var newBrushOption = brushOptionList[newIndex]; // Consider setOption in event listener of brushSelect,\n      // where updating cover when creating should be forbiden.\n\n      if (oldIndex != null && oldCovers[oldIndex] === creatingCover) {\n        newCovers[newIndex] = oldCovers[oldIndex];\n      } else {\n        var cover = newCovers[newIndex] = oldIndex != null ? (oldCovers[oldIndex].__brushOption = newBrushOption, oldCovers[oldIndex]) : endCreating(controller, createCover(controller, newBrushOption));\n        updateCoverAfterCreation(controller, cover);\n      }\n    }\n\n    function remove(oldIndex) {\n      if (oldCovers[oldIndex] !== creatingCover) {\n        controller.group.remove(oldCovers[oldIndex]);\n      }\n    }\n  },\n  unmount: function () {\n    this.enableBrush(false); // container may 'removeAll' outside.\n\n    clearCovers(this);\n\n    this._zr.remove(this.group);\n\n    return this;\n  },\n  dispose: function () {\n    this.unmount();\n    this.off();\n  }\n};\nzrUtil.mixin(BrushController, Eventful);\n\nfunction doEnableBrush(controller, brushOption) {\n  var zr = controller._zr; // Consider roam, which takes globalPan too.\n\n  if (!controller._enableGlobalPan) {\n    interactionMutex.take(zr, MUTEX_RESOURCE_KEY, controller._uid);\n  }\n\n  each(controller._handlers, function (handler, eventName) {\n    zr.on(eventName, handler);\n  });\n  controller._brushType = brushOption.brushType;\n  controller._brushOption = zrUtil.merge(zrUtil.clone(DEFAULT_BRUSH_OPT), brushOption, true);\n}\n\nfunction doDisableBrush(controller) {\n  var zr = controller._zr;\n  interactionMutex.release(zr, MUTEX_RESOURCE_KEY, controller._uid);\n  each(controller._handlers, function (handler, eventName) {\n    zr.off(eventName, handler);\n  });\n  controller._brushType = controller._brushOption = null;\n}\n\nfunction createCover(controller, brushOption) {\n  var cover = coverRenderers[brushOption.brushType].createCover(controller, brushOption);\n  cover.__brushOption = brushOption;\n  updateZ(cover, brushOption);\n  controller.group.add(cover);\n  return cover;\n}\n\nfunction endCreating(controller, creatingCover) {\n  var coverRenderer = getCoverRenderer(creatingCover);\n\n  if (coverRenderer.endCreating) {\n    coverRenderer.endCreating(controller, creatingCover);\n    updateZ(creatingCover, creatingCover.__brushOption);\n  }\n\n  return creatingCover;\n}\n\nfunction updateCoverShape(controller, cover) {\n  var brushOption = cover.__brushOption;\n  getCoverRenderer(cover).updateCoverShape(controller, cover, brushOption.range, brushOption);\n}\n\nfunction updateZ(cover, brushOption) {\n  var z = brushOption.z;\n  z == null && (z = COVER_Z);\n  cover.traverse(function (el) {\n    el.z = z;\n    el.z2 = z; // Consider in given container.\n  });\n}\n\nfunction updateCoverAfterCreation(controller, cover) {\n  getCoverRenderer(cover).updateCommon(controller, cover);\n  updateCoverShape(controller, cover);\n}\n\nfunction getCoverRenderer(cover) {\n  return coverRenderers[cover.__brushOption.brushType];\n} // return target panel or `true` (means global panel)\n\n\nfunction getPanelByPoint(controller, e, localCursorPoint) {\n  var panels = controller._panels;\n\n  if (!panels) {\n    return true; // Global panel\n  }\n\n  var panel;\n  var transform = controller._transform;\n  each(panels, function (pn) {\n    pn.isTargetByCursor(e, localCursorPoint, transform) && (panel = pn);\n  });\n  return panel;\n} // Return a panel or true\n\n\nfunction getPanelByCover(controller, cover) {\n  var panels = controller._panels;\n\n  if (!panels) {\n    return true; // Global panel\n  }\n\n  var panelId = cover.__brushOption.panelId; // User may give cover without coord sys info,\n  // which is then treated as global panel.\n\n  return panelId != null ? panels[panelId] : true;\n}\n\nfunction clearCovers(controller) {\n  var covers = controller._covers;\n  var originalLength = covers.length;\n  each(covers, function (cover) {\n    controller.group.remove(cover);\n  }, controller);\n  covers.length = 0;\n  return !!originalLength;\n}\n\nfunction trigger(controller, opt) {\n  var areas = map(controller._covers, function (cover) {\n    var brushOption = cover.__brushOption;\n    var range = zrUtil.clone(brushOption.range);\n    return {\n      brushType: brushOption.brushType,\n      panelId: brushOption.panelId,\n      range: range\n    };\n  });\n  controller.trigger('brush', areas, {\n    isEnd: !!opt.isEnd,\n    removeOnClick: !!opt.removeOnClick\n  });\n}\n\nfunction shouldShowCover(controller) {\n  var track = controller._track;\n\n  if (!track.length) {\n    return false;\n  }\n\n  var p2 = track[track.length - 1];\n  var p1 = track[0];\n  var dx = p2[0] - p1[0];\n  var dy = p2[1] - p1[1];\n  var dist = mathPow(dx * dx + dy * dy, 0.5);\n  return dist > UNSELECT_THRESHOLD;\n}\n\nfunction getTrackEnds(track) {\n  var tail = track.length - 1;\n  tail < 0 && (tail = 0);\n  return [track[0], track[tail]];\n}\n\nfunction createBaseRectCover(doDrift, controller, brushOption, edgeNames) {\n  var cover = new graphic.Group();\n  cover.add(new graphic.Rect({\n    name: 'main',\n    style: makeStyle(brushOption),\n    silent: true,\n    draggable: true,\n    cursor: 'move',\n    drift: curry(doDrift, controller, cover, 'nswe'),\n    ondragend: curry(trigger, controller, {\n      isEnd: true\n    })\n  }));\n  each(edgeNames, function (name) {\n    cover.add(new graphic.Rect({\n      name: name,\n      style: {\n        opacity: 0\n      },\n      draggable: true,\n      silent: true,\n      invisible: true,\n      drift: curry(doDrift, controller, cover, name),\n      ondragend: curry(trigger, controller, {\n        isEnd: true\n      })\n    }));\n  });\n  return cover;\n}\n\nfunction updateBaseRect(controller, cover, localRange, brushOption) {\n  var lineWidth = brushOption.brushStyle.lineWidth || 0;\n  var handleSize = mathMax(lineWidth, MIN_RESIZE_LINE_WIDTH);\n  var x = localRange[0][0];\n  var y = localRange[1][0];\n  var xa = x - lineWidth / 2;\n  var ya = y - lineWidth / 2;\n  var x2 = localRange[0][1];\n  var y2 = localRange[1][1];\n  var x2a = x2 - handleSize + lineWidth / 2;\n  var y2a = y2 - handleSize + lineWidth / 2;\n  var width = x2 - x;\n  var height = y2 - y;\n  var widtha = width + lineWidth;\n  var heighta = height + lineWidth;\n  updateRectShape(controller, cover, 'main', x, y, width, height);\n\n  if (brushOption.transformable) {\n    updateRectShape(controller, cover, 'w', xa, ya, handleSize, heighta);\n    updateRectShape(controller, cover, 'e', x2a, ya, handleSize, heighta);\n    updateRectShape(controller, cover, 'n', xa, ya, widtha, handleSize);\n    updateRectShape(controller, cover, 's', xa, y2a, widtha, handleSize);\n    updateRectShape(controller, cover, 'nw', xa, ya, handleSize, handleSize);\n    updateRectShape(controller, cover, 'ne', x2a, ya, handleSize, handleSize);\n    updateRectShape(controller, cover, 'sw', xa, y2a, handleSize, handleSize);\n    updateRectShape(controller, cover, 'se', x2a, y2a, handleSize, handleSize);\n  }\n}\n\nfunction updateCommon(controller, cover) {\n  var brushOption = cover.__brushOption;\n  var transformable = brushOption.transformable;\n  var mainEl = cover.childAt(0);\n  mainEl.useStyle(makeStyle(brushOption));\n  mainEl.attr({\n    silent: !transformable,\n    cursor: transformable ? 'move' : 'default'\n  });\n  each(['w', 'e', 'n', 's', 'se', 'sw', 'ne', 'nw'], function (name) {\n    var el = cover.childOfName(name);\n    var globalDir = getGlobalDirection(controller, name);\n    el && el.attr({\n      silent: !transformable,\n      invisible: !transformable,\n      cursor: transformable ? CURSOR_MAP[globalDir] + '-resize' : null\n    });\n  });\n}\n\nfunction updateRectShape(controller, cover, name, x, y, w, h) {\n  var el = cover.childOfName(name);\n  el && el.setShape(pointsToRect(clipByPanel(controller, cover, [[x, y], [x + w, y + h]])));\n}\n\nfunction makeStyle(brushOption) {\n  return zrUtil.defaults({\n    strokeNoScale: true\n  }, brushOption.brushStyle);\n}\n\nfunction formatRectRange(x, y, x2, y2) {\n  var min = [mathMin(x, x2), mathMin(y, y2)];\n  var max = [mathMax(x, x2), mathMax(y, y2)];\n  return [[min[0], max[0]], // x range\n  [min[1], max[1]] // y range\n  ];\n}\n\nfunction getTransform(controller) {\n  return graphic.getTransform(controller.group);\n}\n\nfunction getGlobalDirection(controller, localDirection) {\n  if (localDirection.length > 1) {\n    localDirection = localDirection.split('');\n    var globalDir = [getGlobalDirection(controller, localDirection[0]), getGlobalDirection(controller, localDirection[1])];\n    (globalDir[0] === 'e' || globalDir[0] === 'w') && globalDir.reverse();\n    return globalDir.join('');\n  } else {\n    var map = {\n      w: 'left',\n      e: 'right',\n      n: 'top',\n      s: 'bottom'\n    };\n    var inverseMap = {\n      left: 'w',\n      right: 'e',\n      top: 'n',\n      bottom: 's'\n    };\n    var globalDir = graphic.transformDirection(map[localDirection], getTransform(controller));\n    return inverseMap[globalDir];\n  }\n}\n\nfunction driftRect(toRectRange, fromRectRange, controller, cover, name, dx, dy, e) {\n  var brushOption = cover.__brushOption;\n  var rectRange = toRectRange(brushOption.range);\n  var localDelta = toLocalDelta(controller, dx, dy);\n  each(name.split(''), function (namePart) {\n    var ind = DIRECTION_MAP[namePart];\n    rectRange[ind[0]][ind[1]] += localDelta[ind[0]];\n  });\n  brushOption.range = fromRectRange(formatRectRange(rectRange[0][0], rectRange[1][0], rectRange[0][1], rectRange[1][1]));\n  updateCoverAfterCreation(controller, cover);\n  trigger(controller, {\n    isEnd: false\n  });\n}\n\nfunction driftPolygon(controller, cover, dx, dy, e) {\n  var range = cover.__brushOption.range;\n  var localDelta = toLocalDelta(controller, dx, dy);\n  each(range, function (point) {\n    point[0] += localDelta[0];\n    point[1] += localDelta[1];\n  });\n  updateCoverAfterCreation(controller, cover);\n  trigger(controller, {\n    isEnd: false\n  });\n}\n\nfunction toLocalDelta(controller, dx, dy) {\n  var thisGroup = controller.group;\n  var localD = thisGroup.transformCoordToLocal(dx, dy);\n  var localZero = thisGroup.transformCoordToLocal(0, 0);\n  return [localD[0] - localZero[0], localD[1] - localZero[1]];\n}\n\nfunction clipByPanel(controller, cover, data) {\n  var panel = getPanelByCover(controller, cover);\n  return panel && panel !== true ? panel.clipPath(data, controller._transform) : zrUtil.clone(data);\n}\n\nfunction pointsToRect(points) {\n  var xmin = mathMin(points[0][0], points[1][0]);\n  var ymin = mathMin(points[0][1], points[1][1]);\n  var xmax = mathMax(points[0][0], points[1][0]);\n  var ymax = mathMax(points[0][1], points[1][1]);\n  return {\n    x: xmin,\n    y: ymin,\n    width: xmax - xmin,\n    height: ymax - ymin\n  };\n}\n\nfunction resetCursor(controller, e, localCursorPoint) {\n  // Check active\n  if (!controller._brushType) {\n    return;\n  }\n\n  var zr = controller._zr;\n  var covers = controller._covers;\n  var currPanel = getPanelByPoint(controller, e, localCursorPoint); // Check whether in covers.\n\n  if (!controller._dragging) {\n    for (var i = 0; i < covers.length; i++) {\n      var brushOption = covers[i].__brushOption;\n\n      if (currPanel && (currPanel === true || brushOption.panelId === currPanel.panelId) && coverRenderers[brushOption.brushType].contain(covers[i], localCursorPoint[0], localCursorPoint[1])) {\n        // Use cursor style set on cover.\n        return;\n      }\n    }\n  }\n\n  currPanel && zr.setCursorStyle('crosshair');\n}\n\nfunction preventDefault(e) {\n  var rawE = e.event;\n  rawE.preventDefault && rawE.preventDefault();\n}\n\nfunction mainShapeContain(cover, x, y) {\n  return cover.childOfName('main').contain(x, y);\n}\n\nfunction updateCoverByMouse(controller, e, localCursorPoint, isEnd) {\n  var creatingCover = controller._creatingCover;\n  var panel = controller._creatingPanel;\n  var thisBrushOption = controller._brushOption;\n  var eventParams;\n\n  controller._track.push(localCursorPoint.slice());\n\n  if (shouldShowCover(controller) || creatingCover) {\n    if (panel && !creatingCover) {\n      thisBrushOption.brushMode === 'single' && clearCovers(controller);\n      var brushOption = zrUtil.clone(thisBrushOption);\n      brushOption.brushType = determineBrushType(brushOption.brushType, panel);\n      brushOption.panelId = panel === true ? null : panel.panelId;\n      creatingCover = controller._creatingCover = createCover(controller, brushOption);\n\n      controller._covers.push(creatingCover);\n    }\n\n    if (creatingCover) {\n      var coverRenderer = coverRenderers[determineBrushType(controller._brushType, panel)];\n      var coverBrushOption = creatingCover.__brushOption;\n      coverBrushOption.range = coverRenderer.getCreatingRange(clipByPanel(controller, creatingCover, controller._track));\n\n      if (isEnd) {\n        endCreating(controller, creatingCover);\n        coverRenderer.updateCommon(controller, creatingCover);\n      }\n\n      updateCoverShape(controller, creatingCover);\n      eventParams = {\n        isEnd: isEnd\n      };\n    }\n  } else if (isEnd && thisBrushOption.brushMode === 'single' && thisBrushOption.removeOnClick) {\n    // Help user to remove covers easily, only by a tiny drag, in 'single' mode.\n    // But a single click do not clear covers, because user may have casual\n    // clicks (for example, click on other component and do not expect covers\n    // disappear).\n    // Only some cover removed, trigger action, but not every click trigger action.\n    if (getPanelByPoint(controller, e, localCursorPoint) && clearCovers(controller)) {\n      eventParams = {\n        isEnd: isEnd,\n        removeOnClick: true\n      };\n    }\n  }\n\n  return eventParams;\n}\n\nfunction determineBrushType(brushType, panel) {\n  if (brushType === 'auto') {\n    return panel.defaultBrushType;\n  }\n\n  return brushType;\n}\n\nvar mouseHandlers = {\n  mousedown: function (e) {\n    if (this._dragging) {\n      // In case some browser do not support globalOut,\n      // and release mose out side the browser.\n      handleDragEnd.call(this, e);\n    } else if (!e.target || !e.target.draggable) {\n      preventDefault(e);\n      var localCursorPoint = this.group.transformCoordToLocal(e.offsetX, e.offsetY);\n      this._creatingCover = null;\n      var panel = this._creatingPanel = getPanelByPoint(this, e, localCursorPoint);\n\n      if (panel) {\n        this._dragging = true;\n        this._track = [localCursorPoint.slice()];\n      }\n    }\n  },\n  mousemove: function (e) {\n    var localCursorPoint = this.group.transformCoordToLocal(e.offsetX, e.offsetY);\n    resetCursor(this, e, localCursorPoint);\n\n    if (this._dragging) {\n      preventDefault(e);\n      var eventParams = updateCoverByMouse(this, e, localCursorPoint, false);\n      eventParams && trigger(this, eventParams);\n    }\n  },\n  mouseup: handleDragEnd //,\n  // FIXME\n  // in tooltip, globalout should not be triggered.\n  // globalout: handleDragEnd\n\n};\n\nfunction handleDragEnd(e) {\n  if (this._dragging) {\n    preventDefault(e);\n    var localCursorPoint = this.group.transformCoordToLocal(e.offsetX, e.offsetY);\n    var eventParams = updateCoverByMouse(this, e, localCursorPoint, true);\n    this._dragging = false;\n    this._track = [];\n    this._creatingCover = null; // trigger event shoule be at final, after procedure will be nested.\n\n    eventParams && trigger(this, eventParams);\n  }\n}\n/**\n * key: brushType\n * @type {Object}\n */\n\n\nvar coverRenderers = {\n  lineX: getLineRenderer(0),\n  lineY: getLineRenderer(1),\n  rect: {\n    createCover: function (controller, brushOption) {\n      return createBaseRectCover(curry(driftRect, function (range) {\n        return range;\n      }, function (range) {\n        return range;\n      }), controller, brushOption, ['w', 'e', 'n', 's', 'se', 'sw', 'ne', 'nw']);\n    },\n    getCreatingRange: function (localTrack) {\n      var ends = getTrackEnds(localTrack);\n      return formatRectRange(ends[1][0], ends[1][1], ends[0][0], ends[0][1]);\n    },\n    updateCoverShape: function (controller, cover, localRange, brushOption) {\n      updateBaseRect(controller, cover, localRange, brushOption);\n    },\n    updateCommon: updateCommon,\n    contain: mainShapeContain\n  },\n  polygon: {\n    createCover: function (controller, brushOption) {\n      var cover = new graphic.Group(); // Do not use graphic.Polygon because graphic.Polyline do not close the\n      // border of the shape when drawing, which is a better experience for user.\n\n      cover.add(new graphic.Polyline({\n        name: 'main',\n        style: makeStyle(brushOption),\n        silent: true\n      }));\n      return cover;\n    },\n    getCreatingRange: function (localTrack) {\n      return localTrack;\n    },\n    endCreating: function (controller, cover) {\n      cover.remove(cover.childAt(0)); // Use graphic.Polygon close the shape.\n\n      cover.add(new graphic.Polygon({\n        name: 'main',\n        draggable: true,\n        drift: curry(driftPolygon, controller, cover),\n        ondragend: curry(trigger, controller, {\n          isEnd: true\n        })\n      }));\n    },\n    updateCoverShape: function (controller, cover, localRange, brushOption) {\n      cover.childAt(0).setShape({\n        points: clipByPanel(controller, cover, localRange)\n      });\n    },\n    updateCommon: updateCommon,\n    contain: mainShapeContain\n  }\n};\n\nfunction getLineRenderer(xyIndex) {\n  return {\n    createCover: function (controller, brushOption) {\n      return createBaseRectCover(curry(driftRect, function (range) {\n        var rectRange = [range, [0, 100]];\n        xyIndex && rectRange.reverse();\n        return rectRange;\n      }, function (rectRange) {\n        return rectRange[xyIndex];\n      }), controller, brushOption, [['w', 'e'], ['n', 's']][xyIndex]);\n    },\n    getCreatingRange: function (localTrack) {\n      var ends = getTrackEnds(localTrack);\n      var min = mathMin(ends[0][xyIndex], ends[1][xyIndex]);\n      var max = mathMax(ends[0][xyIndex], ends[1][xyIndex]);\n      return [min, max];\n    },\n    updateCoverShape: function (controller, cover, localRange, brushOption) {\n      var otherExtent; // If brushWidth not specified, fit the panel.\n\n      var panel = getPanelByCover(controller, cover);\n\n      if (panel !== true && panel.getLinearBrushOtherExtent) {\n        otherExtent = panel.getLinearBrushOtherExtent(xyIndex, controller._transform);\n      } else {\n        var zr = controller._zr;\n        otherExtent = [0, [zr.getWidth(), zr.getHeight()][1 - xyIndex]];\n      }\n\n      var rectRange = [localRange, otherExtent];\n      xyIndex && rectRange.reverse();\n      updateBaseRect(controller, cover, rectRange, brushOption);\n    },\n    updateCommon: updateCommon,\n    contain: mainShapeContain\n  };\n}\n\nvar _default = BrushController;\nmodule.exports = _default;\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/echarts/lib/component/helper/BrushController.js\n// module id = oDOe\n// module chunks = 1 2","/**\n * Calculate slider move result.\n * Usage:\n * (1) If both handle0 and handle1 are needed to be moved, set minSpan the same as\n * maxSpan and the same as `Math.abs(handleEnd[1] - handleEnds[0])`.\n * (2) If handle0 is forbidden to cross handle1, set minSpan as `0`.\n *\n * @param {number} delta Move length.\n * @param {Array.<number>} handleEnds handleEnds[0] can be bigger then handleEnds[1].\n *              handleEnds will be modified in this method.\n * @param {Array.<number>} extent handleEnds is restricted by extent.\n *              extent[0] should less or equals than extent[1].\n * @param {number|string} handleIndex Can be 'all', means that both move the two handleEnds,\n *              where the input minSpan and maxSpan will not work.\n * @param {number} [minSpan] The range of dataZoom can not be smaller than that.\n *              If not set, handle0 and cross handle1. If set as a non-negative\n *              number (including `0`), handles will push each other when reaching\n *              the minSpan.\n * @param {number} [maxSpan] The range of dataZoom can not be larger than that.\n * @return {Array.<number>} The input handleEnds.\n */\nfunction _default(delta, handleEnds, extent, handleIndex, minSpan, maxSpan) {\n  // Normalize firstly.\n  handleEnds[0] = restrict(handleEnds[0], extent);\n  handleEnds[1] = restrict(handleEnds[1], extent);\n  delta = delta || 0;\n  var extentSpan = extent[1] - extent[0]; // Notice maxSpan and minSpan can be null/undefined.\n\n  if (minSpan != null) {\n    minSpan = restrict(minSpan, [0, extentSpan]);\n  }\n\n  if (maxSpan != null) {\n    maxSpan = Math.max(maxSpan, minSpan != null ? minSpan : 0);\n  }\n\n  if (handleIndex === 'all') {\n    minSpan = maxSpan = Math.abs(handleEnds[1] - handleEnds[0]);\n    handleIndex = 0;\n  }\n\n  var originalDistSign = getSpanSign(handleEnds, handleIndex);\n  handleEnds[handleIndex] += delta; // Restrict in extent.\n\n  var extentMinSpan = minSpan || 0;\n  var realExtent = extent.slice();\n  originalDistSign.sign < 0 ? realExtent[0] += extentMinSpan : realExtent[1] -= extentMinSpan;\n  handleEnds[handleIndex] = restrict(handleEnds[handleIndex], realExtent); // Expand span.\n\n  var currDistSign = getSpanSign(handleEnds, handleIndex);\n\n  if (minSpan != null && (currDistSign.sign !== originalDistSign.sign || currDistSign.span < minSpan)) {\n    // If minSpan exists, 'cross' is forbinden.\n    handleEnds[1 - handleIndex] = handleEnds[handleIndex] + originalDistSign.sign * minSpan;\n  } // Shrink span.\n\n\n  var currDistSign = getSpanSign(handleEnds, handleIndex);\n\n  if (maxSpan != null && currDistSign.span > maxSpan) {\n    handleEnds[1 - handleIndex] = handleEnds[handleIndex] + currDistSign.sign * maxSpan;\n  }\n\n  return handleEnds;\n}\n\nfunction getSpanSign(handleEnds, handleIndex) {\n  var dist = handleEnds[handleIndex] - handleEnds[1 - handleIndex]; // If `handleEnds[0] === handleEnds[1]`, always believe that handleEnd[0]\n  // is at left of handleEnds[1] for non-cross case.\n\n  return {\n    span: Math.abs(dist),\n    sign: dist > 0 ? -1 : dist < 0 ? 1 : handleIndex ? -1 : 1\n  };\n}\n\nfunction restrict(value, extend) {\n  return Math.min(extend[1], Math.max(extend[0], value));\n}\n\nmodule.exports = _default;\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/echarts/lib/component/helper/sliderMove.js\n// module id = og9+\n// module chunks = 1 2","var MarkerModel = require(\"./MarkerModel\");\n\nvar _default = MarkerModel.extend({\n  type: 'markPoint',\n  defaultOption: {\n    zlevel: 0,\n    z: 5,\n    symbol: 'pin',\n    symbolSize: 50,\n    //symbolRotate: 0,\n    //symbolOffset: [0, 0]\n    tooltip: {\n      trigger: 'item'\n    },\n    label: {\n      normal: {\n        show: true,\n        position: 'inside'\n      },\n      emphasis: {\n        show: true\n      }\n    },\n    itemStyle: {\n      normal: {\n        borderWidth: 2\n      }\n    }\n  }\n});\n\nmodule.exports = _default;\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/echarts/lib/component/marker/MarkPointModel.js\n// module id = orv6\n// module chunks = 1 2","'use strict';\nvar ctx = require('./_ctx');\nvar $export = require('./_export');\nvar toObject = require('./_to-object');\nvar call = require('./_iter-call');\nvar isArrayIter = require('./_is-array-iter');\nvar toLength = require('./_to-length');\nvar createProperty = require('./_create-property');\nvar getIterFn = require('./core.get-iterator-method');\n\n$export($export.S + $export.F * !require('./_iter-detect')(function (iter) { Array.from(iter); }), 'Array', {\n  // 22.1.2.1 Array.from(arrayLike, mapfn = undefined, thisArg = undefined)\n  from: function from(arrayLike /* , mapfn = undefined, thisArg = undefined */) {\n    var O = toObject(arrayLike);\n    var C = typeof this == 'function' ? this : Array;\n    var aLen = arguments.length;\n    var mapfn = aLen > 1 ? arguments[1] : undefined;\n    var mapping = mapfn !== undefined;\n    var index = 0;\n    var iterFn = getIterFn(O);\n    var length, result, step, iterator;\n    if (mapping) mapfn = ctx(mapfn, aLen > 2 ? arguments[2] : undefined, 2);\n    // if object isn't iterable or it's array with default iterator - use simple case\n    if (iterFn != undefined && !(C == Array && isArrayIter(iterFn))) {\n      for (iterator = iterFn.call(O), result = new C(); !(step = iterator.next()).done; index++) {\n        createProperty(result, index, mapping ? call(iterator, mapfn, [step.value, index], true) : step.value);\n      }\n    } else {\n      length = toLength(O.length);\n      for (result = new C(length); length > index; index++) {\n        createProperty(result, index, mapping ? mapfn(O[index], index) : O[index]);\n      }\n    }\n    result.length = index;\n    return result;\n  }\n});\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/core-js/library/modules/es6.array.from.js\n// module id = qyJz\n// module chunks = 2","var DataZoomModel = require(\"./DataZoomModel\");\n\nvar _default = DataZoomModel.extend({\n  type: 'dataZoom.select'\n});\n\nmodule.exports = _default;\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/echarts/lib/component/dataZoom/SelectZoomModel.js\n// module id = r9WW\n// module chunks = 1 2","var zrUtil = require(\"zrender/lib/core/util\");\n\nvar defaultOption = {\n  show: true,\n  zlevel: 0,\n  // 一级层叠\n  z: 0,\n  // 二级层叠\n  // 反向坐标轴\n  inverse: false,\n  // 坐标轴名字，默认为空\n  name: '',\n  // 坐标轴名字位置，支持'start' | 'middle' | 'end'\n  nameLocation: 'end',\n  // 坐标轴名字旋转，degree。\n  nameRotate: null,\n  // Adapt to axis rotate, when nameLocation is 'middle'.\n  nameTruncate: {\n    maxWidth: null,\n    ellipsis: '...',\n    placeholder: '.'\n  },\n  // 坐标轴文字样式，默认取全局样式\n  nameTextStyle: {},\n  // 文字与轴线距离\n  nameGap: 15,\n  silent: false,\n  // Default false to support tooltip.\n  triggerEvent: false,\n  // Default false to avoid legacy user event listener fail.\n  tooltip: {\n    show: false\n  },\n  axisPointer: {},\n  // 坐标轴线\n  axisLine: {\n    // 默认显示，属性show控制显示与否\n    show: true,\n    onZero: true,\n    onZeroAxisIndex: null,\n    // 属性lineStyle控制线条样式\n    lineStyle: {\n      color: '#333',\n      width: 1,\n      type: 'solid'\n    },\n    // 坐标轴两端的箭头\n    symbol: ['none', 'none'],\n    symbolSize: [10, 15]\n  },\n  // 坐标轴小标记\n  axisTick: {\n    // 属性show控制显示与否，默认显示\n    show: true,\n    // 控制小标记是否在grid里\n    inside: false,\n    // 属性length控制线长\n    length: 5,\n    // 属性lineStyle控制线条样式\n    lineStyle: {\n      width: 1\n    }\n  },\n  // 坐标轴文本标签，详见axis.axisLabel\n  axisLabel: {\n    show: true,\n    // 控制文本标签是否在grid里\n    inside: false,\n    rotate: 0,\n    showMinLabel: null,\n    // true | false | null (auto)\n    showMaxLabel: null,\n    // true | false | null (auto)\n    margin: 8,\n    // formatter: null,\n    // 其余属性默认使用全局文本样式，详见TEXTSTYLE\n    fontSize: 12\n  },\n  // 分隔线\n  splitLine: {\n    // 默认显示，属性show控制显示与否\n    show: true,\n    // 属性lineStyle（详见lineStyle）控制线条样式\n    lineStyle: {\n      color: ['#ccc'],\n      width: 1,\n      type: 'solid'\n    }\n  },\n  // 分隔区域\n  splitArea: {\n    // 默认不显示，属性show控制显示与否\n    show: false,\n    // 属性areaStyle（详见areaStyle）控制区域样式\n    areaStyle: {\n      color: ['rgba(250,250,250,0.3)', 'rgba(200,200,200,0.3)']\n    }\n  }\n};\nvar axisDefault = {};\naxisDefault.categoryAxis = zrUtil.merge({\n  // 类目起始和结束两端空白策略\n  boundaryGap: true,\n  // splitArea: {\n  // show: false\n  // },\n  splitLine: {\n    show: false\n  },\n  // 坐标轴小标记\n  axisTick: {\n    // If tick is align with label when boundaryGap is true\n    alignWithLabel: false,\n    interval: 'auto'\n  },\n  // 坐标轴文本标签，详见axis.axisLabel\n  axisLabel: {\n    interval: 'auto'\n  }\n}, defaultOption);\naxisDefault.valueAxis = zrUtil.merge({\n  // 数值起始和结束两端空白策略\n  boundaryGap: [0, 0],\n  // 最小值, 设置成 'dataMin' 则从数据中计算最小值\n  // min: null,\n  // 最大值，设置成 'dataMax' 则从数据中计算最大值\n  // max: null,\n  // Readonly prop, specifies start value of the range when using data zoom.\n  // rangeStart: null\n  // Readonly prop, specifies end value of the range when using data zoom.\n  // rangeEnd: null\n  // 脱离0值比例，放大聚焦到最终_min，_max区间\n  // scale: false,\n  // 分割段数，默认为5\n  splitNumber: 5 // Minimum interval\n  // minInterval: null\n  // maxInterval: null\n\n}, defaultOption); // FIXME\n\naxisDefault.timeAxis = zrUtil.defaults({\n  scale: true,\n  min: 'dataMin',\n  max: 'dataMax'\n}, axisDefault.valueAxis);\naxisDefault.logAxis = zrUtil.defaults({\n  scale: true,\n  logBase: 10\n}, axisDefault.valueAxis);\nvar _default = axisDefault;\nmodule.exports = _default;\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/echarts/lib/coord/axisDefault.js\n// module id = s/lY\n// module chunks = 1 2","var zrUtil = require(\"zrender/lib/core/util\");\n\nvar formatUtil = require(\"../../util/format\");\n\nvar AXIS_DIMS = ['x', 'y', 'z', 'radius', 'angle', 'single']; // Supported coords.\n\nvar COORDS = ['cartesian2d', 'polar', 'singleAxis'];\n/**\n * @param {string} coordType\n * @return {boolean}\n */\n\nfunction isCoordSupported(coordType) {\n  return zrUtil.indexOf(COORDS, coordType) >= 0;\n}\n/**\n * Create \"each\" method to iterate names.\n *\n * @pubilc\n * @param  {Array.<string>} names\n * @param  {Array.<string>=} attrs\n * @return {Function}\n */\n\n\nfunction createNameEach(names, attrs) {\n  names = names.slice();\n  var capitalNames = zrUtil.map(names, formatUtil.capitalFirst);\n  attrs = (attrs || []).slice();\n  var capitalAttrs = zrUtil.map(attrs, formatUtil.capitalFirst);\n  return function (callback, context) {\n    zrUtil.each(names, function (name, index) {\n      var nameObj = {\n        name: name,\n        capital: capitalNames[index]\n      };\n\n      for (var j = 0; j < attrs.length; j++) {\n        nameObj[attrs[j]] = name + capitalAttrs[j];\n      }\n\n      callback.call(context, nameObj);\n    });\n  };\n}\n/**\n * Iterate each dimension name.\n *\n * @public\n * @param {Function} callback The parameter is like:\n *                            {\n *                                name: 'angle',\n *                                capital: 'Angle',\n *                                axis: 'angleAxis',\n *                                axisIndex: 'angleAixs',\n *                                index: 'angleIndex'\n *                            }\n * @param {Object} context\n */\n\n\nvar eachAxisDim = createNameEach(AXIS_DIMS, ['axisIndex', 'axis', 'index', 'id']);\n/**\n * If tow dataZoomModels has the same axis controlled, we say that they are 'linked'.\n * dataZoomModels and 'links' make up one or more graphics.\n * This function finds the graphic where the source dataZoomModel is in.\n *\n * @public\n * @param {Function} forEachNode Node iterator.\n * @param {Function} forEachEdgeType edgeType iterator\n * @param {Function} edgeIdGetter Giving node and edgeType, return an array of edge id.\n * @return {Function} Input: sourceNode, Output: Like {nodes: [], dims: {}}\n */\n\nfunction createLinkedNodesFinder(forEachNode, forEachEdgeType, edgeIdGetter) {\n  return function (sourceNode) {\n    var result = {\n      nodes: [],\n      records: {} // key: edgeType.name, value: Object (key: edge id, value: boolean).\n\n    };\n    forEachEdgeType(function (edgeType) {\n      result.records[edgeType.name] = {};\n    });\n\n    if (!sourceNode) {\n      return result;\n    }\n\n    absorb(sourceNode, result);\n    var existsLink;\n\n    do {\n      existsLink = false;\n      forEachNode(processSingleNode);\n    } while (existsLink);\n\n    function processSingleNode(node) {\n      if (!isNodeAbsorded(node, result) && isLinked(node, result)) {\n        absorb(node, result);\n        existsLink = true;\n      }\n    }\n\n    return result;\n  };\n\n  function isNodeAbsorded(node, result) {\n    return zrUtil.indexOf(result.nodes, node) >= 0;\n  }\n\n  function isLinked(node, result) {\n    var hasLink = false;\n    forEachEdgeType(function (edgeType) {\n      zrUtil.each(edgeIdGetter(node, edgeType) || [], function (edgeId) {\n        result.records[edgeType.name][edgeId] && (hasLink = true);\n      });\n    });\n    return hasLink;\n  }\n\n  function absorb(node, result) {\n    result.nodes.push(node);\n    forEachEdgeType(function (edgeType) {\n      zrUtil.each(edgeIdGetter(node, edgeType) || [], function (edgeId) {\n        result.records[edgeType.name][edgeId] = true;\n      });\n    });\n  }\n}\n\nexports.isCoordSupported = isCoordSupported;\nexports.createNameEach = createNameEach;\nexports.eachAxisDim = eachAxisDim;\nexports.createLinkedNodesFinder = createLinkedNodesFinder;\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/echarts/lib/component/dataZoom/helper.js\n// module id = s1Aj\n// module chunks = 1 2","var zrUtil = require(\"zrender/lib/core/util\");\n\nvar graphic = require(\"../../util/graphic\");\n\nvar AxisBuilder = require(\"./AxisBuilder\");\n\nvar AxisView = require(\"./AxisView\");\n\nvar cartesianAxisHelper = require(\"./cartesianAxisHelper\");\n\nvar ifIgnoreOnTick = AxisBuilder.ifIgnoreOnTick;\nvar getInterval = AxisBuilder.getInterval;\nvar axisBuilderAttrs = ['axisLine', 'axisTickLabel', 'axisName'];\nvar selfBuilderAttrs = ['splitArea', 'splitLine']; // function getAlignWithLabel(model, axisModel) {\n//     var alignWithLabel = model.get('alignWithLabel');\n//     if (alignWithLabel === 'auto') {\n//         alignWithLabel = axisModel.get('axisTick.alignWithLabel');\n//     }\n//     return alignWithLabel;\n// }\n\nvar CartesianAxisView = AxisView.extend({\n  type: 'cartesianAxis',\n  axisPointerClass: 'CartesianAxisPointer',\n\n  /**\n   * @override\n   */\n  render: function (axisModel, ecModel, api, payload) {\n    this.group.removeAll();\n    var oldAxisGroup = this._axisGroup;\n    this._axisGroup = new graphic.Group();\n    this.group.add(this._axisGroup);\n\n    if (!axisModel.get('show')) {\n      return;\n    }\n\n    var gridModel = axisModel.getCoordSysModel();\n    var layout = cartesianAxisHelper.layout(gridModel, axisModel);\n    var axisBuilder = new AxisBuilder(axisModel, layout);\n    zrUtil.each(axisBuilderAttrs, axisBuilder.add, axisBuilder);\n\n    this._axisGroup.add(axisBuilder.getGroup());\n\n    zrUtil.each(selfBuilderAttrs, function (name) {\n      if (axisModel.get(name + '.show')) {\n        this['_' + name](axisModel, gridModel, layout.labelInterval);\n      }\n    }, this);\n    graphic.groupTransition(oldAxisGroup, this._axisGroup, axisModel);\n    CartesianAxisView.superCall(this, 'render', axisModel, ecModel, api, payload);\n  },\n\n  /**\n   * @param {module:echarts/coord/cartesian/AxisModel} axisModel\n   * @param {module:echarts/coord/cartesian/GridModel} gridModel\n   * @param {number|Function} labelInterval\n   * @private\n   */\n  _splitLine: function (axisModel, gridModel, labelInterval) {\n    var axis = axisModel.axis;\n\n    if (axis.scale.isBlank()) {\n      return;\n    }\n\n    var splitLineModel = axisModel.getModel('splitLine');\n    var lineStyleModel = splitLineModel.getModel('lineStyle');\n    var lineColors = lineStyleModel.get('color');\n    var lineInterval = getInterval(splitLineModel, labelInterval);\n    lineColors = zrUtil.isArray(lineColors) ? lineColors : [lineColors];\n    var gridRect = gridModel.coordinateSystem.getRect();\n    var isHorizontal = axis.isHorizontal();\n    var lineCount = 0;\n    var ticksCoords = axis.getTicksCoords();\n    var ticks = axis.scale.getTicks();\n    var showMinLabel = axisModel.get('axisLabel.showMinLabel');\n    var showMaxLabel = axisModel.get('axisLabel.showMaxLabel');\n    var p1 = [];\n    var p2 = []; // Simple optimization\n    // Batching the lines if color are the same\n\n    var lineStyle = lineStyleModel.getLineStyle();\n\n    for (var i = 0; i < ticksCoords.length; i++) {\n      if (ifIgnoreOnTick(axis, i, lineInterval, ticksCoords.length, showMinLabel, showMaxLabel)) {\n        continue;\n      }\n\n      var tickCoord = axis.toGlobalCoord(ticksCoords[i]);\n\n      if (isHorizontal) {\n        p1[0] = tickCoord;\n        p1[1] = gridRect.y;\n        p2[0] = tickCoord;\n        p2[1] = gridRect.y + gridRect.height;\n      } else {\n        p1[0] = gridRect.x;\n        p1[1] = tickCoord;\n        p2[0] = gridRect.x + gridRect.width;\n        p2[1] = tickCoord;\n      }\n\n      var colorIndex = lineCount++ % lineColors.length;\n\n      this._axisGroup.add(new graphic.Line(graphic.subPixelOptimizeLine({\n        anid: 'line_' + ticks[i],\n        shape: {\n          x1: p1[0],\n          y1: p1[1],\n          x2: p2[0],\n          y2: p2[1]\n        },\n        style: zrUtil.defaults({\n          stroke: lineColors[colorIndex]\n        }, lineStyle),\n        silent: true\n      })));\n    }\n  },\n\n  /**\n   * @param {module:echarts/coord/cartesian/AxisModel} axisModel\n   * @param {module:echarts/coord/cartesian/GridModel} gridModel\n   * @param {number|Function} labelInterval\n   * @private\n   */\n  _splitArea: function (axisModel, gridModel, labelInterval) {\n    var axis = axisModel.axis;\n\n    if (axis.scale.isBlank()) {\n      return;\n    }\n\n    var splitAreaModel = axisModel.getModel('splitArea');\n    var areaStyleModel = splitAreaModel.getModel('areaStyle');\n    var areaColors = areaStyleModel.get('color');\n    var gridRect = gridModel.coordinateSystem.getRect();\n    var ticksCoords = axis.getTicksCoords();\n    var ticks = axis.scale.getTicks();\n    var prevX = axis.toGlobalCoord(ticksCoords[0]);\n    var prevY = axis.toGlobalCoord(ticksCoords[0]);\n    var count = 0;\n    var areaInterval = getInterval(splitAreaModel, labelInterval);\n    var areaStyle = areaStyleModel.getAreaStyle();\n    areaColors = zrUtil.isArray(areaColors) ? areaColors : [areaColors];\n    var showMinLabel = axisModel.get('axisLabel.showMinLabel');\n    var showMaxLabel = axisModel.get('axisLabel.showMaxLabel');\n\n    for (var i = 1; i < ticksCoords.length; i++) {\n      if (ifIgnoreOnTick(axis, i, areaInterval, ticksCoords.length, showMinLabel, showMaxLabel)) {\n        continue;\n      }\n\n      var tickCoord = axis.toGlobalCoord(ticksCoords[i]);\n      var x;\n      var y;\n      var width;\n      var height;\n\n      if (axis.isHorizontal()) {\n        x = prevX;\n        y = gridRect.y;\n        width = tickCoord - x;\n        height = gridRect.height;\n      } else {\n        x = gridRect.x;\n        y = prevY;\n        width = gridRect.width;\n        height = tickCoord - y;\n      }\n\n      var colorIndex = count++ % areaColors.length;\n\n      this._axisGroup.add(new graphic.Rect({\n        anid: 'area_' + ticks[i],\n        shape: {\n          x: x,\n          y: y,\n          width: width,\n          height: height\n        },\n        style: zrUtil.defaults({\n          fill: areaColors[colorIndex]\n        }, areaStyle),\n        silent: true\n      }));\n\n      prevX = x + width;\n      prevY = y + height;\n    }\n  }\n});\nCartesianAxisView.extend({\n  type: 'xAxis'\n});\nCartesianAxisView.extend({\n  type: 'yAxis'\n});\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/echarts/lib/component/axis/CartesianAxisView.js\n// module id = s48c\n// module chunks = 1 2","var _config = require(\"../../config\");\n\nvar __DEV__ = _config.__DEV__;\n\nvar echarts = require(\"../../echarts\");\n\nvar zrUtil = require(\"zrender/lib/core/util\");\n\nvar env = require(\"zrender/lib/core/env\");\n\nvar modelUtil = require(\"../../util/model\");\n\nvar helper = require(\"./helper\");\n\nvar AxisProxy = require(\"./AxisProxy\");\n\nvar each = zrUtil.each;\nvar eachAxisDim = helper.eachAxisDim;\nvar DataZoomModel = echarts.extendComponentModel({\n  type: 'dataZoom',\n  dependencies: ['xAxis', 'yAxis', 'zAxis', 'radiusAxis', 'angleAxis', 'singleAxis', 'series'],\n\n  /**\n   * @protected\n   */\n  defaultOption: {\n    zlevel: 0,\n    z: 4,\n    // Higher than normal component (z: 2).\n    orient: null,\n    // Default auto by axisIndex. Possible value: 'horizontal', 'vertical'.\n    xAxisIndex: null,\n    // Default the first horizontal category axis.\n    yAxisIndex: null,\n    // Default the first vertical category axis.\n    filterMode: 'filter',\n    // Possible values: 'filter' or 'empty' or 'weakFilter'.\n    // 'filter': data items which are out of window will be removed. This option is\n    //          applicable when filtering outliers. For each data item, it will be\n    //          filtered if one of the relevant dimensions is out of the window.\n    // 'weakFilter': data items which are out of window will be removed. This option\n    //          is applicable when filtering outliers. For each data item, it will be\n    //          filtered only if all  of the relevant dimensions are out of the same\n    //          side of the window.\n    // 'empty': data items which are out of window will be set to empty.\n    //          This option is applicable when user should not neglect\n    //          that there are some data items out of window.\n    // 'none': Do not filter.\n    // Taking line chart as an example, line will be broken in\n    // the filtered points when filterModel is set to 'empty', but\n    // be connected when set to 'filter'.\n    throttle: null,\n    // Dispatch action by the fixed rate, avoid frequency.\n    // default 100. Do not throttle when use null/undefined.\n    // If animation === true and animationDurationUpdate > 0,\n    // default value is 100, otherwise 20.\n    start: 0,\n    // Start percent. 0 ~ 100\n    end: 100,\n    // End percent. 0 ~ 100\n    startValue: null,\n    // Start value. If startValue specified, start is ignored.\n    endValue: null,\n    // End value. If endValue specified, end is ignored.\n    minSpan: null,\n    // 0 ~ 100\n    maxSpan: null,\n    // 0 ~ 100\n    minValueSpan: null,\n    // The range of dataZoom can not be smaller than that.\n    maxValueSpan: null,\n    // The range of dataZoom can not be larger than that.\n    rangeMode: null // Array, can be 'value' or 'percent'.\n\n  },\n\n  /**\n   * @override\n   */\n  init: function (option, parentModel, ecModel) {\n    /**\n     * key like x_0, y_1\n     * @private\n     * @type {Object}\n     */\n    this._dataIntervalByAxis = {};\n    /**\n     * @private\n     */\n\n    this._dataInfo = {};\n    /**\n     * key like x_0, y_1\n     * @private\n     */\n\n    this._axisProxies = {};\n    /**\n     * @readOnly\n     */\n\n    this.textStyleModel;\n    /**\n     * @private\n     */\n\n    this._autoThrottle = true;\n    /**\n     * 'percent' or 'value'\n     * @private\n     */\n\n    this._rangePropMode = ['percent', 'percent'];\n    var rawOption = retrieveRaw(option);\n    this.mergeDefaultAndTheme(option, ecModel);\n    this.doInit(rawOption);\n  },\n\n  /**\n   * @override\n   */\n  mergeOption: function (newOption) {\n    var rawOption = retrieveRaw(newOption); //FIX #2591\n\n    zrUtil.merge(this.option, newOption, true);\n    this.doInit(rawOption);\n  },\n\n  /**\n   * @protected\n   */\n  doInit: function (rawOption) {\n    var thisOption = this.option; // Disable realtime view update if canvas is not supported.\n\n    if (!env.canvasSupported) {\n      thisOption.realtime = false;\n    }\n\n    this._setDefaultThrottle(rawOption);\n\n    updateRangeUse(this, rawOption);\n    each([['start', 'startValue'], ['end', 'endValue']], function (names, index) {\n      // start/end has higher priority over startValue/endValue if they\n      // both set, but we should make chart.setOption({endValue: 1000})\n      // effective, rather than chart.setOption({endValue: 1000, end: null}).\n      if (this._rangePropMode[index] === 'value') {\n        thisOption[names[0]] = null;\n      } // Otherwise do nothing and use the merge result.\n\n    }, this);\n    this.textStyleModel = this.getModel('textStyle');\n\n    this._resetTarget();\n\n    this._giveAxisProxies();\n  },\n\n  /**\n   * @private\n   */\n  _giveAxisProxies: function () {\n    var axisProxies = this._axisProxies;\n    this.eachTargetAxis(function (dimNames, axisIndex, dataZoomModel, ecModel) {\n      var axisModel = this.dependentModels[dimNames.axis][axisIndex]; // If exists, share axisProxy with other dataZoomModels.\n\n      var axisProxy = axisModel.__dzAxisProxy || ( // Use the first dataZoomModel as the main model of axisProxy.\n      axisModel.__dzAxisProxy = new AxisProxy(dimNames.name, axisIndex, this, ecModel)); // FIXME\n      // dispose __dzAxisProxy\n\n      axisProxies[dimNames.name + '_' + axisIndex] = axisProxy;\n    }, this);\n  },\n\n  /**\n   * @private\n   */\n  _resetTarget: function () {\n    var thisOption = this.option;\n\n    var autoMode = this._judgeAutoMode();\n\n    eachAxisDim(function (dimNames) {\n      var axisIndexName = dimNames.axisIndex;\n      thisOption[axisIndexName] = modelUtil.normalizeToArray(thisOption[axisIndexName]);\n    }, this);\n\n    if (autoMode === 'axisIndex') {\n      this._autoSetAxisIndex();\n    } else if (autoMode === 'orient') {\n      this._autoSetOrient();\n    }\n  },\n\n  /**\n   * @private\n   */\n  _judgeAutoMode: function () {\n    // Auto set only works for setOption at the first time.\n    // The following is user's reponsibility. So using merged\n    // option is OK.\n    var thisOption = this.option;\n    var hasIndexSpecified = false;\n    eachAxisDim(function (dimNames) {\n      // When user set axisIndex as a empty array, we think that user specify axisIndex\n      // but do not want use auto mode. Because empty array may be encountered when\n      // some error occured.\n      if (thisOption[dimNames.axisIndex] != null) {\n        hasIndexSpecified = true;\n      }\n    }, this);\n    var orient = thisOption.orient;\n\n    if (orient == null && hasIndexSpecified) {\n      return 'orient';\n    } else if (!hasIndexSpecified) {\n      if (orient == null) {\n        thisOption.orient = 'horizontal';\n      }\n\n      return 'axisIndex';\n    }\n  },\n\n  /**\n   * @private\n   */\n  _autoSetAxisIndex: function () {\n    var autoAxisIndex = true;\n    var orient = this.get('orient', true);\n    var thisOption = this.option;\n    var dependentModels = this.dependentModels;\n\n    if (autoAxisIndex) {\n      // Find axis that parallel to dataZoom as default.\n      var dimName = orient === 'vertical' ? 'y' : 'x';\n\n      if (dependentModels[dimName + 'Axis'].length) {\n        thisOption[dimName + 'AxisIndex'] = [0];\n        autoAxisIndex = false;\n      } else {\n        each(dependentModels.singleAxis, function (singleAxisModel) {\n          if (autoAxisIndex && singleAxisModel.get('orient', true) === orient) {\n            thisOption.singleAxisIndex = [singleAxisModel.componentIndex];\n            autoAxisIndex = false;\n          }\n        });\n      }\n    }\n\n    if (autoAxisIndex) {\n      // Find the first category axis as default. (consider polar)\n      eachAxisDim(function (dimNames) {\n        if (!autoAxisIndex) {\n          return;\n        }\n\n        var axisIndices = [];\n        var axisModels = this.dependentModels[dimNames.axis];\n\n        if (axisModels.length && !axisIndices.length) {\n          for (var i = 0, len = axisModels.length; i < len; i++) {\n            if (axisModels[i].get('type') === 'category') {\n              axisIndices.push(i);\n            }\n          }\n        }\n\n        thisOption[dimNames.axisIndex] = axisIndices;\n\n        if (axisIndices.length) {\n          autoAxisIndex = false;\n        }\n      }, this);\n    }\n\n    if (autoAxisIndex) {\n      // FIXME\n      // 这里是兼容ec2的写法（没指定xAxisIndex和yAxisIndex时把scatter和双数值轴折柱纳入dataZoom控制），\n      // 但是实际是否需要Grid.js#getScaleByOption来判断（考虑time，log等axis type）？\n      // If both dataZoom.xAxisIndex and dataZoom.yAxisIndex is not specified,\n      // dataZoom component auto adopts series that reference to\n      // both xAxis and yAxis which type is 'value'.\n      this.ecModel.eachSeries(function (seriesModel) {\n        if (this._isSeriesHasAllAxesTypeOf(seriesModel, 'value')) {\n          eachAxisDim(function (dimNames) {\n            var axisIndices = thisOption[dimNames.axisIndex];\n            var axisIndex = seriesModel.get(dimNames.axisIndex);\n            var axisId = seriesModel.get(dimNames.axisId);\n            var axisModel = seriesModel.ecModel.queryComponents({\n              mainType: dimNames.axis,\n              index: axisIndex,\n              id: axisId\n            })[0];\n            axisIndex = axisModel.componentIndex;\n\n            if (zrUtil.indexOf(axisIndices, axisIndex) < 0) {\n              axisIndices.push(axisIndex);\n            }\n          });\n        }\n      }, this);\n    }\n  },\n\n  /**\n   * @private\n   */\n  _autoSetOrient: function () {\n    var dim; // Find the first axis\n\n    this.eachTargetAxis(function (dimNames) {\n      !dim && (dim = dimNames.name);\n    }, this);\n    this.option.orient = dim === 'y' ? 'vertical' : 'horizontal';\n  },\n\n  /**\n   * @private\n   */\n  _isSeriesHasAllAxesTypeOf: function (seriesModel, axisType) {\n    // FIXME\n    // 需要series的xAxisIndex和yAxisIndex都首先自动设置上。\n    // 例如series.type === scatter时。\n    var is = true;\n    eachAxisDim(function (dimNames) {\n      var seriesAxisIndex = seriesModel.get(dimNames.axisIndex);\n      var axisModel = this.dependentModels[dimNames.axis][seriesAxisIndex];\n\n      if (!axisModel || axisModel.get('type') !== axisType) {\n        is = false;\n      }\n    }, this);\n    return is;\n  },\n\n  /**\n   * @private\n   */\n  _setDefaultThrottle: function (rawOption) {\n    // When first time user set throttle, auto throttle ends.\n    if (rawOption.hasOwnProperty('throttle')) {\n      this._autoThrottle = false;\n    }\n\n    if (this._autoThrottle) {\n      var globalOption = this.ecModel.option;\n      this.option.throttle = globalOption.animation && globalOption.animationDurationUpdate > 0 ? 100 : 20;\n    }\n  },\n\n  /**\n   * @public\n   */\n  getFirstTargetAxisModel: function () {\n    var firstAxisModel;\n    eachAxisDim(function (dimNames) {\n      if (firstAxisModel == null) {\n        var indices = this.get(dimNames.axisIndex);\n\n        if (indices.length) {\n          firstAxisModel = this.dependentModels[dimNames.axis][indices[0]];\n        }\n      }\n    }, this);\n    return firstAxisModel;\n  },\n\n  /**\n   * @public\n   * @param {Function} callback param: axisModel, dimNames, axisIndex, dataZoomModel, ecModel\n   */\n  eachTargetAxis: function (callback, context) {\n    var ecModel = this.ecModel;\n    eachAxisDim(function (dimNames) {\n      each(this.get(dimNames.axisIndex), function (axisIndex) {\n        callback.call(context, dimNames, axisIndex, this, ecModel);\n      }, this);\n    }, this);\n  },\n\n  /**\n   * @param {string} dimName\n   * @param {number} axisIndex\n   * @return {module:echarts/component/dataZoom/AxisProxy} If not found, return null/undefined.\n   */\n  getAxisProxy: function (dimName, axisIndex) {\n    return this._axisProxies[dimName + '_' + axisIndex];\n  },\n\n  /**\n   * @param {string} dimName\n   * @param {number} axisIndex\n   * @return {module:echarts/model/Model} If not found, return null/undefined.\n   */\n  getAxisModel: function (dimName, axisIndex) {\n    var axisProxy = this.getAxisProxy(dimName, axisIndex);\n    return axisProxy && axisProxy.getAxisModel();\n  },\n\n  /**\n   * If not specified, set to undefined.\n   *\n   * @public\n   * @param {Object} opt\n   * @param {number} [opt.start]\n   * @param {number} [opt.end]\n   * @param {number} [opt.startValue]\n   * @param {number} [opt.endValue]\n   * @param {boolean} [ignoreUpdateRangeUsg=false]\n   */\n  setRawRange: function (opt, ignoreUpdateRangeUsg) {\n    var option = this.option;\n    each([['start', 'startValue'], ['end', 'endValue']], function (names) {\n      // If only one of 'start' and 'startValue' is not null/undefined, the other\n      // should be cleared, which enable clear the option.\n      // If both of them are not set, keep option with the original value, which\n      // enable use only set start but not set end when calling `dispatchAction`.\n      // The same as 'end' and 'endValue'.\n      if (opt[names[0]] != null || opt[names[1]] != null) {\n        option[names[0]] = opt[names[0]];\n        option[names[1]] = opt[names[1]];\n      }\n    }, this);\n    !ignoreUpdateRangeUsg && updateRangeUse(this, opt);\n  },\n\n  /**\n   * @public\n   * @return {Array.<number>} [startPercent, endPercent]\n   */\n  getPercentRange: function () {\n    var axisProxy = this.findRepresentativeAxisProxy();\n\n    if (axisProxy) {\n      return axisProxy.getDataPercentWindow();\n    }\n  },\n\n  /**\n   * @public\n   * For example, chart.getModel().getComponent('dataZoom').getValueRange('y', 0);\n   *\n   * @param {string} [axisDimName]\n   * @param {number} [axisIndex]\n   * @return {Array.<number>} [startValue, endValue] value can only be '-' or finite number.\n   */\n  getValueRange: function (axisDimName, axisIndex) {\n    if (axisDimName == null && axisIndex == null) {\n      var axisProxy = this.findRepresentativeAxisProxy();\n\n      if (axisProxy) {\n        return axisProxy.getDataValueWindow();\n      }\n    } else {\n      return this.getAxisProxy(axisDimName, axisIndex).getDataValueWindow();\n    }\n  },\n\n  /**\n   * @public\n   * @param {module:echarts/model/Model} [axisModel] If axisModel given, find axisProxy\n   *      corresponding to the axisModel\n   * @return {module:echarts/component/dataZoom/AxisProxy}\n   */\n  findRepresentativeAxisProxy: function (axisModel) {\n    if (axisModel) {\n      return axisModel.__dzAxisProxy;\n    } // Find the first hosted axisProxy\n\n\n    var axisProxies = this._axisProxies;\n\n    for (var key in axisProxies) {\n      if (axisProxies.hasOwnProperty(key) && axisProxies[key].hostedBy(this)) {\n        return axisProxies[key];\n      }\n    } // If no hosted axis find not hosted axisProxy.\n    // Consider this case: dataZoomModel1 and dataZoomModel2 control the same axis,\n    // and the option.start or option.end settings are different. The percentRange\n    // should follow axisProxy.\n    // (We encounter this problem in toolbox data zoom.)\n\n\n    for (var key in axisProxies) {\n      if (axisProxies.hasOwnProperty(key) && !axisProxies[key].hostedBy(this)) {\n        return axisProxies[key];\n      }\n    }\n  },\n\n  /**\n   * @return {Array.<string>}\n   */\n  getRangePropMode: function () {\n    return this._rangePropMode.slice();\n  }\n});\n\nfunction retrieveRaw(option) {\n  var ret = {};\n  each(['start', 'end', 'startValue', 'endValue', 'throttle'], function (name) {\n    option.hasOwnProperty(name) && (ret[name] = option[name]);\n  });\n  return ret;\n}\n\nfunction updateRangeUse(dataZoomModel, rawOption) {\n  var rangePropMode = dataZoomModel._rangePropMode;\n  var rangeModeInOption = dataZoomModel.get('rangeMode');\n  each([['start', 'startValue'], ['end', 'endValue']], function (names, index) {\n    var percentSpecified = rawOption[names[0]] != null;\n    var valueSpecified = rawOption[names[1]] != null;\n\n    if (percentSpecified && !valueSpecified) {\n      rangePropMode[index] = 'percent';\n    } else if (!percentSpecified && valueSpecified) {\n      rangePropMode[index] = 'value';\n    } else if (rangeModeInOption) {\n      rangePropMode[index] = rangeModeInOption[index];\n    } else if (percentSpecified) {\n      // percentSpecified && valueSpecified\n      rangePropMode[index] = 'percent';\n    } // else remain its original setting.\n\n  });\n}\n\nvar _default = DataZoomModel;\nmodule.exports = _default;\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/echarts/lib/component/dataZoom/DataZoomModel.js\n// module id = sJ4e\n// module chunks = 1 2","var echarts = require(\"../../../echarts\");\n\nvar zrUtil = require(\"zrender/lib/core/util\");\n\nvar eventTool = require(\"zrender/lib/core/event\");\n\nvar lang = require(\"../../../lang\");\n\nvar featureManager = require(\"../featureManager\");\n\nvar dataViewLang = lang.toolbox.dataView;\nvar BLOCK_SPLITER = new Array(60).join('-');\nvar ITEM_SPLITER = '\\t';\n/**\n * Group series into two types\n *  1. on category axis, like line, bar\n *  2. others, like scatter, pie\n * @param {module:echarts/model/Global} ecModel\n * @return {Object}\n * @inner\n */\n\nfunction groupSeries(ecModel) {\n  var seriesGroupByCategoryAxis = {};\n  var otherSeries = [];\n  var meta = [];\n  ecModel.eachRawSeries(function (seriesModel) {\n    var coordSys = seriesModel.coordinateSystem;\n\n    if (coordSys && (coordSys.type === 'cartesian2d' || coordSys.type === 'polar')) {\n      var baseAxis = coordSys.getBaseAxis();\n\n      if (baseAxis.type === 'category') {\n        var key = baseAxis.dim + '_' + baseAxis.index;\n\n        if (!seriesGroupByCategoryAxis[key]) {\n          seriesGroupByCategoryAxis[key] = {\n            categoryAxis: baseAxis,\n            valueAxis: coordSys.getOtherAxis(baseAxis),\n            series: []\n          };\n          meta.push({\n            axisDim: baseAxis.dim,\n            axisIndex: baseAxis.index\n          });\n        }\n\n        seriesGroupByCategoryAxis[key].series.push(seriesModel);\n      } else {\n        otherSeries.push(seriesModel);\n      }\n    } else {\n      otherSeries.push(seriesModel);\n    }\n  });\n  return {\n    seriesGroupByCategoryAxis: seriesGroupByCategoryAxis,\n    other: otherSeries,\n    meta: meta\n  };\n}\n/**\n * Assemble content of series on cateogory axis\n * @param {Array.<module:echarts/model/Series>} series\n * @return {string}\n * @inner\n */\n\n\nfunction assembleSeriesWithCategoryAxis(series) {\n  var tables = [];\n  zrUtil.each(series, function (group, key) {\n    var categoryAxis = group.categoryAxis;\n    var valueAxis = group.valueAxis;\n    var valueAxisDim = valueAxis.dim;\n    var headers = [' '].concat(zrUtil.map(group.series, function (series) {\n      return series.name;\n    }));\n    var columns = [categoryAxis.model.getCategories()];\n    zrUtil.each(group.series, function (series) {\n      columns.push(series.getRawData().mapArray(valueAxisDim, function (val) {\n        return val;\n      }));\n    }); // Assemble table content\n\n    var lines = [headers.join(ITEM_SPLITER)];\n\n    for (var i = 0; i < columns[0].length; i++) {\n      var items = [];\n\n      for (var j = 0; j < columns.length; j++) {\n        items.push(columns[j][i]);\n      }\n\n      lines.push(items.join(ITEM_SPLITER));\n    }\n\n    tables.push(lines.join('\\n'));\n  });\n  return tables.join('\\n\\n' + BLOCK_SPLITER + '\\n\\n');\n}\n/**\n * Assemble content of other series\n * @param {Array.<module:echarts/model/Series>} series\n * @return {string}\n * @inner\n */\n\n\nfunction assembleOtherSeries(series) {\n  return zrUtil.map(series, function (series) {\n    var data = series.getRawData();\n    var lines = [series.name];\n    var vals = [];\n    data.each(data.dimensions, function () {\n      var argLen = arguments.length;\n      var dataIndex = arguments[argLen - 1];\n      var name = data.getName(dataIndex);\n\n      for (var i = 0; i < argLen - 1; i++) {\n        vals[i] = arguments[i];\n      }\n\n      lines.push((name ? name + ITEM_SPLITER : '') + vals.join(ITEM_SPLITER));\n    });\n    return lines.join('\\n');\n  }).join('\\n\\n' + BLOCK_SPLITER + '\\n\\n');\n}\n/**\n * @param {module:echarts/model/Global}\n * @return {Object}\n * @inner\n */\n\n\nfunction getContentFromModel(ecModel) {\n  var result = groupSeries(ecModel);\n  return {\n    value: zrUtil.filter([assembleSeriesWithCategoryAxis(result.seriesGroupByCategoryAxis), assembleOtherSeries(result.other)], function (str) {\n      return str.replace(/[\\n\\t\\s]/g, '');\n    }).join('\\n\\n' + BLOCK_SPLITER + '\\n\\n'),\n    meta: result.meta\n  };\n}\n\nfunction trim(str) {\n  return str.replace(/^\\s\\s*/, '').replace(/\\s\\s*$/, '');\n}\n/**\n * If a block is tsv format\n */\n\n\nfunction isTSVFormat(block) {\n  // Simple method to find out if a block is tsv format\n  var firstLine = block.slice(0, block.indexOf('\\n'));\n\n  if (firstLine.indexOf(ITEM_SPLITER) >= 0) {\n    return true;\n  }\n}\n\nvar itemSplitRegex = new RegExp('[' + ITEM_SPLITER + ']+', 'g');\n/**\n * @param {string} tsv\n * @return {Object}\n */\n\nfunction parseTSVContents(tsv) {\n  var tsvLines = tsv.split(/\\n+/g);\n  var headers = trim(tsvLines.shift()).split(itemSplitRegex);\n  var categories = [];\n  var series = zrUtil.map(headers, function (header) {\n    return {\n      name: header,\n      data: []\n    };\n  });\n\n  for (var i = 0; i < tsvLines.length; i++) {\n    var items = trim(tsvLines[i]).split(itemSplitRegex);\n    categories.push(items.shift());\n\n    for (var j = 0; j < items.length; j++) {\n      series[j] && (series[j].data[i] = items[j]);\n    }\n  }\n\n  return {\n    series: series,\n    categories: categories\n  };\n}\n/**\n * @param {string} str\n * @return {Array.<Object>}\n * @inner\n */\n\n\nfunction parseListContents(str) {\n  var lines = str.split(/\\n+/g);\n  var seriesName = trim(lines.shift());\n  var data = [];\n\n  for (var i = 0; i < lines.length; i++) {\n    var items = trim(lines[i]).split(itemSplitRegex);\n    var name = '';\n    var value;\n    var hasName = false;\n\n    if (isNaN(items[0])) {\n      // First item is name\n      hasName = true;\n      name = items[0];\n      items = items.slice(1);\n      data[i] = {\n        name: name,\n        value: []\n      };\n      value = data[i].value;\n    } else {\n      value = data[i] = [];\n    }\n\n    for (var j = 0; j < items.length; j++) {\n      value.push(+items[j]);\n    }\n\n    if (value.length === 1) {\n      hasName ? data[i].value = value[0] : data[i] = value[0];\n    }\n  }\n\n  return {\n    name: seriesName,\n    data: data\n  };\n}\n/**\n * @param {string} str\n * @param {Array.<Object>} blockMetaList\n * @return {Object}\n * @inner\n */\n\n\nfunction parseContents(str, blockMetaList) {\n  var blocks = str.split(new RegExp('\\n*' + BLOCK_SPLITER + '\\n*', 'g'));\n  var newOption = {\n    series: []\n  };\n  zrUtil.each(blocks, function (block, idx) {\n    if (isTSVFormat(block)) {\n      var result = parseTSVContents(block);\n      var blockMeta = blockMetaList[idx];\n      var axisKey = blockMeta.axisDim + 'Axis';\n\n      if (blockMeta) {\n        newOption[axisKey] = newOption[axisKey] || [];\n        newOption[axisKey][blockMeta.axisIndex] = {\n          data: result.categories\n        };\n        newOption.series = newOption.series.concat(result.series);\n      }\n    } else {\n      var result = parseListContents(block);\n      newOption.series.push(result);\n    }\n  });\n  return newOption;\n}\n/**\n * @alias {module:echarts/component/toolbox/feature/DataView}\n * @constructor\n * @param {module:echarts/model/Model} model\n */\n\n\nfunction DataView(model) {\n  this._dom = null;\n  this.model = model;\n}\n\nDataView.defaultOption = {\n  show: true,\n  readOnly: false,\n  optionToContent: null,\n  contentToOption: null,\n  icon: 'M17.5,17.3H33 M17.5,17.3H33 M45.4,29.5h-28 M11.5,2v56H51V14.8L38.4,2H11.5z M38.4,2.2v12.7H51 M45.4,41.7h-28',\n  title: zrUtil.clone(dataViewLang.title),\n  lang: zrUtil.clone(dataViewLang.lang),\n  backgroundColor: '#fff',\n  textColor: '#000',\n  textareaColor: '#fff',\n  textareaBorderColor: '#333',\n  buttonColor: '#c23531',\n  buttonTextColor: '#fff'\n};\n\nDataView.prototype.onclick = function (ecModel, api) {\n  var container = api.getDom();\n  var model = this.model;\n\n  if (this._dom) {\n    container.removeChild(this._dom);\n  }\n\n  var root = document.createElement('div');\n  root.style.cssText = 'position:absolute;left:5px;top:5px;bottom:5px;right:5px;';\n  root.style.backgroundColor = model.get('backgroundColor') || '#fff'; // Create elements\n\n  var header = document.createElement('h4');\n  var lang = model.get('lang') || [];\n  header.innerHTML = lang[0] || model.get('title');\n  header.style.cssText = 'margin: 10px 20px;';\n  header.style.color = model.get('textColor');\n  var viewMain = document.createElement('div');\n  var textarea = document.createElement('textarea');\n  viewMain.style.cssText = 'display:block;width:100%;overflow:auto;';\n  var optionToContent = model.get('optionToContent');\n  var contentToOption = model.get('contentToOption');\n  var result = getContentFromModel(ecModel);\n\n  if (typeof optionToContent === 'function') {\n    var htmlOrDom = optionToContent(api.getOption());\n\n    if (typeof htmlOrDom === 'string') {\n      viewMain.innerHTML = htmlOrDom;\n    } else if (zrUtil.isDom(htmlOrDom)) {\n      viewMain.appendChild(htmlOrDom);\n    }\n  } else {\n    // Use default textarea\n    viewMain.appendChild(textarea);\n    textarea.readOnly = model.get('readOnly');\n    textarea.style.cssText = 'width:100%;height:100%;font-family:monospace;font-size:14px;line-height:1.6rem;';\n    textarea.style.color = model.get('textColor');\n    textarea.style.borderColor = model.get('textareaBorderColor');\n    textarea.style.backgroundColor = model.get('textareaColor');\n    textarea.value = result.value;\n  }\n\n  var blockMetaList = result.meta;\n  var buttonContainer = document.createElement('div');\n  buttonContainer.style.cssText = 'position:absolute;bottom:0;left:0;right:0;';\n  var buttonStyle = 'float:right;margin-right:20px;border:none;' + 'cursor:pointer;padding:2px 5px;font-size:12px;border-radius:3px';\n  var closeButton = document.createElement('div');\n  var refreshButton = document.createElement('div');\n  buttonStyle += ';background-color:' + model.get('buttonColor');\n  buttonStyle += ';color:' + model.get('buttonTextColor');\n  var self = this;\n\n  function close() {\n    container.removeChild(root);\n    self._dom = null;\n  }\n\n  eventTool.addEventListener(closeButton, 'click', close);\n  eventTool.addEventListener(refreshButton, 'click', function () {\n    var newOption;\n\n    try {\n      if (typeof contentToOption === 'function') {\n        newOption = contentToOption(viewMain, api.getOption());\n      } else {\n        newOption = parseContents(textarea.value, blockMetaList);\n      }\n    } catch (e) {\n      close();\n      throw new Error('Data view format error ' + e);\n    }\n\n    if (newOption) {\n      api.dispatchAction({\n        type: 'changeDataView',\n        newOption: newOption\n      });\n    }\n\n    close();\n  });\n  closeButton.innerHTML = lang[1];\n  refreshButton.innerHTML = lang[2];\n  refreshButton.style.cssText = buttonStyle;\n  closeButton.style.cssText = buttonStyle;\n  !model.get('readOnly') && buttonContainer.appendChild(refreshButton);\n  buttonContainer.appendChild(closeButton); // http://stackoverflow.com/questions/6637341/use-tab-to-indent-in-textarea\n\n  eventTool.addEventListener(textarea, 'keydown', function (e) {\n    if ((e.keyCode || e.which) === 9) {\n      // get caret position/selection\n      var val = this.value;\n      var start = this.selectionStart;\n      var end = this.selectionEnd; // set textarea value to: text before caret + tab + text after caret\n\n      this.value = val.substring(0, start) + ITEM_SPLITER + val.substring(end); // put caret at right position again\n\n      this.selectionStart = this.selectionEnd = start + 1; // prevent the focus lose\n\n      eventTool.stop(e);\n    }\n  });\n  root.appendChild(header);\n  root.appendChild(viewMain);\n  root.appendChild(buttonContainer);\n  viewMain.style.height = container.clientHeight - 80 + 'px';\n  container.appendChild(root);\n  this._dom = root;\n};\n\nDataView.prototype.remove = function (ecModel, api) {\n  this._dom && api.getDom().removeChild(this._dom);\n};\n\nDataView.prototype.dispose = function (ecModel, api) {\n  this.remove(ecModel, api);\n};\n/**\n * @inner\n */\n\n\nfunction tryMergeDataOption(newData, originalData) {\n  return zrUtil.map(newData, function (newVal, idx) {\n    var original = originalData && originalData[idx];\n\n    if (zrUtil.isObject(original) && !zrUtil.isArray(original)) {\n      if (zrUtil.isObject(newVal) && !zrUtil.isArray(newVal)) {\n        newVal = newVal.value;\n      } // Original data has option\n\n\n      return zrUtil.defaults({\n        value: newVal\n      }, original);\n    } else {\n      return newVal;\n    }\n  });\n}\n\nfeatureManager.register('dataView', DataView);\necharts.registerAction({\n  type: 'changeDataView',\n  event: 'dataViewChanged',\n  update: 'prepareAndUpdate'\n}, function (payload, ecModel) {\n  var newSeriesOptList = [];\n  zrUtil.each(payload.newOption.series, function (seriesOpt) {\n    var seriesModel = ecModel.getSeriesByName(seriesOpt.name)[0];\n\n    if (!seriesModel) {\n      // New created series\n      // Geuss the series type\n      newSeriesOptList.push(zrUtil.extend({\n        // Default is scatter\n        type: 'scatter'\n      }, seriesOpt));\n    } else {\n      var originalData = seriesModel.get('data');\n      newSeriesOptList.push({\n        name: seriesOpt.name,\n        data: tryMergeDataOption(seriesOpt.data, originalData)\n      });\n    }\n  });\n  ecModel.mergeOption(zrUtil.defaults({\n    series: newSeriesOptList\n  }, payload.newOption));\n});\nvar _default = DataView;\nmodule.exports = _default;\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/echarts/lib/component/toolbox/feature/DataView.js\n// module id = u9lB\n// module chunks = 1 2","var zrUtil = require(\"zrender/lib/core/util\");\n\nvar SymbolDraw = require(\"../../chart/helper/SymbolDraw\");\n\nvar numberUtil = require(\"../../util/number\");\n\nvar List = require(\"../../data/List\");\n\nvar markerHelper = require(\"./markerHelper\");\n\nvar MarkerView = require(\"./MarkerView\");\n\nfunction updateMarkerLayout(mpData, seriesModel, api) {\n  var coordSys = seriesModel.coordinateSystem;\n  mpData.each(function (idx) {\n    var itemModel = mpData.getItemModel(idx);\n    var point;\n    var xPx = numberUtil.parsePercent(itemModel.get('x'), api.getWidth());\n    var yPx = numberUtil.parsePercent(itemModel.get('y'), api.getHeight());\n\n    if (!isNaN(xPx) && !isNaN(yPx)) {\n      point = [xPx, yPx];\n    } // Chart like bar may have there own marker positioning logic\n    else if (seriesModel.getMarkerPosition) {\n        // Use the getMarkerPoisition\n        point = seriesModel.getMarkerPosition(mpData.getValues(mpData.dimensions, idx));\n      } else if (coordSys) {\n        var x = mpData.get(coordSys.dimensions[0], idx);\n        var y = mpData.get(coordSys.dimensions[1], idx);\n        point = coordSys.dataToPoint([x, y]);\n      } // Use x, y if has any\n\n\n    if (!isNaN(xPx)) {\n      point[0] = xPx;\n    }\n\n    if (!isNaN(yPx)) {\n      point[1] = yPx;\n    }\n\n    mpData.setItemLayout(idx, point);\n  });\n}\n\nvar _default = MarkerView.extend({\n  type: 'markPoint',\n  updateLayout: function (markPointModel, ecModel, api) {\n    ecModel.eachSeries(function (seriesModel) {\n      var mpModel = seriesModel.markPointModel;\n\n      if (mpModel) {\n        updateMarkerLayout(mpModel.getData(), seriesModel, api);\n        this.markerGroupMap.get(seriesModel.id).updateLayout(mpModel);\n      }\n    }, this);\n  },\n  renderSeries: function (seriesModel, mpModel, ecModel, api) {\n    var coordSys = seriesModel.coordinateSystem;\n    var seriesId = seriesModel.id;\n    var seriesData = seriesModel.getData();\n    var symbolDrawMap = this.markerGroupMap;\n    var symbolDraw = symbolDrawMap.get(seriesId) || symbolDrawMap.set(seriesId, new SymbolDraw());\n    var mpData = createList(coordSys, seriesModel, mpModel); // FIXME\n\n    mpModel.setData(mpData);\n    updateMarkerLayout(mpModel.getData(), seriesModel, api);\n    mpData.each(function (idx) {\n      var itemModel = mpData.getItemModel(idx);\n      var symbolSize = itemModel.getShallow('symbolSize');\n\n      if (typeof symbolSize === 'function') {\n        // FIXME 这里不兼容 ECharts 2.x，2.x 貌似参数是整个数据？\n        symbolSize = symbolSize(mpModel.getRawValue(idx), mpModel.getDataParams(idx));\n      }\n\n      mpData.setItemVisual(idx, {\n        symbolSize: symbolSize,\n        color: itemModel.get('itemStyle.normal.color') || seriesData.getVisual('color'),\n        symbol: itemModel.getShallow('symbol')\n      });\n    }); // TODO Text are wrong\n\n    symbolDraw.updateData(mpData);\n    this.group.add(symbolDraw.group); // Set host model for tooltip\n    // FIXME\n\n    mpData.eachItemGraphicEl(function (el) {\n      el.traverse(function (child) {\n        child.dataModel = mpModel;\n      });\n    });\n    symbolDraw.__keep = true;\n    symbolDraw.group.silent = mpModel.get('silent') || seriesModel.get('silent');\n  }\n});\n/**\n * @inner\n * @param {module:echarts/coord/*} [coordSys]\n * @param {module:echarts/model/Series} seriesModel\n * @param {module:echarts/model/Model} mpModel\n */\n\n\nfunction createList(coordSys, seriesModel, mpModel) {\n  var coordDimsInfos;\n\n  if (coordSys) {\n    coordDimsInfos = zrUtil.map(coordSys && coordSys.dimensions, function (coordDim) {\n      var info = seriesModel.getData().getDimensionInfo(seriesModel.coordDimToDataDim(coordDim)[0]) || {}; // In map series data don't have lng and lat dimension. Fallback to same with coordSys\n\n      info.name = coordDim;\n      return info;\n    });\n  } else {\n    coordDimsInfos = [{\n      name: 'value',\n      type: 'float'\n    }];\n  }\n\n  var mpData = new List(coordDimsInfos, mpModel);\n  var dataOpt = zrUtil.map(mpModel.get('data'), zrUtil.curry(markerHelper.dataTransform, seriesModel));\n\n  if (coordSys) {\n    dataOpt = zrUtil.filter(dataOpt, zrUtil.curry(markerHelper.dataFilter, coordSys));\n  }\n\n  mpData.initData(dataOpt, null, coordSys ? markerHelper.dimValueGetter : function (item) {\n    return item.value;\n  });\n  return mpData;\n}\n\nmodule.exports = _default;\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/echarts/lib/component/marker/MarkPointView.js\n// module id = vEM8\n// module chunks = 1 2","var _util = require(\"zrender/lib/core/util\");\n\nvar retrieve = _util.retrieve;\nvar defaults = _util.defaults;\nvar extend = _util.extend;\nvar each = _util.each;\n\nvar formatUtil = require(\"../../util/format\");\n\nvar graphic = require(\"../../util/graphic\");\n\nvar Model = require(\"../../model/Model\");\n\nvar _number = require(\"../../util/number\");\n\nvar isRadianAroundZero = _number.isRadianAroundZero;\nvar remRadian = _number.remRadian;\n\nvar _symbol = require(\"../../util/symbol\");\n\nvar createSymbol = _symbol.createSymbol;\n\nvar matrixUtil = require(\"zrender/lib/core/matrix\");\n\nvar _vector = require(\"zrender/lib/core/vector\");\n\nvar v2ApplyTransform = _vector.applyTransform;\nvar PI = Math.PI;\n\nfunction makeAxisEventDataBase(axisModel) {\n  var eventData = {\n    componentType: axisModel.mainType\n  };\n  eventData[axisModel.mainType + 'Index'] = axisModel.componentIndex;\n  return eventData;\n}\n/**\n * A final axis is translated and rotated from a \"standard axis\".\n * So opt.position and opt.rotation is required.\n *\n * A standard axis is and axis from [0, 0] to [0, axisExtent[1]],\n * for example: (0, 0) ------------> (0, 50)\n *\n * nameDirection or tickDirection or labelDirection is 1 means tick\n * or label is below the standard axis, whereas is -1 means above\n * the standard axis. labelOffset means offset between label and axis,\n * which is useful when 'onZero', where axisLabel is in the grid and\n * label in outside grid.\n *\n * Tips: like always,\n * positive rotation represents anticlockwise, and negative rotation\n * represents clockwise.\n * The direction of position coordinate is the same as the direction\n * of screen coordinate.\n *\n * Do not need to consider axis 'inverse', which is auto processed by\n * axis extent.\n *\n * @param {module:zrender/container/Group} group\n * @param {Object} axisModel\n * @param {Object} opt Standard axis parameters.\n * @param {Array.<number>} opt.position [x, y]\n * @param {number} opt.rotation by radian\n * @param {number} [opt.nameDirection=1] 1 or -1 Used when nameLocation is 'middle' or 'center'.\n * @param {number} [opt.tickDirection=1] 1 or -1\n * @param {number} [opt.labelDirection=1] 1 or -1\n * @param {number} [opt.labelOffset=0] Usefull when onZero.\n * @param {string} [opt.axisLabelShow] default get from axisModel.\n * @param {string} [opt.axisName] default get from axisModel.\n * @param {number} [opt.axisNameAvailableWidth]\n * @param {number} [opt.labelRotate] by degree, default get from axisModel.\n * @param {number} [opt.labelInterval] Default label interval when label\n *                                     interval from model is null or 'auto'.\n * @param {number} [opt.strokeContainThreshold] Default label interval when label\n * @param {number} [opt.nameTruncateMaxWidth]\n */\n\n\nvar AxisBuilder = function (axisModel, opt) {\n  /**\n   * @readOnly\n   */\n  this.opt = opt;\n  /**\n   * @readOnly\n   */\n\n  this.axisModel = axisModel; // Default value\n\n  defaults(opt, {\n    labelOffset: 0,\n    nameDirection: 1,\n    tickDirection: 1,\n    labelDirection: 1,\n    silent: true\n  });\n  /**\n   * @readOnly\n   */\n\n  this.group = new graphic.Group(); // FIXME Not use a seperate text group?\n\n  var dumbGroup = new graphic.Group({\n    position: opt.position.slice(),\n    rotation: opt.rotation\n  }); // this.group.add(dumbGroup);\n  // this._dumbGroup = dumbGroup;\n\n  dumbGroup.updateTransform();\n  this._transform = dumbGroup.transform;\n  this._dumbGroup = dumbGroup;\n};\n\nAxisBuilder.prototype = {\n  constructor: AxisBuilder,\n  hasBuilder: function (name) {\n    return !!builders[name];\n  },\n  add: function (name) {\n    builders[name].call(this);\n  },\n  getGroup: function () {\n    return this.group;\n  }\n};\nvar builders = {\n  /**\n   * @private\n   */\n  axisLine: function () {\n    var opt = this.opt;\n    var axisModel = this.axisModel;\n\n    if (!axisModel.get('axisLine.show')) {\n      return;\n    }\n\n    var extent = this.axisModel.axis.getExtent();\n    var matrix = this._transform;\n    var pt1 = [extent[0], 0];\n    var pt2 = [extent[1], 0];\n\n    if (matrix) {\n      v2ApplyTransform(pt1, pt1, matrix);\n      v2ApplyTransform(pt2, pt2, matrix);\n    }\n\n    var lineStyle = extend({\n      lineCap: 'round'\n    }, axisModel.getModel('axisLine.lineStyle').getLineStyle());\n    this.group.add(new graphic.Line(graphic.subPixelOptimizeLine({\n      // Id for animation\n      anid: 'line',\n      shape: {\n        x1: pt1[0],\n        y1: pt1[1],\n        x2: pt2[0],\n        y2: pt2[1]\n      },\n      style: lineStyle,\n      strokeContainThreshold: opt.strokeContainThreshold || 5,\n      silent: true,\n      z2: 1\n    })));\n    var arrows = axisModel.get('axisLine.symbol');\n    var arrowSize = axisModel.get('axisLine.symbolSize');\n\n    if (arrows != null) {\n      if (typeof arrows === 'string') {\n        // Use the same arrow for start and end point\n        arrows = [arrows, arrows];\n      }\n\n      if (typeof arrowSize === 'string' || typeof arrowSize === 'number') {\n        // Use the same size for width and height\n        arrowSize = [arrowSize, arrowSize];\n      }\n\n      var symbolWidth = arrowSize[0];\n      var symbolHeight = arrowSize[1];\n      each([[opt.rotation + Math.PI / 2, pt1], [opt.rotation - Math.PI / 2, pt2]], function (item, index) {\n        if (arrows[index] !== 'none' && arrows[index] != null) {\n          var symbol = createSymbol(arrows[index], -symbolWidth / 2, -symbolHeight / 2, symbolWidth, symbolHeight, lineStyle.stroke, true);\n          symbol.attr({\n            rotation: item[0],\n            position: item[1],\n            silent: true\n          });\n          this.group.add(symbol);\n        }\n      }, this);\n    }\n  },\n\n  /**\n   * @private\n   */\n  axisTickLabel: function () {\n    var axisModel = this.axisModel;\n    var opt = this.opt;\n    var tickEls = buildAxisTick(this, axisModel, opt);\n    var labelEls = buildAxisLabel(this, axisModel, opt);\n    fixMinMaxLabelShow(axisModel, labelEls, tickEls);\n  },\n\n  /**\n   * @private\n   */\n  axisName: function () {\n    var opt = this.opt;\n    var axisModel = this.axisModel;\n    var name = retrieve(opt.axisName, axisModel.get('name'));\n\n    if (!name) {\n      return;\n    }\n\n    var nameLocation = axisModel.get('nameLocation');\n    var nameDirection = opt.nameDirection;\n    var textStyleModel = axisModel.getModel('nameTextStyle');\n    var gap = axisModel.get('nameGap') || 0;\n    var extent = this.axisModel.axis.getExtent();\n    var gapSignal = extent[0] > extent[1] ? -1 : 1;\n    var pos = [nameLocation === 'start' ? extent[0] - gapSignal * gap : nameLocation === 'end' ? extent[1] + gapSignal * gap : (extent[0] + extent[1]) / 2, // 'middle'\n    // Reuse labelOffset.\n    isNameLocationCenter(nameLocation) ? opt.labelOffset + nameDirection * gap : 0];\n    var labelLayout;\n    var nameRotation = axisModel.get('nameRotate');\n\n    if (nameRotation != null) {\n      nameRotation = nameRotation * PI / 180; // To radian.\n    }\n\n    var axisNameAvailableWidth;\n\n    if (isNameLocationCenter(nameLocation)) {\n      labelLayout = innerTextLayout(opt.rotation, nameRotation != null ? nameRotation : opt.rotation, // Adapt to axis.\n      nameDirection);\n    } else {\n      labelLayout = endTextLayout(opt, nameLocation, nameRotation || 0, extent);\n      axisNameAvailableWidth = opt.axisNameAvailableWidth;\n\n      if (axisNameAvailableWidth != null) {\n        axisNameAvailableWidth = Math.abs(axisNameAvailableWidth / Math.sin(labelLayout.rotation));\n        !isFinite(axisNameAvailableWidth) && (axisNameAvailableWidth = null);\n      }\n    }\n\n    var textFont = textStyleModel.getFont();\n    var truncateOpt = axisModel.get('nameTruncate', true) || {};\n    var ellipsis = truncateOpt.ellipsis;\n    var maxWidth = retrieve(opt.nameTruncateMaxWidth, truncateOpt.maxWidth, axisNameAvailableWidth); // FIXME\n    // truncate rich text? (consider performance)\n\n    var truncatedText = ellipsis != null && maxWidth != null ? formatUtil.truncateText(name, maxWidth, textFont, ellipsis, {\n      minChar: 2,\n      placeholder: truncateOpt.placeholder\n    }) : name;\n    var tooltipOpt = axisModel.get('tooltip', true);\n    var mainType = axisModel.mainType;\n    var formatterParams = {\n      componentType: mainType,\n      name: name,\n      $vars: ['name']\n    };\n    formatterParams[mainType + 'Index'] = axisModel.componentIndex;\n    var textEl = new graphic.Text({\n      // Id for animation\n      anid: 'name',\n      __fullText: name,\n      __truncatedText: truncatedText,\n      position: pos,\n      rotation: labelLayout.rotation,\n      silent: isSilent(axisModel),\n      z2: 1,\n      tooltip: tooltipOpt && tooltipOpt.show ? extend({\n        content: name,\n        formatter: function () {\n          return name;\n        },\n        formatterParams: formatterParams\n      }, tooltipOpt) : null\n    });\n    graphic.setTextStyle(textEl.style, textStyleModel, {\n      text: truncatedText,\n      textFont: textFont,\n      textFill: textStyleModel.getTextColor() || axisModel.get('axisLine.lineStyle.color'),\n      textAlign: labelLayout.textAlign,\n      textVerticalAlign: labelLayout.textVerticalAlign\n    });\n\n    if (axisModel.get('triggerEvent')) {\n      textEl.eventData = makeAxisEventDataBase(axisModel);\n      textEl.eventData.targetType = 'axisName';\n      textEl.eventData.name = name;\n    } // FIXME\n\n\n    this._dumbGroup.add(textEl);\n\n    textEl.updateTransform();\n    this.group.add(textEl);\n    textEl.decomposeTransform();\n  }\n};\n/**\n * @public\n * @static\n * @param {Object} opt\n * @param {number} axisRotation in radian\n * @param {number} textRotation in radian\n * @param {number} direction\n * @return {Object} {\n *  rotation, // according to axis\n *  textAlign,\n *  textVerticalAlign\n * }\n */\n\nvar innerTextLayout = AxisBuilder.innerTextLayout = function (axisRotation, textRotation, direction) {\n  var rotationDiff = remRadian(textRotation - axisRotation);\n  var textAlign;\n  var textVerticalAlign;\n\n  if (isRadianAroundZero(rotationDiff)) {\n    // Label is parallel with axis line.\n    textVerticalAlign = direction > 0 ? 'top' : 'bottom';\n    textAlign = 'center';\n  } else if (isRadianAroundZero(rotationDiff - PI)) {\n    // Label is inverse parallel with axis line.\n    textVerticalAlign = direction > 0 ? 'bottom' : 'top';\n    textAlign = 'center';\n  } else {\n    textVerticalAlign = 'middle';\n\n    if (rotationDiff > 0 && rotationDiff < PI) {\n      textAlign = direction > 0 ? 'right' : 'left';\n    } else {\n      textAlign = direction > 0 ? 'left' : 'right';\n    }\n  }\n\n  return {\n    rotation: rotationDiff,\n    textAlign: textAlign,\n    textVerticalAlign: textVerticalAlign\n  };\n};\n\nfunction endTextLayout(opt, textPosition, textRotate, extent) {\n  var rotationDiff = remRadian(textRotate - opt.rotation);\n  var textAlign;\n  var textVerticalAlign;\n  var inverse = extent[0] > extent[1];\n  var onLeft = textPosition === 'start' && !inverse || textPosition !== 'start' && inverse;\n\n  if (isRadianAroundZero(rotationDiff - PI / 2)) {\n    textVerticalAlign = onLeft ? 'bottom' : 'top';\n    textAlign = 'center';\n  } else if (isRadianAroundZero(rotationDiff - PI * 1.5)) {\n    textVerticalAlign = onLeft ? 'top' : 'bottom';\n    textAlign = 'center';\n  } else {\n    textVerticalAlign = 'middle';\n\n    if (rotationDiff < PI * 1.5 && rotationDiff > PI / 2) {\n      textAlign = onLeft ? 'left' : 'right';\n    } else {\n      textAlign = onLeft ? 'right' : 'left';\n    }\n  }\n\n  return {\n    rotation: rotationDiff,\n    textAlign: textAlign,\n    textVerticalAlign: textVerticalAlign\n  };\n}\n\nfunction isSilent(axisModel) {\n  var tooltipOpt = axisModel.get('tooltip');\n  return axisModel.get('silent') // Consider mouse cursor, add these restrictions.\n  || !(axisModel.get('triggerEvent') || tooltipOpt && tooltipOpt.show);\n}\n\nfunction fixMinMaxLabelShow(axisModel, labelEls, tickEls) {\n  // If min or max are user set, we need to check\n  // If the tick on min(max) are overlap on their neighbour tick\n  // If they are overlapped, we need to hide the min(max) tick label\n  var showMinLabel = axisModel.get('axisLabel.showMinLabel');\n  var showMaxLabel = axisModel.get('axisLabel.showMaxLabel'); // FIXME\n  // Have not consider onBand yet, where tick els is more than label els.\n\n  labelEls = labelEls || [];\n  tickEls = tickEls || [];\n  var firstLabel = labelEls[0];\n  var nextLabel = labelEls[1];\n  var lastLabel = labelEls[labelEls.length - 1];\n  var prevLabel = labelEls[labelEls.length - 2];\n  var firstTick = tickEls[0];\n  var nextTick = tickEls[1];\n  var lastTick = tickEls[tickEls.length - 1];\n  var prevTick = tickEls[tickEls.length - 2];\n\n  if (showMinLabel === false) {\n    ignoreEl(firstLabel);\n    ignoreEl(firstTick);\n  } else if (isTwoLabelOverlapped(firstLabel, nextLabel)) {\n    if (showMinLabel) {\n      ignoreEl(nextLabel);\n      ignoreEl(nextTick);\n    } else {\n      ignoreEl(firstLabel);\n      ignoreEl(firstTick);\n    }\n  }\n\n  if (showMaxLabel === false) {\n    ignoreEl(lastLabel);\n    ignoreEl(lastTick);\n  } else if (isTwoLabelOverlapped(prevLabel, lastLabel)) {\n    if (showMaxLabel) {\n      ignoreEl(prevLabel);\n      ignoreEl(prevTick);\n    } else {\n      ignoreEl(lastLabel);\n      ignoreEl(lastTick);\n    }\n  }\n}\n\nfunction ignoreEl(el) {\n  el && (el.ignore = true);\n}\n\nfunction isTwoLabelOverlapped(current, next, labelLayout) {\n  // current and next has the same rotation.\n  var firstRect = current && current.getBoundingRect().clone();\n  var nextRect = next && next.getBoundingRect().clone();\n\n  if (!firstRect || !nextRect) {\n    return;\n  } // When checking intersect of two rotated labels, we use mRotationBack\n  // to avoid that boundingRect is enlarge when using `boundingRect.applyTransform`.\n\n\n  var mRotationBack = matrixUtil.identity([]);\n  matrixUtil.rotate(mRotationBack, mRotationBack, -current.rotation);\n  firstRect.applyTransform(matrixUtil.mul([], mRotationBack, current.getLocalTransform()));\n  nextRect.applyTransform(matrixUtil.mul([], mRotationBack, next.getLocalTransform()));\n  return firstRect.intersect(nextRect);\n}\n\nfunction isNameLocationCenter(nameLocation) {\n  return nameLocation === 'middle' || nameLocation === 'center';\n}\n/**\n * @static\n */\n\n\nvar ifIgnoreOnTick = AxisBuilder.ifIgnoreOnTick = function (axis, i, interval, ticksCnt, showMinLabel, showMaxLabel) {\n  if (i === 0 && showMinLabel || i === ticksCnt - 1 && showMaxLabel) {\n    return false;\n  } // FIXME\n  // Have not consider label overlap (if label is too long) yet.\n\n\n  var rawTick;\n  var scale = axis.scale;\n  return scale.type === 'ordinal' && (typeof interval === 'function' ? (rawTick = scale.getTicks()[i], !interval(rawTick, scale.getLabel(rawTick))) : i % (interval + 1));\n};\n/**\n * @static\n */\n\n\nvar getInterval = AxisBuilder.getInterval = function (model, labelInterval) {\n  var interval = model.get('interval');\n\n  if (interval == null || interval == 'auto') {\n    interval = labelInterval;\n  }\n\n  return interval;\n};\n\nfunction buildAxisTick(axisBuilder, axisModel, opt) {\n  var axis = axisModel.axis;\n\n  if (!axisModel.get('axisTick.show') || axis.scale.isBlank()) {\n    return;\n  }\n\n  var tickModel = axisModel.getModel('axisTick');\n  var lineStyleModel = tickModel.getModel('lineStyle');\n  var tickLen = tickModel.get('length');\n  var tickInterval = getInterval(tickModel, opt.labelInterval);\n  var ticksCoords = axis.getTicksCoords(tickModel.get('alignWithLabel')); // FIXME\n  // Corresponds to ticksCoords ?\n\n  var ticks = axis.scale.getTicks();\n  var showMinLabel = axisModel.get('axisLabel.showMinLabel');\n  var showMaxLabel = axisModel.get('axisLabel.showMaxLabel');\n  var pt1 = [];\n  var pt2 = [];\n  var matrix = axisBuilder._transform;\n  var tickEls = [];\n  var ticksCnt = ticksCoords.length;\n\n  for (var i = 0; i < ticksCnt; i++) {\n    // Only ordinal scale support tick interval\n    if (ifIgnoreOnTick(axis, i, tickInterval, ticksCnt, showMinLabel, showMaxLabel)) {\n      continue;\n    }\n\n    var tickCoord = ticksCoords[i];\n    pt1[0] = tickCoord;\n    pt1[1] = 0;\n    pt2[0] = tickCoord;\n    pt2[1] = opt.tickDirection * tickLen;\n\n    if (matrix) {\n      v2ApplyTransform(pt1, pt1, matrix);\n      v2ApplyTransform(pt2, pt2, matrix);\n    } // Tick line, Not use group transform to have better line draw\n\n\n    var tickEl = new graphic.Line(graphic.subPixelOptimizeLine({\n      // Id for animation\n      anid: 'tick_' + ticks[i],\n      shape: {\n        x1: pt1[0],\n        y1: pt1[1],\n        x2: pt2[0],\n        y2: pt2[1]\n      },\n      style: defaults(lineStyleModel.getLineStyle(), {\n        stroke: axisModel.get('axisLine.lineStyle.color')\n      }),\n      z2: 2,\n      silent: true\n    }));\n    axisBuilder.group.add(tickEl);\n    tickEls.push(tickEl);\n  }\n\n  return tickEls;\n}\n\nfunction buildAxisLabel(axisBuilder, axisModel, opt) {\n  var axis = axisModel.axis;\n  var show = retrieve(opt.axisLabelShow, axisModel.get('axisLabel.show'));\n\n  if (!show || axis.scale.isBlank()) {\n    return;\n  }\n\n  var labelModel = axisModel.getModel('axisLabel');\n  var labelMargin = labelModel.get('margin');\n  var ticks = axis.scale.getTicks();\n  var labels = axisModel.getFormattedLabels(); // Special label rotate.\n\n  var labelRotation = (retrieve(opt.labelRotate, labelModel.get('rotate')) || 0) * PI / 180;\n  var labelLayout = innerTextLayout(opt.rotation, labelRotation, opt.labelDirection);\n  var categoryData = axisModel.get('data');\n  var labelEls = [];\n  var silent = isSilent(axisModel);\n  var triggerEvent = axisModel.get('triggerEvent');\n  var showMinLabel = axisModel.get('axisLabel.showMinLabel');\n  var showMaxLabel = axisModel.get('axisLabel.showMaxLabel');\n  each(ticks, function (tickVal, index) {\n    if (ifIgnoreOnTick(axis, index, opt.labelInterval, ticks.length, showMinLabel, showMaxLabel)) {\n      return;\n    }\n\n    var itemLabelModel = labelModel;\n\n    if (categoryData && categoryData[tickVal] && categoryData[tickVal].textStyle) {\n      itemLabelModel = new Model(categoryData[tickVal].textStyle, labelModel, axisModel.ecModel);\n    }\n\n    var textColor = itemLabelModel.getTextColor() || axisModel.get('axisLine.lineStyle.color');\n    var tickCoord = axis.dataToCoord(tickVal);\n    var pos = [tickCoord, opt.labelOffset + opt.labelDirection * labelMargin];\n    var labelStr = axis.scale.getLabel(tickVal);\n    var textEl = new graphic.Text({\n      // Id for animation\n      anid: 'label_' + tickVal,\n      position: pos,\n      rotation: labelLayout.rotation,\n      silent: silent,\n      z2: 10\n    });\n    graphic.setTextStyle(textEl.style, itemLabelModel, {\n      text: labels[index],\n      textAlign: itemLabelModel.getShallow('align', true) || labelLayout.textAlign,\n      textVerticalAlign: itemLabelModel.getShallow('verticalAlign', true) || itemLabelModel.getShallow('baseline', true) || labelLayout.textVerticalAlign,\n      textFill: typeof textColor === 'function' ? textColor( // (1) In category axis with data zoom, tick is not the original\n      // index of axis.data. So tick should not be exposed to user\n      // in category axis.\n      // (2) Compatible with previous version, which always returns labelStr.\n      // But in interval scale labelStr is like '223,445', which maked\n      // user repalce ','. So we modify it to return original val but remain\n      // it as 'string' to avoid error in replacing.\n      axis.type === 'category' ? labelStr : axis.type === 'value' ? tickVal + '' : tickVal, index) : textColor\n    }); // Pack data for mouse event\n\n    if (triggerEvent) {\n      textEl.eventData = makeAxisEventDataBase(axisModel);\n      textEl.eventData.targetType = 'axisLabel';\n      textEl.eventData.value = labelStr;\n    } // FIXME\n\n\n    axisBuilder._dumbGroup.add(textEl);\n\n    textEl.updateTransform();\n    labelEls.push(textEl);\n    axisBuilder.group.add(textEl);\n    textEl.decomposeTransform();\n  });\n  return labelEls;\n}\n\nvar _default = AxisBuilder;\nmodule.exports = _default;\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/echarts/lib/component/axis/AxisBuilder.js\n// module id = vjPX\n// module chunks = 1 2","var zrUtil = require(\"zrender/lib/core/util\");\n\nvar numberUtil = require(\"../../util/number\");\n\nvar indexOf = zrUtil.indexOf;\n\nfunction hasXOrY(item) {\n  return !(isNaN(parseFloat(item.x)) && isNaN(parseFloat(item.y)));\n}\n\nfunction hasXAndY(item) {\n  return !isNaN(parseFloat(item.x)) && !isNaN(parseFloat(item.y));\n}\n\nfunction getPrecision(data, valueAxisDim, dataIndex) {\n  var precision = -1;\n\n  do {\n    precision = Math.max(numberUtil.getPrecision(data.get(valueAxisDim, dataIndex)), precision);\n    data = data.stackedOn;\n  } while (data);\n\n  return precision;\n}\n\nfunction markerTypeCalculatorWithExtent(mlType, data, otherDataDim, targetDataDim, otherCoordIndex, targetCoordIndex) {\n  var coordArr = [];\n  var value = numCalculate(data, targetDataDim, mlType);\n  var dataIndex = data.indicesOfNearest(targetDataDim, value, true)[0];\n  coordArr[otherCoordIndex] = data.get(otherDataDim, dataIndex, true);\n  coordArr[targetCoordIndex] = data.get(targetDataDim, dataIndex, true);\n  var precision = getPrecision(data, targetDataDim, dataIndex);\n  precision = Math.min(precision, 20);\n\n  if (precision >= 0) {\n    coordArr[targetCoordIndex] = +coordArr[targetCoordIndex].toFixed(precision);\n  }\n\n  return coordArr;\n}\n\nvar curry = zrUtil.curry; // TODO Specified percent\n\nvar markerTypeCalculator = {\n  /**\n   * @method\n   * @param {module:echarts/data/List} data\n   * @param {string} baseAxisDim\n   * @param {string} valueAxisDim\n   */\n  min: curry(markerTypeCalculatorWithExtent, 'min'),\n\n  /**\n   * @method\n   * @param {module:echarts/data/List} data\n   * @param {string} baseAxisDim\n   * @param {string} valueAxisDim\n   */\n  max: curry(markerTypeCalculatorWithExtent, 'max'),\n\n  /**\n   * @method\n   * @param {module:echarts/data/List} data\n   * @param {string} baseAxisDim\n   * @param {string} valueAxisDim\n   */\n  average: curry(markerTypeCalculatorWithExtent, 'average')\n};\n/**\n * Transform markPoint data item to format used in List by do the following\n * 1. Calculate statistic like `max`, `min`, `average`\n * 2. Convert `item.xAxis`, `item.yAxis` to `item.coord` array\n * @param  {module:echarts/model/Series} seriesModel\n * @param  {module:echarts/coord/*} [coordSys]\n * @param  {Object} item\n * @return {Object}\n */\n\nfunction dataTransform(seriesModel, item) {\n  var data = seriesModel.getData();\n  var coordSys = seriesModel.coordinateSystem; // 1. If not specify the position with pixel directly\n  // 2. If `coord` is not a data array. Which uses `xAxis`,\n  // `yAxis` to specify the coord on each dimension\n  // parseFloat first because item.x and item.y can be percent string like '20%'\n\n  if (item && !hasXAndY(item) && !zrUtil.isArray(item.coord) && coordSys) {\n    var dims = coordSys.dimensions;\n    var axisInfo = getAxisInfo(item, data, coordSys, seriesModel); // Clone the option\n    // Transform the properties xAxis, yAxis, radiusAxis, angleAxis, geoCoord to value\n\n    item = zrUtil.clone(item);\n\n    if (item.type && markerTypeCalculator[item.type] && axisInfo.baseAxis && axisInfo.valueAxis) {\n      var otherCoordIndex = indexOf(dims, axisInfo.baseAxis.dim);\n      var targetCoordIndex = indexOf(dims, axisInfo.valueAxis.dim);\n      item.coord = markerTypeCalculator[item.type](data, axisInfo.baseDataDim, axisInfo.valueDataDim, otherCoordIndex, targetCoordIndex); // Force to use the value of calculated value.\n\n      item.value = item.coord[targetCoordIndex];\n    } else {\n      // FIXME Only has one of xAxis and yAxis.\n      var coord = [item.xAxis != null ? item.xAxis : item.radiusAxis, item.yAxis != null ? item.yAxis : item.angleAxis]; // Each coord support max, min, average\n\n      for (var i = 0; i < 2; i++) {\n        if (markerTypeCalculator[coord[i]]) {\n          var dataDim = seriesModel.coordDimToDataDim(dims[i])[0];\n          coord[i] = numCalculate(data, dataDim, coord[i]);\n        }\n      }\n\n      item.coord = coord;\n    }\n  }\n\n  return item;\n}\n\nfunction getAxisInfo(item, data, coordSys, seriesModel) {\n  var ret = {};\n\n  if (item.valueIndex != null || item.valueDim != null) {\n    ret.valueDataDim = item.valueIndex != null ? data.getDimension(item.valueIndex) : item.valueDim;\n    ret.valueAxis = coordSys.getAxis(seriesModel.dataDimToCoordDim(ret.valueDataDim));\n    ret.baseAxis = coordSys.getOtherAxis(ret.valueAxis);\n    ret.baseDataDim = seriesModel.coordDimToDataDim(ret.baseAxis.dim)[0];\n  } else {\n    ret.baseAxis = seriesModel.getBaseAxis();\n    ret.valueAxis = coordSys.getOtherAxis(ret.baseAxis);\n    ret.baseDataDim = seriesModel.coordDimToDataDim(ret.baseAxis.dim)[0];\n    ret.valueDataDim = seriesModel.coordDimToDataDim(ret.valueAxis.dim)[0];\n  }\n\n  return ret;\n}\n/**\n * Filter data which is out of coordinateSystem range\n * [dataFilter description]\n * @param  {module:echarts/coord/*} [coordSys]\n * @param  {Object} item\n * @return {boolean}\n */\n\n\nfunction dataFilter(coordSys, item) {\n  // Alwalys return true if there is no coordSys\n  return coordSys && coordSys.containData && item.coord && !hasXOrY(item) ? coordSys.containData(item.coord) : true;\n}\n\nfunction dimValueGetter(item, dimName, dataIndex, dimIndex) {\n  // x, y, radius, angle\n  if (dimIndex < 2) {\n    return item.coord && item.coord[dimIndex];\n  }\n\n  return item.value;\n}\n\nfunction numCalculate(data, valueDataDim, type) {\n  if (type === 'average') {\n    var sum = 0;\n    var count = 0;\n    data.each(valueDataDim, function (val, idx) {\n      if (!isNaN(val)) {\n        sum += val;\n        count++;\n      }\n    }, true);\n    return sum / count;\n  } else {\n    return data.getDataExtent(valueDataDim, true)[type === 'max' ? 1 : 0];\n  }\n}\n\nexports.dataTransform = dataTransform;\nexports.getAxisInfo = getAxisInfo;\nexports.dataFilter = dataFilter;\nexports.dimValueGetter = dimValueGetter;\nexports.numCalculate = numCalculate;\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/echarts/lib/component/marker/markerHelper.js\n// module id = vx1D\n// module chunks = 1 2","var zrUtil = require(\"zrender/lib/core/util\");\n\nvar graphic = require(\"../../util/graphic\");\n\nvar textContain = require(\"zrender/lib/contain/text\");\n\nvar formatUtil = require(\"../../util/format\");\n\nvar matrix = require(\"zrender/lib/core/matrix\");\n\nvar axisHelper = require(\"../../coord/axisHelper\");\n\nvar AxisBuilder = require(\"../axis/AxisBuilder\");\n\n/**\n * @param {module:echarts/model/Model} axisPointerModel\n */\nfunction buildElStyle(axisPointerModel) {\n  var axisPointerType = axisPointerModel.get('type');\n  var styleModel = axisPointerModel.getModel(axisPointerType + 'Style');\n  var style;\n\n  if (axisPointerType === 'line') {\n    style = styleModel.getLineStyle();\n    style.fill = null;\n  } else if (axisPointerType === 'shadow') {\n    style = styleModel.getAreaStyle();\n    style.stroke = null;\n  }\n\n  return style;\n}\n/**\n * @param {Function} labelPos {align, verticalAlign, position}\n */\n\n\nfunction buildLabelElOption(elOption, axisModel, axisPointerModel, api, labelPos) {\n  var value = axisPointerModel.get('value');\n  var text = getValueLabel(value, axisModel.axis, axisModel.ecModel, axisPointerModel.get('seriesDataIndices'), {\n    precision: axisPointerModel.get('label.precision'),\n    formatter: axisPointerModel.get('label.formatter')\n  });\n  var labelModel = axisPointerModel.getModel('label');\n  var paddings = formatUtil.normalizeCssArray(labelModel.get('padding') || 0);\n  var font = labelModel.getFont();\n  var textRect = textContain.getBoundingRect(text, font);\n  var position = labelPos.position;\n  var width = textRect.width + paddings[1] + paddings[3];\n  var height = textRect.height + paddings[0] + paddings[2]; // Adjust by align.\n\n  var align = labelPos.align;\n  align === 'right' && (position[0] -= width);\n  align === 'center' && (position[0] -= width / 2);\n  var verticalAlign = labelPos.verticalAlign;\n  verticalAlign === 'bottom' && (position[1] -= height);\n  verticalAlign === 'middle' && (position[1] -= height / 2); // Not overflow ec container\n\n  confineInContainer(position, width, height, api);\n  var bgColor = labelModel.get('backgroundColor');\n\n  if (!bgColor || bgColor === 'auto') {\n    bgColor = axisModel.get('axisLine.lineStyle.color');\n  }\n\n  elOption.label = {\n    shape: {\n      x: 0,\n      y: 0,\n      width: width,\n      height: height,\n      r: labelModel.get('borderRadius')\n    },\n    position: position.slice(),\n    // TODO: rich\n    style: {\n      text: text,\n      textFont: font,\n      textFill: labelModel.getTextColor(),\n      textPosition: 'inside',\n      fill: bgColor,\n      stroke: labelModel.get('borderColor') || 'transparent',\n      lineWidth: labelModel.get('borderWidth') || 0,\n      shadowBlur: labelModel.get('shadowBlur'),\n      shadowColor: labelModel.get('shadowColor'),\n      shadowOffsetX: labelModel.get('shadowOffsetX'),\n      shadowOffsetY: labelModel.get('shadowOffsetY')\n    },\n    // Lable should be over axisPointer.\n    z2: 10\n  };\n} // Do not overflow ec container\n\n\nfunction confineInContainer(position, width, height, api) {\n  var viewWidth = api.getWidth();\n  var viewHeight = api.getHeight();\n  position[0] = Math.min(position[0] + width, viewWidth) - width;\n  position[1] = Math.min(position[1] + height, viewHeight) - height;\n  position[0] = Math.max(position[0], 0);\n  position[1] = Math.max(position[1], 0);\n}\n/**\n * @param {number} value\n * @param {module:echarts/coord/Axis} axis\n * @param {module:echarts/model/Global} ecModel\n * @param {Object} opt\n * @param {Array.<Object>} seriesDataIndices\n * @param {number|string} opt.precision 'auto' or a number\n * @param {string|Function} opt.formatter label formatter\n */\n\n\nfunction getValueLabel(value, axis, ecModel, seriesDataIndices, opt) {\n  var text = axis.scale.getLabel( // If `precision` is set, width can be fixed (like '12.00500'), which\n  // helps to debounce when when moving label.\n  value, {\n    precision: opt.precision\n  });\n  var formatter = opt.formatter;\n\n  if (formatter) {\n    var params = {\n      value: axisHelper.getAxisRawValue(axis, value),\n      seriesData: []\n    };\n    zrUtil.each(seriesDataIndices, function (idxItem) {\n      var series = ecModel.getSeriesByIndex(idxItem.seriesIndex);\n      var dataIndex = idxItem.dataIndexInside;\n      var dataParams = series && series.getDataParams(dataIndex);\n      dataParams && params.seriesData.push(dataParams);\n    });\n\n    if (zrUtil.isString(formatter)) {\n      text = formatter.replace('{value}', text);\n    } else if (zrUtil.isFunction(formatter)) {\n      text = formatter(params);\n    }\n  }\n\n  return text;\n}\n/**\n * @param {module:echarts/coord/Axis} axis\n * @param {number} value\n * @param {Object} layoutInfo {\n *  rotation, position, labelOffset, labelDirection, labelMargin\n * }\n */\n\n\nfunction getTransformedPosition(axis, value, layoutInfo) {\n  var transform = matrix.create();\n  matrix.rotate(transform, transform, layoutInfo.rotation);\n  matrix.translate(transform, transform, layoutInfo.position);\n  return graphic.applyTransform([axis.dataToCoord(value), (layoutInfo.labelOffset || 0) + (layoutInfo.labelDirection || 1) * (layoutInfo.labelMargin || 0)], transform);\n}\n\nfunction buildCartesianSingleLabelElOption(value, elOption, layoutInfo, axisModel, axisPointerModel, api) {\n  var textLayout = AxisBuilder.innerTextLayout(layoutInfo.rotation, 0, layoutInfo.labelDirection);\n  layoutInfo.labelMargin = axisPointerModel.get('label.margin');\n  buildLabelElOption(elOption, axisModel, axisPointerModel, api, {\n    position: getTransformedPosition(axisModel.axis, value, layoutInfo),\n    align: textLayout.textAlign,\n    verticalAlign: textLayout.textVerticalAlign\n  });\n}\n/**\n * @param {Array.<number>} p1\n * @param {Array.<number>} p2\n * @param {number} [xDimIndex=0] or 1\n */\n\n\nfunction makeLineShape(p1, p2, xDimIndex) {\n  xDimIndex = xDimIndex || 0;\n  return {\n    x1: p1[xDimIndex],\n    y1: p1[1 - xDimIndex],\n    x2: p2[xDimIndex],\n    y2: p2[1 - xDimIndex]\n  };\n}\n/**\n * @param {Array.<number>} xy\n * @param {Array.<number>} wh\n * @param {number} [xDimIndex=0] or 1\n */\n\n\nfunction makeRectShape(xy, wh, xDimIndex) {\n  xDimIndex = xDimIndex || 0;\n  return {\n    x: xy[xDimIndex],\n    y: xy[1 - xDimIndex],\n    width: wh[xDimIndex],\n    height: wh[1 - xDimIndex]\n  };\n}\n\nfunction makeSectorShape(cx, cy, r0, r, startAngle, endAngle) {\n  return {\n    cx: cx,\n    cy: cy,\n    r0: r0,\n    r: r,\n    startAngle: startAngle,\n    endAngle: endAngle,\n    clockwise: true\n  };\n}\n\nexports.buildElStyle = buildElStyle;\nexports.buildLabelElOption = buildLabelElOption;\nexports.getValueLabel = getValueLabel;\nexports.getTransformedPosition = getTransformedPosition;\nexports.buildCartesianSingleLabelElOption = buildCartesianSingleLabelElOption;\nexports.makeLineShape = makeLineShape;\nexports.makeRectShape = makeRectShape;\nexports.makeSectorShape = makeSectorShape;\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/echarts/lib/component/axisPointer/viewHelper.js\n// module id = zAPJ\n// module chunks = 1 2","require(\"../coord/cartesian/AxisModel\");\n\nrequire(\"./axis/CartesianAxisView\");\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/echarts/lib/component/axis.js\n// module id = zz1u\n// module chunks = 1 2"],"sourceRoot":""}